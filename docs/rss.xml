<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ADd7</title><link>https://natsunokoide.github.io/</link><description>C++ / C# / Unity 
 You are welcome to send us your valuable comments.  E-mail:yujiaqifinn@outlook.com</description><copyright>ADd7</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://i.postimg.cc/dtT4J441/image.png</url><title>avatar</title><link>https://natsunokoide.github.io/</link></image><lastBuildDate>Sun, 11 Feb 2024 05:40:54 +0000</lastBuildDate><managingEditor>ADd7</managingEditor><ttl>60</ttl><webMaster>ADd7</webMaster><item><title>Acwing 852.spfa判断负环</title><link>https://natsunokoide.github.io//post/Acwing%20852.spfa-pan-duan-fu-huan.html</link><description>### 题目&#13;
给定一个 n个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20852.spfa-pan-duan-fu-huan.html</guid><pubDate>Sun, 11 Feb 2024 05:40:08 +0000</pubDate></item><item><title>UI.NGUI.ScrollView组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.ScrollView-zu-jian-%20.html</link><description>### ScrollView组件 &#13;
&#13;
### 作用和制作&#13;
1）ScrollView是什么&#13;
滚动视图&#13;
我们现在用于编程的VS代码窗口就是典型的滚动视图&#13;
游戏中主要用于 背包、商店、排行榜等等功能&#13;
2）制作ScrollView&#13;
1.直接工具栏创建即可 NGUI——Create——ScrollView&#13;
2.若需要ScrollBar 自行添加水平和竖直&#13;
&#13;
&gt; 第三点非常重要 如果不添加脚本和碰撞器 会拖不动&#13;
&#13;
3.添加子对象 为子对象添加Drag Scroll View和碰撞器&#13;
&#13;
### 参数&#13;
![参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/d6218278-b9fc-4b5d-9ce8-af018df870bd)&#13;
![参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/b323daee-18d1-458b-b398-80fa84903770)&#13;
![参数3](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/1eba1c22-06de-4837-be6b-87e0fb3b223d)&#13;
&#13;
### 设置30格背包格子（自己定义位置信息+更新滚动条的api）&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class BagPanel : MonoBehaviour&#13;
{&#13;
    private static BagPanel instance;&#13;
    public static BagPanel Instance =&gt; instance;&#13;
&#13;
    private void Awake()&#13;
    {&#13;
        instance = this;&#13;
    }&#13;
&#13;
    public UIScrollView sv;&#13;
    public UIButton btnClose;&#13;
&#13;
    private void Start()&#13;
    {&#13;
        //按下关闭按钮 隐藏界面&#13;
        btnClose.onClick.Add(new EventDelegate(() =&gt;&#13;
        {&#13;
            this.gameObject.SetActive(false);&#13;
        }));&#13;
&#13;
        //动态创建30格背包格子&#13;
        for (int i = 0; i &lt; 60; i++)&#13;
        {&#13;
            GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;("Item"));&#13;
            obj.transform.SetParent(sv.transform, false);&#13;
            //通过自己的代码逻辑设置框的位置&#13;
            // % + / 非常经典的一维转二维位置&#13;
            obj.transform.localPosition = new Vector3(120 * (i % 5), 120 * (i / 5), 0);&#13;
        }&#13;
&#13;
        //通过sv控制 滚动条更新&#13;
        sv.UpdateScrollbars();&#13;
&#13;
        this.gameObject.SetActive(false);&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.ScrollView-zu-jian-%20.html</guid><pubDate>Fri, 09 Feb 2024 06:03:58 +0000</pubDate></item><item><title>Acwing 851.spfa求最短路</title><link>https://natsunokoide.github.io//post/Acwing%20851.spfa-qiu-zui-duan-lu.html</link><description>### 题目&#13;
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20851.spfa-qiu-zui-duan-lu.html</guid><pubDate>Thu, 08 Feb 2024 16:24:29 +0000</pubDate></item><item><title>UI.NGUI.ScrollBar和ProgressBar组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.ScrollBar-he-ProgressBar-zu-jian.html</link><description>### ScrollBar和ProgressBar组件&#13;
### 作用&#13;
1.ScrollBar滚动条一般不单独使用 都是配合滚动视图使用 类似VS右侧的滚动条&#13;
2.ProgressBar进度条 一般不咋使用   一般直接用Sprite的Filed填充模式即可&#13;
&#13;
### 制作&#13;
1）制作Scrollbar&#13;
1.两个Sprite 1个背景 1个滚动条&#13;
2.背景父对象添加脚本&#13;
3.添加碰撞器&#13;
4.关联对象&#13;
&#13;
1）制作ProgressBar&#13;
1.两个Sprite 1个背景 1个进度条&#13;
2.背景父对象添加脚本&#13;
3.关联对象&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.ScrollBar-he-ProgressBar-zu-jian.html</guid><pubDate>Thu, 08 Feb 2024 11:33:55 +0000</pubDate></item><item><title>UI.NGUI.Slider组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Slider-zu-jian.html</link><description>### Slider组件&#13;
&#13;
### 参数&#13;
![参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/ccd56038-cc70-4eac-a9c5-93d91e27ab80)&#13;
&#13;
&#13;
&gt; 注意Slider与之前学习组件不同多了一个委托函数slider.onDragFinished可以直接+=lamda表达式！！！！！！！！！！！！！！！！！！！！&#13;
&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson10 : MonoBehaviour&#13;
{&#13;
    public UISlider slider;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 Slider是啥&#13;
        //滑动条控件&#13;
        //主要用于设置音乐音效大小等&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Slider&#13;
        //1.3个sprite 1个做根对象为背景  2个子对象 1个进度 1个滑动块 &#13;
        //2.设置层级&#13;
        //3.为根背景添加Slider脚本&#13;
        //4.添加碰撞器（父对象或者滑块）&#13;
        //5.关联3个对象&#13;
        #endregion&#13;
&#13;
        #region 知识点 监听事件的两种方式&#13;
        //1.拖曳脚本关联&#13;
        //2.通过代码关联&#13;
        slider.onChange.Add(new EventDelegate(() =&gt; {&#13;
&#13;
            print("通过代码监听" + slider.value);&#13;
        }));&#13;
&#13;
        slider.onDragFinished += () =&gt; {&#13;
            print("拖曳结束" + slider.value);&#13;
        };&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void OnChange()&#13;
    {&#13;
        print("值变化" + slider.value);&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Slider-zu-jian.html</guid><pubDate>Wed, 07 Feb 2024 14:45:22 +0000</pubDate></item><item><title>UI.NGUI.PopupList组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.PopupList-zu-jian-%20.html</link><description>### PopupList组件 &#13;
&#13;
### 参数&#13;
![参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/5f1e4f50-e74b-40c0-ad2b-0a6a976590f2)&#13;
![参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/c377a1f7-da85-458c-b0db-39d57a150217)&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson9 : MonoBehaviour&#13;
{&#13;
    public UIPopupList list;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 PopupList是啥？&#13;
        //下拉列表 &#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Popuplist&#13;
        //1.一个sprite做背景 一个lable做显示内容&#13;
        //2.添加PopupList脚本&#13;
        //3.添加碰撞器&#13;
        //4.关联lable做信息更新，选择Label中的SetCurrentSelection函数&#13;
        #endregion&#13;
&#13;
        #region 知识点 添加新选项 + 监听事件的两种方式&#13;
        //1.拖曳代码&#13;
        //2.代码关联&#13;
        list.items.Add("新加 选项4");&#13;
&#13;
        list.onChange.Add(new EventDelegate(() =&gt; {&#13;
&#13;
            print("代码添加的监听" + list.value);&#13;
        }));&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void OnChange()&#13;
    {&#13;
        print("选项变化" + list.value);&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.PopupList-zu-jian-%20.html</guid><pubDate>Wed, 07 Feb 2024 12:52:19 +0000</pubDate></item><item><title>UI.NGUI.Input组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.Input-zu-jian-%20.html</link><description>### Input组件 &#13;
&#13;
### 参数&#13;
![input参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/531345f0-7ac1-4ebf-9c3f-6cde944796de)&#13;
![input参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/e52ef3c0-5b14-45a2-9a6f-c7f1eee0ea3a)&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson8 : MonoBehaviour&#13;
{&#13;
    public UIInput input;&#13;
&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 Input是啥&#13;
        //输入框&#13;
        //可以用来制作账号密码聊天输入框&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Input&#13;
        //1.1个Sprite做背景 1个Label显示文字&#13;
        //2.为Sprint添加Input脚本&#13;
        //3.添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点 监听事件的两种方式&#13;
        //1.拖曳脚本&#13;
        //2.通过代码关联&#13;
&#13;
        input.onSubmit.Add(new EventDelegate(() =&gt;&#13;
        {&#13;
            print("完成输入 通关代码添加的监听函数");&#13;
        }));&#13;
&#13;
        input.onChange.Add(new EventDelegate(() =&gt;&#13;
        {&#13;
            print("输入变化 通关代码添加的监听函数");&#13;
        }));&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void OnSubmit()&#13;
    {&#13;
        print("输入完成" + input.value);&#13;
    }&#13;
&#13;
    public void OnChange()&#13;
    {&#13;
        print("输入变化" + input.value);&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Input-zu-jian-%20.html</guid><pubDate>Wed, 07 Feb 2024 06:52:38 +0000</pubDate></item><item><title>Acwing 845.八数码（华容道最小步数）</title><link>https://natsunokoide.github.io//post/Acwing%20845.-ba-shu-ma-%EF%BC%88-hua-rong-dao-zui-xiao-bu-shu-%EF%BC%89.html</link><description>### 题目&#13;
在一个 3×3的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3的网格中。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20845.-ba-shu-ma-%EF%BC%88-hua-rong-dao-zui-xiao-bu-shu-%EF%BC%89.html</guid><pubDate>Wed, 07 Feb 2024 06:18:21 +0000</pubDate></item><item><title>UI.NGUI.Toggle单选多选组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Toggle-dan-xuan-duo-xuan-zu-jian.html</link><description>### Toggle单选多选组件&#13;
&#13;
### 参数&#13;
![toggle参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/5b2f6a06-f73d-4446-b978-3a9db45445a5)&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson7 : MonoBehaviour&#13;
{&#13;
    public UIToggle tog1;&#13;
    public UIToggle tog2;&#13;
    public UIToggle tog3;&#13;
&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 Toggle用来干啥&#13;
        //单选框 多选框都可以使用它来制作&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Toggle&#13;
        //1.2个Sprite 1父1子&#13;
        //2.为父对象添加Toggle脚本&#13;
        //3.添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点四 监听事件的两种方式&#13;
        //1.拖代码（button类似）&#13;
        //2.代码进行监听添加&#13;
        tog1.onChange.Add(new EventDelegate(Change2));&#13;
        tog2.onChange.Add(new EventDelegate(Change2));&#13;
        tog3.onChange.Add(new EventDelegate(Change2));&#13;
        #endregion&#13;
    }&#13;
&#13;
    private void Change2()&#13;
    {&#13;
        print("代码监听");&#13;
    }&#13;
&#13;
    //可以将toggle设置为同一级 这样就可以实现if~else if的单选判断&#13;
    public void Change()&#13;
    {&#13;
        print("Toggle变化执行的内容");&#13;
&#13;
        if (tog1.value)&#13;
        {&#13;
            print("tog1选中");&#13;
        }&#13;
        else if (tog2.value)&#13;
        {&#13;
            print("tog2选中");&#13;
        }&#13;
        else if (tog3.value)&#13;
        {&#13;
            print("tog3选中");&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Toggle-dan-xuan-duo-xuan-zu-jian.html</guid><pubDate>Tue, 06 Feb 2024 13:54:36 +0000</pubDate></item><item><title>UI.NGUI.Button按钮组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Button-an-niu-zu-jian.html</link><description>### Button按钮组件&#13;
&#13;
### 参数&#13;
![按钮参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/9882d3df-1237-497e-a8d2-ae6b9af0ae9c)&#13;
&#13;
### 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson6 : MonoBehaviour&#13;
{&#13;
    public UIButton btn;&#13;
&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 所有组合控件的共同特点&#13;
        //1.在3个基础组件对象上添加对应组件&#13;
        //2.如果希望响应点击等事件 需要添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点 Button是用来干嘛的&#13;
        //UI界面中的按钮 当点击按钮后我们可以进行一些处理&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Button&#13;
        //1.一个Sprite（需要文字再加一个Label子对象）&#13;
        //2.为Sprite添加Button脚本&#13;
        //3.添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点 监听事件的两种方式&#13;
        //1.拖脚本&#13;
        //直接在unity编辑器中进行 把脚本托给Ngui对象然后在编辑器里面选&#13;
        //2.代码获取按钮对象监听&#13;
        btn.onClick.Add(new EventDelegate(ClickDo2));&#13;
&#13;
        btn.onClick.Add(new EventDelegate(() =&gt; {&#13;
            print("那么大表达式添加的 点击事件处理");&#13;
        }));&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void ClickDoSomthing()&#13;
    {&#13;
        print("按钮点击");&#13;
    }&#13;
&#13;
    public void ClickDo2()&#13;
    {&#13;
        print("按钮点击2");&#13;
    }&#13;
&#13;
    #region 总结&#13;
    //1.button的制作流程&#13;
    //  3个基础组件构成 任意一个基础组件 往上面添加Button脚本 再添加碰撞器 就可以让它变成一个按钮&#13;
    //2.事件的监听&#13;
    // 通过 拖曳 或者 代码的形式 可以进行按钮的 点击事件 监听&#13;
    #endregion&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Button-an-niu-zu-jian.html</guid><pubDate>Tue, 06 Feb 2024 07:20:53 +0000</pubDate></item><item><title>Acwing 240.食物链</title><link>https://natsunokoide.github.io//post/Acwing%20240.-shi-wu-lian.html</link><description>### 题目&#13;
动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20240.-shi-wu-lian.html</guid><pubDate>Tue, 06 Feb 2024 06:48:52 +0000</pubDate></item><item><title>UI.NGUI.Texture控件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.Texture-kong-jian-%20.html</link><description>### Texture控件 &#13;
&#13;
### 基本参数&#13;
![texture控件](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/bcda5c29-4928-4824-85a1-af5cddbfb27a)&#13;
&#13;
### 代码&#13;
```js&#13;
    public UITexture tex;&#13;
    void Start()&#13;
    {&#13;
        #region Texture用来干啥&#13;
        //Sprite只能显示图集中图片 一般用于显示中小图片&#13;
        //如果使用大尺寸图片 没有必要打图集&#13;
        //直接使用Texture组件进行大图片显示&#13;
        #endregion&#13;
&#13;
        #region  代码设置&#13;
        //加载图片 &#13;
        Texture texture = Resources.Load&lt;Texture&gt;("BK");&#13;
        //改变图片&#13;
        if (texture != null)&#13;
            tex.mainTexture = texture;&#13;
        #endregion&#13;
    }&#13;
```&#13;
&#13;
### 细节&#13;
创建texture 将图片放入需要查看图片的原始分辨率并进行调整&#13;
若为背景大图 需要对UIRoot组件进行 修改 保证 大图的清晰与准确。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Texture-kong-jian-%20.html</guid><pubDate>Mon, 05 Feb 2024 14:24:03 +0000</pubDate></item><item><title>UI.NGUI.Lable控件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Lable-kong-jian.html</link><description>### Lable控件&#13;
&#13;
### 基础参数&#13;
![lable参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/01edb567-8c90-4fb7-a9d5-a415bcd72758)&#13;
![lable参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/3b92ad46-8f64-40c1-8f0a-69fa4fe82a19)&#13;
&#13;
### 富文本内容&#13;
![富文本](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/2abe1dbf-53a3-4fa9-83ae-577555be69b0)&#13;
&#13;
### 代码相关&#13;
1.创建： public UILable lable；&#13;
2.得到内容： lable.text = " xxxx "；。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Lable-kong-jian.html</guid><pubDate>Mon, 05 Feb 2024 14:08:22 +0000</pubDate></item><item><title>UI.NGUI.Sprite控件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Sprite-kong-jian.html</link><description>### Sprite控件&#13;
&#13;
### 作用&#13;
NGUI中所有中小尺寸图片显示都用Sprite显示，使用它来显示图集中的单个图片资源&#13;
&#13;
### 参数&#13;
![sprite参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/b745b945-4b7f-4daf-8980-d8f7e0f94b07)&#13;
![sprite参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/b0e6998e-9c62-4420-bee0-f2fc941de96e)&#13;
![sprite参数3](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/146cb5b7-786b-4c0e-812e-93347c226da0)&#13;
&#13;
### 代码相关内容&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson3 : MonoBehaviour&#13;
{&#13;
    //定义精灵图&#13;
    public UISprite sprite;&#13;
    void Start()&#13;
    {&#13;
        //设置长宽&#13;
        sprite.width = 200;&#13;
        sprite.height = 300;&#13;
&#13;
        //改变为当前图集中选择的图片&#13;
        sprite.spriteName = "bk";&#13;
&#13;
        //2.改变为其它图集中的图片&#13;
        //先加载图集&#13;
        //图集在 NGUIAtlas 类中 使用Resources直接加载&#13;
        NGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;("Atlas/login");&#13;
        sprite.atlas = atlas;&#13;
        //再设置图片&#13;
        sprite.spriteName = "ui_DL_anniuxiao_01";&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Sprite-kong-jian.html</guid><pubDate>Mon, 05 Feb 2024 13:46:16 +0000</pubDate></item><item><title>UI.NGUI.图集</title><link>https://natsunokoide.github.io//post/UI.NGUI.-tu-ji.html</link><description>### 图集&#13;
&#13;
### 定义&#13;
 NGUI中的最小图片控件Sprite要使用图集中的图片进行显示&#13;
图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集&#13;
目的：提高渲染性能&#13;
&#13;
### 打开图集编辑器&#13;
方法一：Project右键打开&#13;
方法二：上方工具栏NGUI——Open——Atlas Maker&#13;
&#13;
### 图集文件内容&#13;
1.图集文件&#13;
2.图集材质&#13;
3.图集图片&#13;
&#13;
### 图集工具参数&#13;
![图集工具参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/19129d99-3fb8-4c01-a0b2-be1e0dbe01b1)&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.-tu-ji.html</guid><pubDate>Sun, 04 Feb 2024 13:35:47 +0000</pubDate></item><item><title>UI.NGUI.EventSystem组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.EventSystem-zu-jian-%20.html</link><description>### EventSystem控件 &#13;
![EventSystem参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/859b8eca-d747-473d-bc55-807fc3ac5608)&#13;
![EventSystem参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/ff0e2ea5-d8b9-4455-95b6-60f4357296f7)&#13;
&#13;
### 总结&#13;
1.如果没有EventSystem，没有办法监听玩家输入&#13;
2.创建UI时的 2DUI 和3DUI 主要就是摄像机的模式不一样&#13;
EventSystem的2D和3D主要是 采用2D碰撞器 还是3D碰撞器 不能直接改变摄像机模式。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.EventSystem-zu-jian-%20.html</guid><pubDate>Sun, 04 Feb 2024 09:19:21 +0000</pubDate></item><item><title>UI.NGUI.Panel控件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Panel-kong-jian.html</link><description>### Panel控件参数&#13;
![panel重要参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/a6c67231-ec59-4f4f-82f9-73cbd2682191)&#13;
![panel次要参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/e53f032f-4957-4995-b905-0f631d3516fb)&#13;
&#13;
### 总结&#13;
1.没有Panel父对象 UI控件看不到&#13;
2.Panel一般用于管理面板 控制层级&#13;
3.Panel可以有多个 一般一个Panel管理一个面板&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Panel-kong-jian.html</guid><pubDate>Sun, 04 Feb 2024 08:19:59 +0000</pubDate></item><item><title>UI.NGUI.Root控件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Root-kong-jian.html</link><description>![root控件参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/2b6b910f-977c-48d2-8170-43b7b68e8f16)&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Root-kong-jian.html</guid><pubDate>Sun, 04 Feb 2024 07:42:17 +0000</pubDate></item><item><title>Acwing 143.最大异或对</title><link>https://natsunokoide.github.io//post/Acwing%20143.-zui-da-yi-huo-dui.html</link><description>### 题目&#13;
在给定的 N个整数 A1，A2……AN中选出两个进行 xor（异或）运算，得到的结果最大是多少？&#13;
&#13;
### 输入格式&#13;
第一行输入一个整数 N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20143.-zui-da-yi-huo-dui.html</guid><pubDate>Sun, 04 Feb 2024 06:36:30 +0000</pubDate></item><item><title>Acwing 831. KMP字符串</title><link>https://natsunokoide.github.io//post/Acwing%20831.%20KMP-zi-fu-chuan.html</link><description>###  题目&#13;
### KMP字符串 经典问题&#13;
给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20831.%20KMP-zi-fu-chuan.html</guid><pubDate>Sat, 03 Feb 2024 13:06:11 +0000</pubDate></item><item><title>数据持久化.XmlDataMgr</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XmlDataMgr.html</link><description>### xml管理脚本&#13;
&#13;
&gt; 使用这个管理脚本若要序列化字典数据类型需要自己写一个继承IXmlSerializer接口的Dictionnary&#13;
&#13;
```js&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.IO;&#13;
using System.Xml.Serialization;&#13;
using UnityEngine;&#13;
&#13;
public class XmlDataMgr &#13;
{&#13;
    private static XmlDataMgr instance = new XmlDataMgr();&#13;
    public static XmlDataMgr Instance =&gt; instance;&#13;
    private XmlDataMgr() { }&#13;
&#13;
    public void SaveData(object data,string fileName)&#13;
    {&#13;
        //得到路径&#13;
        string path = Application.persistentDataPath + "/" + fileName + ".xml";&#13;
        //存储文件&#13;
        using (StreamWriter writer = new StreamWriter(path))&#13;
        {&#13;
            //序列化&#13;
            XmlSerializer s = new XmlSerializer(data.GetType());&#13;
            s.Serialize(writer, data);&#13;
        }&#13;
    }&#13;
&#13;
    public object LoadData(Type type,string fileName)&#13;
    {&#13;
        //判断文件是否存在&#13;
        string path = Application.persistentDataPath + "/" + fileName + ".xml";&#13;
        //存在就读取&#13;
        if(!File.Exists(path))&#13;
        {&#13;
            path = Application.streamingAssetsPath + "/" + fileName + ".xml";&#13;
            if(!File.Exists(path))&#13;
            {&#13;
                //如果两个路径都没有文件 那么new一个type类型对象返回给外部 都是默认值&#13;
                return Activator.CreateInstance(type);&#13;
            }&#13;
        }&#13;
        using (StreamReader reader = new StreamReader(path))&#13;
        {&#13;
            //反序列化&#13;
            XmlSerializer s = new XmlSerializer(type);&#13;
            return s.Deserialize(reader);&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XmlDataMgr.html</guid><pubDate>Fri, 02 Feb 2024 06:55:39 +0000</pubDate></item><item><title>Acwing 3302.表达式求值</title><link>https://natsunokoide.github.io//post/Acwing%203302.-biao-da-shi-qiu-zhi.html</link><description>### 题目&#13;
给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%203302.-biao-da-shi-qiu-zhi.html</guid><pubDate>Fri, 02 Feb 2024 06:04:28 +0000</pubDate></item><item><title>Acwing 125.耍杂技的牛</title><link>https://natsunokoide.github.io//post/Acwing%20125.-shua-za-ji-de-niu.html</link><description>### 题目&#13;
农民约翰的 N 头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20125.-shua-za-ji-de-niu.html</guid><pubDate>Thu, 01 Feb 2024 13:37:55 +0000</pubDate></item><item><title>数据持久化.XML的序列化反序列化</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-de-xu-lie-hua-fan-xu-lie-hua.html</link><description>### 1.序列化&#13;
定义： 把对象转化为可传输的字节序列过程称为序列化。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-de-xu-lie-hua-fan-xu-lie-hua.html</guid><pubDate>Tue, 30 Jan 2024 07:53:30 +0000</pubDate></item><item><title>Acwing 104.货仓选址</title><link>https://natsunokoide.github.io//post/Acwing%20104.-huo-cang-xuan-zhi.html</link><description>### 题目&#13;
在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20104.-huo-cang-xuan-zhi.html</guid><pubDate>Tue, 30 Jan 2024 06:54:17 +0000</pubDate></item><item><title>Acwing 913.排队打水</title><link>https://natsunokoide.github.io//post/Acwing%20913.-pai-dui-da-shui.html</link><description>### 题目&#13;
有 n个人排队到 1个水龙头处打水，第 i个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？&#13;
&#13;
### 输入格式&#13;
第一行包含整数 n。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20913.-pai-dui-da-shui.html</guid><pubDate>Tue, 30 Jan 2024 06:28:21 +0000</pubDate></item><item><title>Acwing 148.合并果子</title><link>https://natsunokoide.github.io//post/Acwing%20148.-he-bing-guo-zi.html</link><description>### 题目&#13;
在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20148.-he-bing-guo-zi.html</guid><pubDate>Mon, 29 Jan 2024 13:37:22 +0000</pubDate></item><item><title>Acwing 907.区间覆盖</title><link>https://natsunokoide.github.io//post/Acwing%20907.-qu-jian-fu-gai.html</link><description>### 题目&#13;
给定 N个闭区间 [ai,bi]以及一个线段区间 [s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20907.-qu-jian-fu-gai.html</guid><pubDate>Sun, 28 Jan 2024 13:40:43 +0000</pubDate></item><item><title>数据持久化.XML文件存储</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-cun-chu.html</link><description>### XML文件存储&#13;
&#13;
### 存储位置分析&#13;
&#13;
1. 存储xml文件 在Unity中一定是使用各平台都可读可写可找到的路径&#13;
2. Resources 可读 不可写 打包后找不到  （×）&#13;
3. Application.streamingAssetsPath 可读 PC端可写 iosmac不可写 找得到  （×）&#13;
4. Application.dataPath 打包后找不到（×）&#13;
5. Application.persistentDataPath 可读可写找得到 （√）&#13;
&#13;
### 存储xml文件&#13;
**XmlDocument 需要引入头文件using System.Xml;**&#13;
&gt; 代码&#13;
```js&#13;
//关键类 XmlDocument 用于创建节点 存储文件&#13;
//关键类 XmlDeclaration 用于添加版本信息&#13;
//关键类 XmlElement 节点类&#13;
&#13;
        //存储有5步&#13;
        //1.创建文本对象&#13;
        XmlDocument xml = new XmlDocument();&#13;
&#13;
        //2.添加固定版本信息&#13;
        //这一句代码 相当于就是创建&lt;?xml version="1.0" encoding="UTF-8"?&gt;这句内容&#13;
        XmlDeclaration xmlDec = xml.CreateXmlDeclaration("1.0", "UTF-8", "");&#13;
        //创建完成过后 要添加进入 文本对象中&#13;
        xml.AppendChild(xmlDec);&#13;
&#13;
        //3.添加根节点&#13;
        XmlElement root = xml.CreateElement("Root");&#13;
        xml.AppendChild(root);&#13;
&#13;
        //4.为根节点添加子节点&#13;
        //加了一个 name子节点&#13;
        XmlElement name = xml.CreateElement("name");&#13;
        name.InnerText = "唐老狮";&#13;
        root.AppendChild(name);&#13;
&#13;
        XmlElement atk = xml.CreateElement("atk");&#13;
        atk.InnerText = "10";&#13;
        root.AppendChild(atk);&#13;
&#13;
        XmlElement listInt = xml.CreateElement("listInt");&#13;
        for (int i = 1; i &lt;= 3; i++)&#13;
        {&#13;
            XmlElement childNode = xml.CreateElement("int");&#13;
            childNode.InnerText = i.ToString();&#13;
            listInt.AppendChild(childNode);&#13;
        }&#13;
        root.AppendChild(listInt);&#13;
&#13;
        XmlElement itemList = xml.CreateElement("itemList");&#13;
        for (int i = 1; i &lt;= 3; i++)&#13;
        {&#13;
            XmlElement childNode = xml.CreateElement("Item");&#13;
            //添加属性&#13;
            childNode.SetAttribute("id", i.ToString());&#13;
            childNode.SetAttribute("num", (i * 10).ToString());&#13;
            itemList.AppendChild(childNode);&#13;
        }&#13;
        root.AppendChild(itemList);&#13;
&#13;
        //5.保存&#13;
        xml.Save(path);&#13;
```&#13;
&#13;
&gt; 上述代码得到的xml文件&#13;
&#13;
```js&#13;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
&lt;Root&gt;&#13;
  &lt;name&gt;ADd7&lt;/name&gt;&#13;
  &lt;atk&gt;10&lt;/atk&gt;&gt;&#13;
  &lt;listInt&gt;&#13;
    &lt;int&gt;1&lt;/int&gt;&#13;
    &lt;int&gt;2&lt;/int&gt;&#13;
    &lt;int&gt;3&lt;/int&gt;&#13;
  &lt;/listInt&gt;&#13;
  &lt;itemList&gt;&#13;
    &lt;Item id="1" num="10" /&gt;&#13;
    &lt;Item id="2" num="20" /&gt;&#13;
    &lt;Item id="3" num="30" /&gt;&#13;
  &lt;/itemList&gt;&#13;
&lt;/Root&gt;&#13;
```&#13;
&#13;
### 文件的修改（添加/移除）&#13;
**判断文件是否存在 这个功能是在using System.IO中的**&#13;
&gt; 代码&#13;
```js&#13;
        //1.先判断是否存在文件&#13;
        if (File.Exists(path))&#13;
        {&#13;
            //2.加载后 直接添加节点 移除节点即可&#13;
            XmlDocument newXml = new XmlDocument();&#13;
            newXml.Load(path);&#13;
&#13;
            //修改就是在原有文件基础上 去移除 或者添加&#13;
            //移除&#13;
            //XmlNode node = newXml.SelectSingleNode("Root").SelectSingleNode("atk");&#13;
            //这种是一种简便写法 通过/来区分父子关系&#13;
            node = newXml.SelectSingleNode("Root/atk");&#13;
            //得到自己的父节点&#13;
            XmlNode root2 = newXml.SelectSingleNode("Root");&#13;
            //移除子节点方法&#13;
            root2.RemoveChild(node);&#13;
&#13;
            //添加节点&#13;
            XmlElement speed = newXml.CreateElement("moveSpeed");&#13;
            speed.InnerText = "20";&#13;
            root2.AppendChild(speed);&#13;
&#13;
            //改了记得存&#13;
            newXml.Save(path);&#13;
        }&#13;
```&#13;
&#13;
&gt; 上述代码得到的修改后xml文件&#13;
```js&#13;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
&lt;Root&gt;&#13;
  &lt;name&gt;ADd7&lt;/name&gt;&#13;
  &lt;listInt&gt;&#13;
    &lt;int&gt;1&lt;/int&gt;&#13;
    &lt;int&gt;2&lt;/int&gt;&#13;
    &lt;int&gt;3&lt;/int&gt;&#13;
  &lt;/listInt&gt;&#13;
  &lt;itemList&gt;&#13;
    &lt;Item id="1" num="10" /&gt;&#13;
    &lt;Item id="2" num="20" /&gt;&#13;
    &lt;Item id="3" num="30" /&gt;&#13;
  &lt;/itemList&gt;&#13;
  &lt;speed&gt;2&lt;/speed&gt;&#13;
&lt;/Root&gt;&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-cun-chu.html</guid><pubDate>Sat, 27 Jan 2024 06:31:53 +0000</pubDate></item><item><title>Acwing 906.区间分组</title><link>https://natsunokoide.github.io//post/Acwing%20906.-qu-jian-fen-zu.html</link><description>### 题目 &#13;
给定 N个闭区间 [ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20906.-qu-jian-fen-zu.html</guid><pubDate>Fri, 26 Jan 2024 16:30:41 +0000</pubDate></item><item><title>数据持久化.XML文件读取</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-du-qu.html</link><description>### XML文件读取&#13;
**总结**&#13;
**1.读取XML文件**&#13;
XmlDocument xml = new XmlDocument();&#13;
读取文本方式1-xml.LoadXml(传入xml文本字符串)&#13;
读取文本方式2-xml.Load(传入路径)&#13;
&#13;
**2.读取元素和属性**&#13;
获取单个节点 : XmlNode node = xml.SelectSingleNode(节点名)&#13;
获取多个节点 : XmlNodeList nodeList = xml.SelectNodes(节点名)&#13;
&#13;
获取节点元素内容：node.InnerText&#13;
获取节点元素属性：&#13;
1.item.Attributes["属性名"].Value&#13;
2.item.Attributes.GetNamedItem("属性名").Value&#13;
&#13;
通过迭代器遍历或者循环遍历XmlNodeList对象 可以获取到各单个元素节点&#13;
&#13;
&gt; 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Xml;&#13;
using UnityEngine;&#13;
&#13;
public class LoadXml : MonoBehaviour&#13;
{&#13;
    void Start()&#13;
    {&#13;
        //1.使用Resources提取出的资源，得到xml的text并进行加载&#13;
        XmlDocument xml = new XmlDocument();&#13;
        TextAsset asset = Resources.Load&lt;TextAsset&gt;("TestXml");&#13;
        //print(asset.text);&#13;
        //loadxml 直接翻译字符串为xml&#13;
        xml.LoadXml(asset.text);&#13;
        //2.直接通过xml的路径加载&#13;
        //xml.Load(Application.streamingAssetsPath + "/TestXml.xml");&#13;
&#13;
&#13;
        //节点信息类&#13;
        //XmlNode 单个节点信息&#13;
        //XmlNodeList 多个节点信息类&#13;
        XmlNode root = xml.SelectSingleNode("Root");&#13;
        //通过根节点找子节点&#13;
        XmlNode nodeName = root.SelectSingleNode("name");&#13;
        //得到个子节点通过 InnerText读取里面的内容&#13;
        print(nodeName.InnerText);&#13;
        XmlNode nodeAge = root.SelectSingleNode("age");&#13;
        print(nodeAge.InnerText);&#13;
&#13;
        XmlNode nodeItem = root.SelectSingleNode("Item");&#13;
        //得到带属性的节点内容&#13;
        //第一种&#13;
        print(nodeItem.Attributes["id"].Value);&#13;
        print(nodeItem.Attributes["num"].Value);&#13;
        //第二种（了解）&#13;
        print(nodeItem.Attributes.GetNamedItem("id").Value);&#13;
&#13;
        //获取一个节点下 所有同名节点的方式&#13;
        XmlNodeList friendList = root.SelectNodes("Friend");&#13;
        //遍历方式1：迭代器遍历&#13;
        foreach (XmlNode item in friendList)&#13;
        {&#13;
            print(item.SelectSingleNode("id").Value);&#13;
            print(item.SelectSingleNode("name").Value);&#13;
        }&#13;
&#13;
        //遍历方式2：for循环&#13;
        for (int i = 0; i &lt; friendList.Count; i++)&#13;
        {&#13;
            print(friendList[i].SelectSingleNode("id").Value);&#13;
            print(friendList[i].SelectSingleNode("name").Value);&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```&#13;
### 在playerInfo类中写一个加载xml数据的LoadData（）函数&#13;
### 用于解析一个xml文件并将内容赋予到一个新的playerInfo上去&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Xml;&#13;
using UnityEngine;&#13;
&#13;
public class Item&#13;
{&#13;
    public int id;&#13;
    public int num;&#13;
}&#13;
&#13;
public class playerInfo&#13;
{&#13;
    public string name;&#13;
    public int atk;&#13;
    public int def;&#13;
    public float moveSpeed;&#13;
    public float roundSpeed;&#13;
    public Item weapon;&#13;
    public List&lt;int&gt; listInt;&#13;
    public List&lt;Item&gt; itemList;&#13;
    public Dictionary&lt;int, Item&gt; itemDic;&#13;
&#13;
    public void LoadData(string fileName)&#13;
    {&#13;
        //加载XML文件信息&#13;
        XmlDocument xml = new XmlDocument();&#13;
        //加载&#13;
        xml.Load(Application.streamingAssetsPath + "/" + fileName + ".xml");&#13;
&#13;
        //从文件中加载出具体的数据&#13;
        //加载根节点 才能加载后面的内容&#13;
        XmlNode playerInfo = xml.SelectSingleNode("PlayerInfo");&#13;
        //通过根节点 去加载具体的信息&#13;
        //不是属性的化用 InnerText 属性的化用Attributes&#13;
        this.name = playerInfo.SelectSingleNode("name").InnerText;&#13;
        this.atk = int.Parse(playerInfo.SelectSingleNode("atk").InnerText);&#13;
        this.def = int.Parse(playerInfo.SelectSingleNode("def").InnerText);&#13;
        this.moveSpeed = float.Parse(playerInfo.SelectSingleNode("moveSpeed").InnerText);&#13;
        this.roundSpeed = float.Parse(playerInfo.SelectSingleNode("roundSpeed").InnerText);&#13;
&#13;
        XmlNode weaponNode = playerInfo.SelectSingleNode("weapon");&#13;
        //实例化不能忘记&#13;
        this.weapon = new Item();&#13;
        this.weapon.id = int.Parse(weaponNode.SelectSingleNode("id").InnerText);&#13;
        this.weapon.num = int.Parse(weaponNode.SelectSingleNode("num").InnerText);&#13;
&#13;
        XmlNode listIntNode = playerInfo.SelectSingleNode("listInt");&#13;
        XmlNodeList intList = listIntNode.SelectNodes("int");&#13;
        this.listInt = new List&lt;int&gt;();&#13;
        for (int i = 0; i &lt; intList.Count; i++)&#13;
        {&#13;
            this.listInt.Add(int.Parse(intList[i].InnerText));&#13;
        }&#13;
&#13;
        XmlNode itemList = playerInfo.SelectSingleNode("itemList");&#13;
        XmlNodeList items = itemList.SelectNodes("Item");&#13;
        this.itemList = new List&lt;Item&gt;();&#13;
        //对单一类别的节点 用 foreach和for都可以&#13;
        foreach (XmlNode item in items)&#13;
        {&#13;
            Item item2 = new Item();&#13;
            item2.id = int.Parse(item.Attributes["id"].Value);&#13;
            item2.num = int.Parse(item.Attributes["num"].Value);&#13;
            this.itemList.Add(item2);&#13;
        }&#13;
&#13;
        XmlNode itemDic = playerInfo.SelectSingleNode("itemDic");&#13;
        XmlNodeList keyInt = itemDic.SelectNodes("int");&#13;
        XmlNodeList valueItem = itemDic.SelectNodes("Item");&#13;
&#13;
        this.itemDic = new Dictionary&lt;int, Item&gt;();&#13;
        for (int i = 0; i &lt; keyInt.Count; i++)&#13;
        {&#13;
            int key = int.Parse(keyInt[i].InnerText);&#13;
            Item item1 = new Item();&#13;
            item1.id = int.Parse(valueItem[i].Attributes["id"].Value);&#13;
            item1.num = int.Parse(valueItem[i].Attributes["num"].Value);&#13;
            this.itemDic.Add(key, item1);&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
### 测试&#13;
```js&#13;
    void Start()&#13;
    {&#13;
        playerInfo p = new playerInfo();&#13;
        p.LoadData("PlayerInfo");&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-du-qu.html</guid><pubDate>Thu, 25 Jan 2024 07:24:48 +0000</pubDate></item><item><title>Acwing.905 区间选点+AcWing 908. 最大不相交区间数量</title><link>https://natsunokoide.github.io//post/Acwing.905%20-qu-jian-xuan-dian-%2BAcWing%20908.%20-zui-da-bu-xiang-jiao-qu-jian-shu-liang.html</link><description>### 908与905的代码完全一样 思路相似不做额外篇幅&#13;
### 题目&#13;
给定 N个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing.905%20-qu-jian-xuan-dian-%2BAcWing%20908.%20-zui-da-bu-xiang-jiao-qu-jian-shu-liang.html</guid><pubDate>Thu, 25 Jan 2024 03:33:34 +0000</pubDate></item><item><title>Unity.射线检测（fps游戏相关）</title><link>https://natsunokoide.github.io//post/Unity.-she-xian-jian-ce-%EF%BC%88fps-you-xi-xiang-guan-%EF%BC%89.html</link><description>### 射线检测&#13;
&#13;
&gt; 重点内容是 ： 物体信息类 RaycastHit 以及RaycastHit[]数组&#13;
&#13;
&gt; 数组有特殊的api :RaycastAll 用法与 Raycast类似&#13;
&#13;
&gt; 特殊api：RaycastNonAlloc 返回的是碰撞器的数量&#13;
&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson23 : MonoBehaviour&#13;
{&#13;
    void Start()&#13;
    {&#13;
        #region 知识点一 什么是射线检测&#13;
        //物理系统中 &#13;
        //目前我们学习的物体相交判断&#13;
        //1.碰撞检测——必备条件 1刚体2碰撞器&#13;
        //2.范围检测——必备条件 碰撞器&#13;
&#13;
        //如果想要做这样的碰撞检测呢？&#13;
        //1.鼠标选择场景上一物体&#13;
        //2.FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）&#13;
        //等等 需要判断一条线和物体的碰撞情况&#13;
&#13;
        //射线检测 就是来解决这些问题的&#13;
        //它可以在指定点发射一个指定方向的射线&#13;
        //判断该射线与哪些碰撞器相交，得到对应对象&#13;
        #endregion&#13;
&#13;
        #region 知识点二 射线对象&#13;
        //1.3D世界中的射线&#13;
        //假设有一条&#13;
        //起点为坐标(1,0,0)&#13;
        //方向为世界坐标Z轴正方向的射线&#13;
        //注意：&#13;
        //理解参数含义&#13;
        //参数一：起点&#13;
        //参数二：方向（一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量）&#13;
&#13;
        //目前只是申明了一个射线对象 对于我们来说 没有任何的用处&#13;
        Ray r = new Ray(Vector3.right, Vector3.forward);&#13;
&#13;
        //Ray中的参数&#13;
        print(r.origin);//起点,参数1&#13;
        print(r.direction);//方向，参数2&#13;
&#13;
        //2.摄像机发射出的射线&#13;
        // 得到一条从屏幕位置作为起点&#13;
        // 摄像机视口方向为 方向的射线&#13;
        //很重要的API&#13;
        Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);&#13;
&#13;
&#13;
        //注意：&#13;
        //单独的射线对于我们来说没有实际的意义&#13;
        //我们需要用它结合物理系统进行射线碰撞判断&#13;
        #endregion&#13;
&#13;
        #region 知识点三 碰撞检测函数&#13;
        //Physics类中提供了很多进行射线检测的静态函数&#13;
        //注意：&#13;
        //射线检测是瞬时的&#13;
        //执行代码时进行一次射线检测&#13;
&#13;
        //1.最原始的射线检测&#13;
        // 准备一条射线&#13;
        Ray r3 = new Ray(Vector3.zero, Vector3.forward);&#13;
        // 进行射线检测 如果碰撞到对象 返回true&#13;
        //参数一：射线&#13;
        //参数二: 检测的最大距离 超出这个距离不检测&#13;
        //参数三：检测指定层级（不填检测所有层）&#13;
        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：bool 当碰撞到对象时 返回 true 没有 返回false&#13;
&#13;
        if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
            print("碰撞到了对象");&#13;
        }&#13;
&#13;
        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断&#13;
        //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向&#13;
        if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
            print("碰撞到了对象2");&#13;
        }&#13;
&#13;
        //2.获取相交的单个物体信息&#13;
        //物体信息类 RaycastHit&#13;
        RaycastHit hitInfo;&#13;
        //参数一：射线&#13;
        //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中&#13;
        //参数三：距离&#13;
        //参数四：检测指定层级（不填检测所有层）&#13;
        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        if (Physics.Raycast(r3, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
            print("碰撞到了物体 得到了信息");&#13;
&#13;
            //碰撞器信息&#13;
            print("碰撞到物体的名字" + hitInfo.collider.gameObject.name);&#13;
            //碰撞到的点&#13;
            print(hitInfo.point);&#13;
            //法线信息&#13;
            print(hitInfo.normal);&#13;
&#13;
            //得到碰撞到对象的位置&#13;
            print(hitInfo.transform.position);&#13;
&#13;
            //得到碰撞到对象 离自己的距离&#13;
            print(hitInfo.distance);&#13;
&#13;
            //RaycastHit 该类 对于我们的意义&#13;
            //它不仅可以得到我们碰撞到的对象信息&#13;
            //还可以得到一些 碰撞的点 距离 法线等等的信息&#13;
        }&#13;
&#13;
        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断&#13;
        if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
&#13;
        }&#13;
&#13;
        //3.获取相交的多个物体&#13;
        //可以得到碰撞到的多个对象&#13;
        //如果没有 就是容量为0的数组&#13;
        //参数一：射线&#13;
        //参数二：距离&#13;
        //参数三：检测指定层级（不填检测所有层）&#13;
        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal);&#13;
        for (int i = 0; i &lt; hits.Length; i++)&#13;
        {&#13;
            print("碰到的所有物体 名字分别是" + hits[i].collider.gameObject.name);&#13;
        }&#13;
&#13;
        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断&#13;
        //之前的参数一射线 通过两个点传入&#13;
        hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal);&#13;
&#13;
        //还有一种函数 返回的碰撞的数量 通过out得到数据&#13;
        if (Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal) &gt; 0)&#13;
        {&#13;
&#13;
        }&#13;
        #endregion&#13;
        #region 知识点四 使用时注意的问题&#13;
        //注意：&#13;
        //距离、层级两个参数 都是int类型&#13;
        //当我们传入参数时 一定要明确传入的参数代表的是距离还是层级&#13;
&#13;
        //以下 这样写是错误的 因为第二个参数 代表的是距离 不应该是层级 但这个在ide里面是不会报错的&#13;
        if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster")))&#13;
        {&#13;
        }&#13;
        #endregion&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 实现鼠标点击场景上的一面墙 点击位置创建子弹特效和弹孔&#13;
_子弹特效和弹孔 已经放入到Resources文件夹_&#13;
```js&#13;
//实现鼠标点击场景上的一面墙 点击位置创建子弹特效和弹孔&#13;
        if (Input.GetMouseButtonDown(0))&#13;
        {&#13;
            if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),&#13;
                               out info,&#13;
                               1000,&#13;
                               1 &lt;&lt; LayerMask.NameToLayer("Monster")))&#13;
            {&#13;
                //碰撞到的点和法线向量&#13;
                //创建打击特效（特效是一个gameobject）&#13;
                GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;("Effect/HitEff"));&#13;
                obj.transform.position = info.point + info.normal * 0.3f;&#13;
                //让特效朝向屏幕&#13;
                //让物体看向法向量  这个法向量是垂直于面的向量 &#13;
                obj.transform.rotation = Quaternion.LookRotation(info.normal);&#13;
                Destroy(obj, 0.8f);&#13;
                //创建弹孔&#13;
                GameObject obj1 = Instantiate(Resources.Load&lt;GameObject&gt;("Effect/DDD"));&#13;
                obj1.transform.position = info.point + info.normal * 0.3f;&#13;
                //让特效朝向屏幕 //让物体看向法向量  这个法向量是垂直于面的向量 &#13;
                obj1.transform.rotation = Quaternion.LookRotation(info.normal);&#13;
            }&#13;
        }&#13;
```&#13;
&#13;
### 点击立方体 常按可以拖动在平面上移动点击右键取消选中&#13;
```js&#13;
if (Input.GetMouseButtonDown(0))&#13;
        {&#13;
            if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),out info,1000,1 &lt;&lt; LayerMask.NameToLayer("Player")))&#13;
            {&#13;
                nowSelObj = info.transform;&#13;
            }&#13;
        }&#13;
        //注意此处 GetMouseButton(0) 和上方鼠标选定 GetMouseButtonDown(0)的区别 前者是常按 后者是 按一下&#13;
        if (Input.GetMouseButton(0) &amp;&amp; nowSelObj != null)&#13;
        {&#13;
            if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),out info,1000, 1 &lt;&lt; LayerMask.NameToLayer("Floor")))&#13;
            {&#13;
                nowSelObj.position = info.point + Vector3.up * offSetY;&#13;
            }&#13;
        }&#13;
&#13;
        &#13;
        if(Input.GetMouseButtonDown(1))&#13;
        {&#13;
            nowSelObj = null;  &#13;
        }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-she-xian-jian-ce-%EF%BC%88fps-you-xi-xiang-guan-%EF%BC%89.html</guid><pubDate>Wed, 24 Jan 2024 14:38:57 +0000</pubDate></item><item><title>Acwing 901.滑雪</title><link>https://natsunokoide.github.io//post/Acwing%20901.-hua-xue.html</link><description>### 题目&#13;
给定一个 R行 C列的矩阵，表示一个矩形网格滑雪场。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20901.-hua-xue.html</guid><pubDate>Wed, 24 Jan 2024 12:50:58 +0000</pubDate></item><item><title>Acwing 285.没有上司的舞会</title><link>https://natsunokoide.github.io//post/Acwing%20285.-mei-you-shang-si-de-wu-hui.html</link><description>### 题目&#13;
Ural 大学有 N名职员，编号为 1∼N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20285.-mei-you-shang-si-de-wu-hui.html</guid><pubDate>Wed, 24 Jan 2024 11:34:56 +0000</pubDate></item><item><title>Unity.物理系统_范围检测</title><link>https://natsunokoide.github.io//post/Unity.-wu-li-xi-tong-_-fan-wei-jian-ce.html</link><description>### 物理系统_范围检测&#13;
&#13;
&gt; 代码总结&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
//重要知识点：&#13;
//关于层级&#13;
//通过名字得到层级编号 LayerMask.NameToLayer&#13;
//我们需要通过编号左移构建二进制数&#13;
//这样每一个编号的层级 都是 对应位为1的2进制数&#13;
//我们通过 位运算 可以选择想要检测层级&#13;
//好处 一个int 就可以表示所有想要检测的层级信息&#13;
&#13;
//层级编号是 0~31 刚好32位&#13;
//是一个int数&#13;
//每一个编号 代表的 都是二进制的一位&#13;
//0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1&#13;
//1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2&#13;
//2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4&#13;
//3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8&#13;
//4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16&#13;
//5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32&#13;
&#13;
public class Lesson22 : MonoBehaviour&#13;
{&#13;
    void Start()&#13;
    {&#13;
        #region 知识点一 什么是范围检测&#13;
        //游戏中瞬时的攻击范围判断一般会使用范围检测&#13;
        //简而言之在指定位置 进行 范围判断 我们可以得到处于指定范围内的 对象 目的是对 对象进行处理比如 受伤 减血等等&#13;
        #endregion&#13;
&#13;
        #region 知识点二 如何进行范围检测&#13;
        //必备条件：想要被范围检测到的对象 必须具备碰撞器&#13;
        //注意点：&#13;
        //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的&#13;
        //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已&#13;
&#13;
        //范围检测API&#13;
        //1.盒状范围检测&#13;
        //参数一：立方体中心点&#13;
        //参数二：立方体三边大小&#13;
        //参数三：立方体角度&#13;
        //参数四：检测指定层级（不填检测所有层）&#13;
        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）&#13;
        print(LayerMask.NameToLayer("UI"));&#13;
        Collider[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up),&#13;
                            1 &lt;&lt; LayerMask.NameToLayer("UI") |&#13;
                            1 &lt;&lt; LayerMask.NameToLayer("Default"), QueryTriggerInteraction.UseGlobal);&#13;
        for (int i = 0; i &lt; colliders.Length; i++)&#13;
        {&#13;
            print(colliders[i].gameObject.name);&#13;
        }&#13;
        //另一个API &#13;
        //返回值：碰撞到的碰撞器数量&#13;
        //参数：传入一个数组进行存储&#13;
        //Physics.OverlapBoxNonAlloc()&#13;
        if (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) { };&#13;
&#13;
        //2.球形范围检测&#13;
        //参数一：中心点&#13;
        //参数二：球半径&#13;
        //参数三：检测指定层级（不填检测所有层）&#13;
        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）&#13;
        colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer("Default"));&#13;
&#13;
        //另一个API &#13;
        //返回值：碰撞到的碰撞器数量&#13;
        //参数：传入一个数组进行存储&#13;
        //Physics.OverlapSphereNonAlloc&#13;
        if (Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0) { };&#13;
&#13;
        //3.胶囊范围检测&#13;
        //参数一：半圆一中心点&#13;
        //参数二：半圆二中心点&#13;
        //参数三：半圆半径&#13;
        //参数四：检测指定层级（不填检测所有层）&#13;
        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）&#13;
        colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer("UI"), QueryTriggerInteraction.UseGlobal);&#13;
&#13;
        //另一个API &#13;
        //返回值：碰撞到的碰撞器数量&#13;
        //参数：传入一个数组进行存储&#13;
        //Physics.OverlapCapsuleNonAlloc&#13;
        if (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders) != 0) { };&#13;
        #endregion&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 写一个cube wasd移动转向+jkl检测物体&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson22_exercises : MonoBehaviour&#13;
{&#13;
    public float moveSpeed = 10;&#13;
    public float roundSpeed = 20;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        &#13;
    }&#13;
&#13;
    // Update is called once per frame&#13;
    void Update()&#13;
    {&#13;
        //Input.GetAxis("Horizontal"); //控制左右&#13;
        //Input.GetAxis("vertical"); //控制前后&#13;
        //位移&#13;
        this.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis("Vertical"));&#13;
        //旋转&#13;
        this.transform.Rotate(Vector3.up, Input.GetAxis("Horizontal") * roundSpeed * Time.deltaTime);&#13;
&#13;
        if(Input.GetKeyDown(KeyCode.J))&#13;
        {&#13;
            //Vector3.one 创建的是长宽高的一半&#13;
            //Quaternion.identity 单位四元数 用于占位 本质是0，0，0&#13;
            //this.transform.rotation作为第三个参数这样可以让碰撞体和物体一起转动&#13;
            Collider[] colliders = Physics.OverlapBox(this.transform.position + this.transform.forward, Vector3.one * 0.5f,&#13;
                                                      this.transform.rotation,1 &lt;&lt; LayerMask.NameToLayer("Monster"));&#13;
            for (int i = 0; i &lt; colliders.Length; i++)&#13;
            {&#13;
                print("物体受伤" + colliders[i].name);&#13;
            }&#13;
        }&#13;
        else if(Input.GetKeyDown(KeyCode.K))&#13;
        {&#13;
            Collider[] colliders = Physics.OverlapCapsule(this.transform.position,this.transform.position + this.transform.forward * 5,&#13;
                                                          0.5f,1 &lt;&lt; LayerMask.NameToLayer("Monster"));&#13;
            for (int i = 0; i &lt; colliders.Length; i++)&#13;
            {&#13;
                print("物体受伤" + colliders[i].name);&#13;
            }&#13;
        }&#13;
        else if (Input.GetKeyDown(KeyCode.L))&#13;
        {&#13;
            Collider[] colliders = Physics.OverlapSphere(this.transform.position,10,1 &lt;&lt; LayerMask.NameToLayer("Monster"));&#13;
            for (int i = 0; i &lt; colliders.Length; i++)&#13;
            {&#13;
                print("物体受伤" + colliders[i].name);&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-wu-li-xi-tong-_-fan-wei-jian-ce.html</guid><pubDate>Tue, 23 Jan 2024 13:46:07 +0000</pubDate></item><item><title>Unity.代码实现LineRender画圆以及常按画线</title><link>https://natsunokoide.github.io//post/Unity.-dai-ma-shi-xian-LineRender-hua-yuan-yi-ji-chang-an-hua-xian.html</link><description>### LineRender画圆函数&#13;
```js&#13;
public void DrawLineRenderer(Vector3 centerPos, float r, int pointNum)&#13;
    {&#13;
        //动态创建 画线对象&#13;
        GameObject obj = new GameObject();&#13;
        obj.name = "R";&#13;
        LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();&#13;
        line.loop = false;&#13;
        //设置有多少个点&#13;
        line.positionCount = pointNum;&#13;
        //让其首尾相连&#13;
        line.loop = true;&#13;
&#13;
        //得到每个点之间 间隔的度数&#13;
        float angle = 360f / pointNum;&#13;
&#13;
        //准备得到每一个点&#13;
        for (int i = 0; i &lt; pointNum; i++)&#13;
        {&#13;
            //知识点&#13;
            //1.点加向量 相当于平移点&#13;
            //2.四元数 * 向量 相当于在 旋转向量&#13;
            line.SetPosition(i, centerPos + Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r);&#13;
        }&#13;
    }&#13;
```&#13;
### 常按画线&#13;
```js&#13;
    private LineRenderer line2;&#13;
    private Vector3 nowPos;&#13;
    void Update()&#13;
    {&#13;
        //这样写可以画多条线而不是一直连续 ，鼠标每抬起一次就会创建一条新的linerenderer&#13;
        if (Input.GetMouseButtonDown(0))&#13;
        {&#13;
            GameObject obj = new GameObject();&#13;
            line2 = obj.AddComponent&lt;LineRenderer&gt;();&#13;
            line2.loop = false;&#13;
            line2.startWidth = 0.5f;&#13;
            line2.endWidth = 0.5f;&#13;
&#13;
            line2.positionCount = 0;&#13;
        }&#13;
        //使得用户可以长按鼠标画linerenderer线&#13;
        if (Input.GetMouseButton(0))&#13;
        {&#13;
            line2.positionCount += 1;&#13;
            //如何得到鼠标转世界坐标的 对应点 &#13;
            //知识点&#13;
&#13;
            //1.如何得到鼠标位置&#13;
            //Input.mousePosition&#13;
            //2.怎么把鼠标 屏幕坐标转世界坐标&#13;
            //Camera.main.ScreenToWorldPoint(Input.mousePosition);&#13;
&#13;
            nowPos = Input.mousePosition;&#13;
            //需要把位置往前方推一点 才能让摄像机看到&#13;
            nowPos.z = 10; //修改z非常关键不然相机会记录不到&#13;
            line2.SetPosition(line2.positionCount - 1, Camera.main.ScreenToWorldPoint(nowPos)); //Camera.main.ScreenToWorldPoint非常关键——屏幕坐标转世界坐标操作&#13;
        }&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-dai-ma-shi-xian-LineRender-hua-yuan-yi-ji-chang-an-hua-xian.html</guid><pubDate>Tue, 23 Jan 2024 13:39:36 +0000</pubDate></item><item><title>Acwing 91.最短Hamilton路径</title><link>https://natsunokoide.github.io//post/Acwing%2091.-zui-duan-Hamilton-lu-jing.html</link><description>### 题目&#13;
给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1的最短 Hamilton 路径。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%2091.-zui-duan-Hamilton-lu-jing.html</guid><pubDate>Tue, 23 Jan 2024 08:06:36 +0000</pubDate></item><item><title>Unity.LineRenderer类</title><link>https://natsunokoide.github.io//post/Unity.LineRenderer-lei.html</link><description>### LineRenderer类&#13;
&#13;
&gt; 相关介绍以及常用API说明&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson21 : MonoBehaviour&#13;
{&#13;
    private Material m;&#13;
    void Start()&#13;
    {&#13;
        #region LineRenderer是什么&#13;
        //LineRenderer是Unity提供的一个用于画线的组件&#13;
        //使用它我们可以在场景中绘制线段&#13;
        //一般可以用于&#13;
        //1绘制攻击范围&#13;
        //2武器红外线&#13;
        //3辅助功能&#13;
        //4其它画线功能&#13;
        #endregion&#13;
&#13;
        #region LineRender代码相关  如果忘记了api在lineRenderer类里面自己找&#13;
        //动态添加一个线段，空物体&#13;
        GameObject line = new GameObject();&#13;
        //把空物体对象改名为Line&#13;
        line.name = "Line";&#13;
        //代码挂载LineRenderer&#13;
        LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;();&#13;
&#13;
        //首尾相连&#13;
        lineRenderer.loop = true;&#13;
&#13;
        //开始结束宽&#13;
        lineRenderer.startWidth = 0.02f;&#13;
        lineRenderer.endWidth = 0.02f;&#13;
&#13;
        //开始结束颜色&#13;
        lineRenderer.startColor = Color.white;&#13;
        lineRenderer.endColor = Color.red;&#13;
&#13;
        //设置材质&#13;
        //使用Resources同步加载&#13;
        m = Resources.Load&lt;Material&gt;("M");&#13;
        lineRenderer.material = m;&#13;
&#13;
        //设置点&#13;
        //一定注意 设置点 要 先设置点的个数&#13;
        lineRenderer.positionCount = 4;&#13;
        //接着就设置 对应每个点的位置&#13;
        //如果设置的点少于positionCount的个数 unity会用0，0，0点填充&#13;
        lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0),&#13;
                                                  new Vector3(0,0,5),&#13;
                                                  new Vector3(5,0,5)});&#13;
        lineRenderer.SetPosition(3, new Vector3(5, 0, 0));&#13;
&#13;
        //是否使用世界坐标系&#13;
        //决定了 是否随对象移动而移动&#13;
        lineRenderer.useWorldSpace = false;&#13;
&#13;
        //让线段受光影响 会接受光数据 进行着色器计算&#13;
        lineRenderer.generateLightingData = true;&#13;
        #endregion&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### LineRenderer类在Unity编辑器中的参数 （出自唐老狮课件）&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/4b4460ce-ebc3-48af-94b8-cb5e4bdea61d)&#13;
&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/422257e6-06c6-49e6-80b4-d526b60348e0)&#13;
&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/47c91c30-901d-4d5b-a2b4-6e411c0dcb64)&#13;
&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/00a605af-0d59-40b2-88b8-b43ad0b77983)&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.LineRenderer-lei.html</guid><pubDate>Mon, 22 Jan 2024 14:47:37 +0000</pubDate></item><item><title>Unity.异步加载场景</title><link>https://natsunokoide.github.io//post/Unity.-yi-bu-jia-zai-chang-jing.html</link><description>### 异步加载场景&#13;
&#13;
&gt; 代码以及总结&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.SceneManagement;&#13;
&#13;
public class Lesson20 : MonoBehaviour&#13;
{&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点一 回顾场景同步切换&#13;
        //SceneManager.LoadScene("Lesson20test");&#13;
&#13;
&#13;
        //需要在build settings中添加场景才能使用&#13;
&#13;
        //同步切换的缺点：&#13;
        //1.unity会删除当前场景的所有对象&#13;
        //2.同时加载下一个场景的相关信息&#13;
        //3.当前对象过多或者下一个场景对象过多时 会非常耗时并造成卡顿&#13;
&#13;
        //对于切换的卡顿 可以用异步切换解决这个问题&#13;
        #endregion&#13;
&#13;
        #region 知识点二 场景异步加载&#13;
        //1.通过事件回调函数 实现异步加载&#13;
        //AsyncOperation oa =  SceneManager.LoadSceneAsync("Lesson20test");&#13;
        //当场景异步加载结束后 自动调用事件函数 &#13;
        //如果希望在加载之后做一些说明 可以把逻辑加入到事件中&#13;
        //oa.completed += (a) =&gt;&#13;
        //{&#13;
        //    print("加载结束");&#13;
        //};&#13;
        //oa.completed += LoadOver;&#13;
&#13;
&#13;
        //2.通过协程异步加载&#13;
        //加载场景会把当前场景上 没有特殊处理的对象都删除&#13;
        //所以协程中部分逻辑 可能执行部不了&#13;
&#13;
        //解决办法：让处理场景加载的脚本衣服的对象 过场景时 不被移除&#13;
        //         使用函数 DontDestroyOnLoad（this.gameobject）;&#13;
&#13;
        DontDestroyOnLoad(this.gameObject);&#13;
        StartCoroutine(LoadScenes("Lesson20test"));&#13;
        #endregion&#13;
    }&#13;
&#13;
    private void LoadOver(AsyncOperation ao)&#13;
    {&#13;
        print("loadover");&#13;
    }&#13;
&#13;
    IEnumerator LoadScenes(string name)&#13;
    {&#13;
        AsyncOperation ao = SceneManager.LoadSceneAsync(name);&#13;
        //unity内部会发现是异步加载类型的返回对象 &#13;
        //会等待异步加载结束后 才会执行迭代器之后的内容&#13;
        //协程的好处 是异步加载场景时 可以在加载的同时做一些别的逻辑&#13;
        print("异步加载中");&#13;
        //yield return ao;&#13;
        //print("异步加载后");&#13;
&#13;
&#13;
        //可以在异步加载过程中 更新进度条&#13;
        //第一种 利用场景异步加载的进度 更新 但不准确 不常用&#13;
        while(!ao.isDone)&#13;
        {&#13;
            print(ao.progress);&#13;
            yield return null;&#13;
        }&#13;
        //离开循环 意味着加载结束 进度套满 完成切换 然后对进度条隐藏&#13;
&#13;
&#13;
        //第二种 根据游戏规则 自己定义 进度条变化的条件&#13;
        yield return ao;&#13;
        //场景加载结束 更新20%&#13;
        //接着加载场景的其他信息 比如加载怪物&#13;
        //再更新20% &#13;
        //接着加载场景模型 ……………………&#13;
    }&#13;
}&#13;
&#13;
#region 总结&#13;
//场景异步加载 和 资源异步加载 一样&#13;
//有两种方式&#13;
//1.通过事件回调函数&#13;
//2.协程异步加载&#13;
&#13;
//他们的优缺点表现和资源异步加载 也是一样的&#13;
//1.事件回调函数&#13;
//优点：写法简单，逻辑清晰&#13;
//缺点：只能加载完场景做一些事情 不能再加载过程中处理逻辑&#13;
//2.协程异步加载&#13;
//优点：可以在加载过程中处理逻辑，比如进度条更新等&#13;
//缺点：写法较为麻烦，要通过协程&#13;
#endregion&#13;
&#13;
```&#13;
&#13;
### 写一个异步加载场景的管理器&#13;
&#13;
&gt; 管理器代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
using UnityEngine.SceneManagement;&#13;
&#13;
public class SceneMgr &#13;
{&#13;
    private static SceneMgr instance = new SceneMgr();&#13;
    public static SceneMgr Instance =&gt; instance;&#13;
    private SceneMgr() { }&#13;
&#13;
    public void LoadScene(string name,UnityAction action)&#13;
    {&#13;
        AsyncOperation ao = SceneManager.LoadSceneAsync(name);&#13;
        //只是completed加入的委托一定要给予一个参数 此处a并没有用到&#13;
        ao.completed += (a) =&gt;&#13;
         {&#13;
             //通过lamda表达式包裹一层 在内部直接调用外部传入的委托&#13;
             action();&#13;
         };&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&gt; 管理器测试脚本&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson20Test : MonoBehaviour&#13;
{&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        SceneMgr.Instance.LoadScene("Lesson20test", () =&gt; &#13;
        {&#13;
            print("加载结束");&#13;
        });&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-yi-bu-jia-zai-chang-jing.html</guid><pubDate>Mon, 22 Jan 2024 13:49:54 +0000</pubDate></item><item><title>Acwing 291.蒙德里安的梦想</title><link>https://natsunokoide.github.io//post/Acwing%20291.-meng-de-li-an-de-meng-xiang.html</link><description>### 题目&#13;
n×m的棋盘可以摆放不同的1×2小方格的种类数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20291.-meng-de-li-an-de-meng-xiang.html</guid><pubDate>Mon, 22 Jan 2024 09:19:53 +0000</pubDate></item><item><title>Unity.Resources资源卸载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-xie-zai.html</link><description>### Resources资源卸载&#13;
&#13;
1. Resources是否存在重复加载资源以及内存消耗&#13;
Resources加载一次资源后，资源会存放在内存中作为缓存。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-xie-zai.html</guid><pubDate>Sun, 21 Jan 2024 11:13:00 +0000</pubDate></item><item><title>Unity.Resources异步加载管理器</title><link>https://natsunokoide.github.io//post/Unity.Resources-yi-bu-jia-zai-guan-li-qi.html</link><description>### Resources异步加载管理器&#13;
&#13;
### 单例模式实现资源异步加载管理&#13;
**用于对象化resources资源的异步加载，使得其他脚本在加载资源的时候更加便利，只需要输入地址和结束后需要响应的函数即可**&#13;
&#13;
&gt; 异步资源加载管理器代码（ResourcesMgr）&#13;
_运用单例模式进行编写，由于没有继承mono所以instance需要实例化_&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
&#13;
public class ResourcesMgr &#13;
{&#13;
    private static ResourcesMgr instance = new ResourcesMgr();&#13;
    public static ResourcesMgr Instance =&gt; instance;&#13;
    private ResourcesMgr(){}；&#13;
&#13;
    //在Resources类中 对于LoadAsync函数中的泛型T有object约束 所以a as ResourceRequest 需要定义函数内变量的约束&#13;
    //public static ResourceRequest LoadAsync&lt;T&gt;(string path) where T : Object;&#13;
    //泛型unity委托是有参委托&#13;
    public void LoadRes&lt;T&gt;(string address,UnityAction&lt;T&gt; callBack) where T : Object&#13;
    {&#13;
        ResourceRequest rq = Resources.LoadAsync(address);&#13;
        rq.completed += (a) =&gt;&#13;
        {&#13;
            callBack((a as ResourceRequest).asset as T);&#13;
        };&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&gt; 演示如何在text脚本中使用&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson18Text : MonoBehaviour&#13;
{&#13;
    private Texture tex;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        ResourcesMgr.Instance.LoadRes&lt;Texture&gt;("软考", (obj) =&gt;&#13;
        {&#13;
            tex = obj;&#13;
        });&#13;
&#13;
    }&#13;
&#13;
    private void OnGUI()&#13;
    {&#13;
        if(tex != null)&#13;
            GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-yi-bu-jia-zai-guan-li-qi.html</guid><pubDate>Sun, 21 Jan 2024 10:54:46 +0000</pubDate></item><item><title>Acwing 338.计数问题</title><link>https://natsunokoide.github.io//post/Acwing%20338.-ji-shu-wen-ti.html</link><description>### 题目&#13;
给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9的出现次数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20338.-ji-shu-wen-ti.html</guid><pubDate>Sun, 21 Jan 2024 06:44:54 +0000</pubDate></item><item><title>Acwing 900.整数划分（计数DP）</title><link>https://natsunokoide.github.io//post/Acwing%20900.-zheng-shu-hua-fen-%EF%BC%88-ji-shu-DP%EF%BC%89.html</link><description>### 题目&#13;
一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20900.-zheng-shu-hua-fen-%EF%BC%88-ji-shu-DP%EF%BC%89.html</guid><pubDate>Sat, 20 Jan 2024 05:17:20 +0000</pubDate></item><item><title>Acwing 899.编辑距离（最短距离问题的质询版本）</title><link>https://natsunokoide.github.io//post/Acwing%20899.-bian-ji-ju-li-%EF%BC%88-zui-duan-ju-li-wen-ti-de-zhi-xun-ban-ben-%EF%BC%89.html</link><description>### 题目&#13;
给定 n个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-bian-ji-ju-li-%EF%BC%88-zui-duan-ju-li-wen-ti-de-zhi-xun-ban-ben-%EF%BC%89.html</guid><pubDate>Tue, 16 Jan 2024 14:03:31 +0000</pubDate></item><item><title>Unity.Resources资源异步加载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-yi-bu-jia-zai.html</link><description>### Resources异步加载&#13;
### 对于异步加载的定义是什么&#13;
如果加载过大的资源可能会造成程序卡顿&#13;
卡顿的原因就是 从硬盘上把数据读取到内存中 是需要进行计算的&#13;
越大的资源耗时越长，就会造成掉帧卡顿&#13;
&#13;
&gt; Resources异步加载 就是内部新开一个线程进行资源加载 不会造成主线程卡顿&#13;
&#13;
### Resources异步加载方式&#13;
&#13;
1. 通过ResourceRequest中的事件实现异步加载&#13;
```js&#13;
// Unity 在内部 实例化一个rq请求 这个请求会去开一个线程进行资源下载&#13;
ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;("Tex/TestJPG");&#13;
//对资源下载结束这一事件进行监听&#13;
rq.completed += LoadOver;&#13;
//不能直接在 ResourceRequest rq 下一行直接调用 rq.asset 此时资源还没有加载完&#13;
```&#13;
```js&#13;
//completed事件需要形参 AsyncOperation 也就是正在监听是否结束的事件&#13;
private void LoadOver(AsyncOperation rq)&#13;
    {&#13;
        print("加载结束");&#13;
        //asset 是资源对象 加载完毕过后 就能够得到它&#13;
        //需要将AsyncOperation转换为ResourceRequest才能点出asset资源属性才能 再从资源as为目标对象类型&#13;
        tex = (rq as ResourceRequest).asset as Texture;&#13;
    }&#13;
private void OnGUI()&#13;
    {&#13;
        //判定tex对象不为空后 进行gui绘制&#13;
        if (tex != null)&#13;
            GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);&#13;
    }&#13;
```&#13;
2. 通过协程实现 异步加载资源&#13;
```js&#13;
void start()&#13;
{&#13;
     //在start函数中 开启协程 运行 协程函数load&#13;
     StartCoroutine(Load());&#13;
}&#13;
```&#13;
```js&#13;
 IEnumerator Load()&#13;
    {&#13;
        //迭代器函数 当遇到yield return时  就会停止执行之后的代码&#13;
        //协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时&#13;
        ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;("Tex/TestJPG");&#13;
&#13;
        //第一部分&#13;
        //Unity 自己知道 该返回值 意味着你在异步加载资源 &#13;
&#13;
        yield return rq; &#13;
        //通过yield return 一个ResourceRequest 可以让协程知道在运行异步加载&#13;
&#13;
        //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码&#13;
&#13;
         //另一种判断资源是否加载的方式 &#13;
        //判断资源是否加载结束&#13;
        while (!rq.isDone)&#13;
        {&#13;
            //打印当前的 加载进度 &#13;
            //该进度 不会特别准确 过渡也不是特别明显&#13;
            print(rq.progress);&#13;
            yield return null;&#13;
        }&#13;
        tex = rq.asset as Texture;&#13;
&#13;
        //yield return null;&#13;
        ////第二部分&#13;
        //yield return new WaitForSeconds(2f);&#13;
        ////第三部分&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-yi-bu-jia-zai.html</guid><pubDate>Mon, 15 Jan 2024 12:32:58 +0000</pubDate></item><item><title>Unity.Resources资源动态加载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-dong-tai-jia-zai.html</link><description>### Resources资源动态加载&#13;
&#13;
### 1. Resources资源动态加载的作用&#13;
1. 通过代码动态加载Resources文件夹下指定路径资源&#13;
2. 避免繁琐的拖曳操作&#13;
&#13;
### 2.常用资源类型&#13;
1.预设体对象——GameObject&#13;
2.音效文件——AudioClip&#13;
3.文本文件——TextAsset&#13;
4.图片文件——Texture&#13;
5.其它类型&#13;
&#13;
&gt; 预设体对象加载需要实例化,其它资源加载一般直接用&#13;
&#13;
### 3.资源同步加载 普通方法&#13;
&#13;
1. 在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 打包时 Resources文件夹 里的内容 都会打包在一起.&#13;
2. 预设体对象:第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) 第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化&#13;
```js&#13;
Object obj = Resources.Load("Cube");&#13;
Instantiate(obj);&#13;
```&#13;
_预设体的初始化操作是必须的_&#13;
&#13;
3.音效资源:第一步：就是加载数据 第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可&#13;
```js&#13;
public AudioSource audioS;&#13;
Object obj3 = Resources.Load("Music/BKMusic");&#13;
 audioS.clip = obj3 as AudioClip;&#13;
audioS.Play();&#13;
```&#13;
&#13;
4.文本资源:支持主流格式包括 txt,xml,bytes,json,html,csv……&#13;
```js&#13;
 TextAsset ta = Resources.Load("Txt/Test") as TextAsset;&#13;
 print(ta.text);&#13;
```&#13;
&#13;
5.图片资源&#13;
```js&#13;
private Texture tex;&#13;
tex = Resources.Load("Tex/TestJPG") as Texture;&#13;
```&#13;
&#13;
6.资源同名问题&#13;
显然Resources.Load加载同名资源时 无法准确加载出你想要的内容&#13;
解决方案有：&#13;
   (1)加载指定类型的资源&#13;
```js&#13;
 tex = Resources.Load("Tex/TestJPG", typeof(Texture)) as Texture;&#13;
```&#13;
   (2)加载指定名字的所有资源&#13;
```js&#13;
 Object[] objs = Resources.LoadAll("Tex/TestJPG");&#13;
        foreach (Object item in objs)&#13;
            if (item is Texture)&#13;
            else if (item is TextAsset)&#13;
```&#13;
&#13;
### 4. 解决资源类型和同名问题   泛型方法&#13;
&#13;
&gt; unity在Resources中提供了泛型接口 直接在使用的时候定义好类型即可&#13;
```js&#13;
TextAsset ta2 = Resources.Load&lt;TextAsset&gt;("Tex/TestJPG");&#13;
print(ta2.text);&#13;
tex = Resources.Load&lt;Texture&gt;("Tex/TestJPG");&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-dong-tai-jia-zai.html</guid><pubDate>Mon, 15 Jan 2024 07:45:33 +0000</pubDate></item><item><title>Unity.各类特殊文件</title><link>https://natsunokoide.github.io//post/Unity.-ge-lei-te-shu-wen-jian.html</link><description>### 1. 工程路径的获取&#13;
**该方式 获取到的路径 一般情况下 只在 编辑模式下使用&#13;
游戏发布过后 该路径不存在**&#13;
```js&#13;
print(Application.datePath);&#13;
```&#13;
###  2. Resources 资源文件夹&#13;
&#13;
_一般不获取,只能使用Resources相关API进行加载,需要我们自己将创建_&#13;
&#13;
**作用：&#13;
        资源文件夹&#13;
        1-1.需要通过Resources相关API动态加载的资源需要放在其中&#13;
        1-2.该文件夹下所有文件都会被打包出去&#13;
        1-3.打包时Unity会对其压缩加密&#13;
        1-4.该文件夹打包后只读 只能通过Resources相关API加载**&#13;
&#13;
###  3. StreamingAssets 流动资源文件夹&#13;
```js&#13;
print(Application.streamingAssetsPath);&#13;
```&#13;
_可以被主动获取，文件夹需要自己创建 _&#13;
**作用：&#13;
        流文件夹&#13;
        2-1.打包出去不会被压缩加密，可以任由我们摆布&#13;
        2-2.移动平台只读，PC平台可读可写&#13;
        2-3.可以放入一些需要自定义动态加载的初始资源**&#13;
&#13;
### 4. persistentDataPath 持久数据文件夹&#13;
```js&#13;
print(Application.persistentDataPath);&#13;
```&#13;
_可以被主动获取，不需要自己创建文件夹_&#13;
**固定数据文件夹&#13;
        3-1.所有平台都可读可写&#13;
        3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中**&#13;
&#13;
### 5. 其余特殊文件夹&#13;
&#13;
1. Plugins 插件文件夹：一般不获取，自己创建，存放不同平台的插件相关文件。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-ge-lei-te-shu-wen-jian.html</guid><pubDate>Mon, 15 Jan 2024 07:04:08 +0000</pubDate></item><item><title>Acwing 902.最短编辑距离</title><link>https://natsunokoide.github.io//post/Acwing%20902.-zui-duan-bian-ji-ju-li.html</link><description>### 题目&#13;
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：&#13;
1.删除–将字符串 A中的某个字符删除。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20902.-zui-duan-bian-ji-ju-li.html</guid><pubDate>Mon, 15 Jan 2024 04:57:43 +0000</pubDate></item><item><title>Acwing 896.最长上升子序列Ⅱ</title><link>https://natsunokoide.github.io//post/Acwing%20896.-zui-chang-shang-sheng-zi-xu-lie-%E2%85%A1.html</link><description>### 题目&#13;
给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20896.-zui-chang-shang-sheng-zi-xu-lie-%E2%85%A1.html</guid><pubDate>Sun, 14 Jan 2024 14:39:00 +0000</pubDate></item><item><title>Acwing 282.石子合并（区间DP）</title><link>https://natsunokoide.github.io//post/Acwing%20282.-shi-zi-he-bing-%EF%BC%88-qu-jian-DP%EF%BC%89.html</link><description>### 题目&#13;
**设有 N 堆石子排成一排，其编号为 1,2,3,…,N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20282.-shi-zi-he-bing-%EF%BC%88-qu-jian-DP%EF%BC%89.html</guid><pubDate>Fri, 05 Jan 2024 04:06:36 +0000</pubDate></item><item><title>Hot 100-7 LeetCode 42.接雨水</title><link>https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</link><description>### 题目&#13;
**给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</guid><pubDate>Sat, 30 Dec 2023 08:16:36 +0000</pubDate></item><item><title>Acwing 897.最长公共子序列</title><link>https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</link><description>### 题目&#13;
给定两个长度分别为 N 和 M的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</guid><pubDate>Sat, 30 Dec 2023 07:43:48 +0000</pubDate></item><item><title>Acwing 895.最长上升子序列</title><link>https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</link><description>### 题目&#13;
**给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</guid><pubDate>Fri, 29 Dec 2023 04:24:36 +0000</pubDate></item><item><title>Hot 100-6 LeetCode 15.三数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</link><description>### 题目&#13;
**给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</guid><pubDate>Thu, 28 Dec 2023 03:59:27 +0000</pubDate></item><item><title>Hot 100-5 LeetCode 11.盛最多水的容器</title><link>https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</link><description>### 题目&#13;
**给定一个长度为 n 的整数数组 height 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</guid><pubDate>Thu, 28 Dec 2023 03:40:07 +0000</pubDate></item><item><title>Acwing 898.数字三角形</title><link>https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</link><description>### 题目&#13;
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</guid><pubDate>Wed, 27 Dec 2023 01:59:41 +0000</pubDate></item><item><title>Hot 100-4 LeetCode 283.移动零</title><link>https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</link><description>### 题目&#13;
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</guid><pubDate>Tue, 26 Dec 2023 03:01:56 +0000</pubDate></item><item><title>Acwing 9.分组背包问题</title><link>https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</link><description>### 分组背包问题&#13;
有 N 组物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</guid><pubDate>Mon, 25 Dec 2023 04:17:12 +0000</pubDate></item><item><title>Acwing 5.多重背包问题Ⅱ（二进制优化物品个数问题）</title><link>https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</link><description>### 有 N种物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</guid><pubDate>Sun, 24 Dec 2023 06:25:08 +0000</pubDate></item><item><title>Acwing 4.多重背包问题Ⅰ</title><link>https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</link><description>### 题目有 N种物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</guid><pubDate>Sun, 24 Dec 2023 04:34:41 +0000</pubDate></item><item><title>Hot 100-3 LeetCode 128.最长连续序列</title><link>https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</link><description>### 题目&#13;
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</guid><pubDate>Sat, 23 Dec 2023 03:14:47 +0000</pubDate></item><item><title>Acwing 3.完全背包问题 </title><link>https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</link><description>### 完全背包问题&#13;
**有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</guid><pubDate>Sat, 23 Dec 2023 02:28:10 +0000</pubDate></item><item><title>Hot 100-2 LeetCode 49.字母异位词分组</title><link>https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</link><description>### 题目&#13;
**给你一个字符串数组，请你将 字母异位词 组合在一起。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</guid><pubDate>Fri, 22 Dec 2023 04:35:06 +0000</pubDate></item><item><title>Acwing 2.01背包问题（要求一维二维数组两组求解方案）</title><link>https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</link><description>### 0-1背包问题&#13;
**有 N 件物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</guid><pubDate>Fri, 22 Dec 2023 03:13:13 +0000</pubDate></item><item><title>Hot 100-1 LeetCode 1.两数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</link><description>### 题目&#13;
**给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</guid><pubDate>Thu, 21 Dec 2023 05:15:36 +0000</pubDate></item><item><title>Acwing 894.拆分-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</link><description>### Nim游戏的基础理论 在 #4 Nim游戏 中&#13;
### 拆分-Nim游戏 的 思考方式类似于集合-Nim游戏 需要针对不同的局面进行异或 #7 （SG函数）&#13;
&#13;
&gt; 拆分-Nim游戏的核心&#13;
**本题主要在于 每一次拆分两组的数量虽然可以大于原石头堆 但是每一组不可以大于原堆的石头数&#13;
   所以每一轮拆分都会至少使得上一轮的最大值-1，从而遍历所有情况总能使得有一方石头堆归零，无法继续操作。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</guid><pubDate>Thu, 21 Dec 2023 02:09:57 +0000</pubDate></item><item><title>Acwing 893.集合-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</link><description>### 集合-Nim游戏&#13;
**集合类型的Nim游戏问题在Nim之前需要对每一个集合进行SG函数计算并分析SG的结果**&#13;
&#13;
&gt; 知识点 1 mex( )函数&#13;
_mex（）：设集合S是一个非负整数集合，定义mex（S）为求出不属于S的最小非负整数的运算&#13;
  mes（S）= min[x],其中x属于自然数，且x不属于_&#13;
**可以理解为mex就是得出S中不存在的最小的数**&#13;
&#13;
&gt; 知识点 2 SG( )函数&#13;
_SG( ):：在有向图中，对于每个节点x,设x触发共有k条边，分别到达节点y1，y2……yk&#13;
  SG(x)为x的后继节点的SG值构成的集合执行mex（）运算后的值&#13;
  即SG（x） = mex（SG(y1),SG(y2),SG(y3)……SG（yk））&#13;
性质1：SG(i)  = k，则i最大能到达的SG值为k-1&#13;
性质2：非0可以走向0&#13;
性质3：0只能走向非0_&#13;
&#13;
### 本题最重要的定理&#13;
**对于n个图（集合）如果SG（G1）^SG(G2)^……SG(Gn) != 0 则先手必胜，反之先手必败**&#13;
&#13;
_对于理论部分，引用Acwing用户E.lena的手写图解_&#13;
[https://www.acwing.com/solution/content/23435/](url)&#13;
&#13;
### 题目内容&#13;
**给定 n堆石子以及一个由 k个不同正整数构成的数字集合 S。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:58:13 +0000</pubDate></item><item><title>Acwing 892.台阶-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</link><description>### 结论&#13;
**在Acwing 891的基础上，此题将传统Nim游戏问题拓展到台阶，有结论为：如果先手的奇数台阶上的值异或为0，则先手必败，反之亦然。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:02:38 +0000</pubDate></item><item><title>Unity.四元数</title><link>https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</link><description>### 轴-角对&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/fb7ce126-6726-4819-bebf-a2dfa19a1f75)&#13;
&#13;
### unity中的四元数结构体 —— Quaternion&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/db2d3b39-ca81-4b03-85ec-c2898ba6e7ae)&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/90418e9d-fb10-4fc1-a528-0ea20316fe95)&#13;
&#13;
&gt; 四元数公式api的使用用例&#13;
```js&#13;
//写一个 绕轴x 60度旋转 的cube&#13;
        Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30) * Mathf.Deg2Rad);&#13;
        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);&#13;
        obj.transform.rotation = q; &#13;
//q2与q相同 只是api不同&#13;
        Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right);&#13;
```&#13;
&#13;
&gt; 四元数和欧拉角转换&#13;
```js&#13;
        //1.欧拉直接赋值给四元数&#13;
        Quaternion q3 = Quaternion.Euler(120, 0, 0);&#13;
        obj.transform.rotation = q3;&#13;
        //2.四元数转欧拉角&#13;
        print(q3.eulerAngles);&#13;
```&#13;
&#13;
&gt; 四元数相乘——旋转（不会万向节死锁）&#13;
```js&#13;
        this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.forward); &#13;
```&#13;
&#13;
&gt; !!!!写一种会产生万向节死锁的方法（错误案例）&#13;
```js&#13;
        e = this.transform.rotation.eulerAngles;&#13;
        e += Vector3.forward;&#13;
        this.transform.rotation = Quaternion.Euler(e);&#13;
```&#13;
### 单位四元数——代表没有旋转&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/7e3c13a5-2def-426e-a612-2443e74416f6)&#13;
&#13;
```js&#13;
#region 知识点1 单位四元数&#13;
        print(Quaternion.identity);&#13;
        //直接让单位四元数赋值会直接让物体转角全部归零&#13;
        //obj.rotation = Quaternion.identity;&#13;
&#13;
        //Instantiate(obj, Vector3.zero, Quaternion.identity);&#13;
 #endregion&#13;
```&#13;
&#13;
### 四元数中的差值运算 + 通过看向的方式让物体一直盯着目标&#13;
```js&#13;
    public Quaternion start;&#13;
    public float time;&#13;
&#13;
    public Transform lookA;&#13;
    public Transform lookB;&#13;
void Start()&#13;
    {&#13;
        start = B.transform.rotation;&#13;
    }&#13;
void Update()&#13;
    {&#13;
&#13;
        #region 知识点2 插值运算 (在Quaternion中有lerp和slerp 但是lerp效果在大角度中一般所以就用slerp)&#13;
        //无限接近&#13;
        A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.transform.rotation, Time.deltaTime);&#13;
        //匀速  time &gt;= 1 到达目标&#13;
        time += Time.deltaTime;&#13;
        B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);&#13;
        #endregion&#13;
        #region 知识点3 lookrotation&#13;
        //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        lookA.rotation = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        #endregion&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</guid><pubDate>Tue, 19 Dec 2023 05:54:08 +0000</pubDate></item><item><title>Acwing 891.Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</link><description>### Nim游戏中的状态&#13;
**先手必胜状态：先手操作完，可以走到某一个必败状态&#13;
先手必败状态：先手操作完，走不到任何一个必败状态&#13;
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0&#13;
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0**&#13;
&#13;
### 结论&#13;
**假设n堆石头，石头的数量分别是a1，a2，a3……an。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</guid><pubDate>Tue, 19 Dec 2023 02:21:33 +0000</pubDate></item><item><title>Acwing 890.能被整除的数</title><link>https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</link><description>### 容斥原理&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/74e4f052-c584-420d-9027-d5efab16034b)&#13;
&#13;
### 实现思路&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/9ec8a3d0-3385-4127-a98a-217d07e992be)&#13;
&#13;
&gt; 此处给出一个答案用例 &#13;
&#13;
**n= 10，m = 2 ，p1 = 2， p2 = 3 解释为求1-10中能够满足被2或3整除的数字个数，答案为2，3，4，6，8，9，10，共7个**&#13;
&#13;
### Acwing 890.能被整除的数 代码 + 解析&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
using namespace std;&#13;
&#13;
using LL = long long;&#13;
&#13;
const int N = 20;&#13;
int p[N],n,m;&#13;
int res = 0;&#13;
&#13;
int main()&#13;
{&#13;
    cin &gt;&gt; n &gt;&gt; m;&#13;
    //先把输入的质数存到p数组中&#13;
    for(int i = 0;i &lt; m;i++) cin &gt;&gt; p[i];&#13;
    // 1 &lt;&lt; m 代表的是2的m次方 也就是2的m次方个二进制情况&#13;
    for(int i = 1;i &lt; 1 &lt;&lt; m;i++)&#13;
    {&#13;
        int t = 1;//用于记录当前组质数的总乘积&#13;
        int s = 0; //用来记录这一组二进制数有几个1，几个1代表包含几个集合&#13;
        //遍历当前组的各个位置&#13;
        for(int j = 0;j &lt; m;j++)&#13;
        {&#13;
            //判断到当前位置为1&#13;
            if(i &gt;&gt; j &amp; 1)&#13;
            {&#13;
                //质数的总乘积如果已经大于n呢么就break，此集合是空集&#13;
                if((LL)t * p[j] &gt; n) &#13;
                {&#13;
                    t = -1;&#13;
                    break;&#13;
                }&#13;
                s++; //i &gt;&gt; j &amp; 1 判定到当前位是1 s++&#13;
                t *= p[j]; //把当前1位置的质数乘到t中&#13;
            }&#13;
        }&#13;
        if(t != -1) //如果t的值没有超出总数，就对res进行计算&#13;
        {&#13;
            //这里涉及到容斥原理中 计算集合个数的公式 Si = n/pi（向下取整）（n为总数，pi为质数）&#13;
            //之前用t存储当前组所有质数的乘积 因为 S1交S2 = n/（p1*p2），所以使用t的乘积可以多个集合的情况&#13;
            //s代表1的个数，这是因为容斥原理每一项的系数为（-1）的（n-1）次方（n为1的个数）&#13;
            if(s &amp; 1) res += n / t; //(s &amp; 1)若为1 证明当前组包含奇数个集合（奇数个1）&#13;
            //如果是奇数的组合 根据容斥原理 为+号&#13;
            else res -= n / t; //反之为-号&#13;
        }&#13;
    }&#13;
    cout &lt;&lt; res &lt;&lt; endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
_此题涉及到容斥原理 和 二进制处理集合的情况_。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</guid><pubDate>Mon, 18 Dec 2023 09:23:11 +0000</pubDate></item><item><title>Acwing 899.满足条件的01序列</title><link>https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</link><description>### 卡特兰数&#13;
    &#13;
&#13;
&gt; 卡特兰数是组合数学中一个常出现于各种计数问题中的数列。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</guid><pubDate>Sat, 16 Dec 2023 05:23:12 +0000</pubDate></item><item><title>Acwing 888.求组合数IV </title><link>https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</link><description>&#13;
### 求组合数的基础公式：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/d3b140ef-012e-46ab-9edd-974cc4d97757)&#13;
### 其中阶乘可以转化为：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/ec00e7e3-2f42-46a3-bbf5-15df59e956fa)&#13;
&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const int N = 5010;&#13;
&#13;
int primes[N],cnt;&#13;
int sum[N];&#13;
bool st[N];&#13;
&#13;
void get_primes(int n)   //线性筛法求质数 cnt是个数 primes数组里装着质数&#13;
{&#13;
    for(int i = 2;i &lt;= n;i++)&#13;
    {&#13;
        if(!st[i]) primes[cnt++] = i;&#13;
        for(int j = 0;primes[j] * i &lt;= n;j++)&#13;
        {&#13;
            st[primes[j] * i] = true;&#13;
            if(i % primes[j] == 0) break;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int get(int n,int p) //// 求n！中包含p的次数&#13;
{&#13;
    int res = 0;&#13;
    while(n)&#13;
    {&#13;
        res += n/p;&#13;
        n /= p;&#13;
    }&#13;
    return res;&#13;
}&#13;
&#13;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)   //高精度乘法 用vector接收 和 输入 c++才要&#13;
{&#13;
    vector&lt;int&gt; C;&#13;
    int t = 0;&#13;
    for(int i = 0;t || i &lt; A.size();i++)&#13;
    {&#13;
        if(i &lt; A.size()) t += A[i] * b;&#13;
        C.push_back(t % 10);&#13;
        t /= 10;&#13;
    }&#13;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#13;
    return C;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    int a,b;&#13;
    cin &gt;&gt; a &gt;&gt; b;&#13;
    get_primes(a);&#13;
    //循环得到每一个质数的次数（这个次数不能重复）&#13;
    for(int i = 0;i &lt; cnt;i++) //cnt在get_primes函数里&#13;
    {&#13;
        int p = primes[i];&#13;
        sum[i] = get(a,p) - get(a-b,p) - get(b,p);&#13;
    }&#13;
    &#13;
    vector&lt;int&gt; res;&#13;
    res.push_back(1);&#13;
    &#13;
    for(int i = 0;i &lt; cnt;i++) //循环质数的个数&#13;
    {&#13;
        for(int j = 0;j &lt; sum[i];j++)//循环质数的次数&#13;
        {&#13;
            res = mul(res,primes[i]); //算出每一个质数的j次方&#13;
        }&#13;
    }&#13;
    //因为高精度乘法最后的输出是每一个数字以vector的方式呈现的 所以需要遍历整个数组才能得到最后的数字&#13;
    for(int i = res.size() - 1;i &gt;= 0;i--) printf("%d",res[i]);&#13;
    return 0;&#13;
} &#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</guid><pubDate>Thu, 14 Dec 2023 04:27:59 +0000</pubDate></item></channel></rss>