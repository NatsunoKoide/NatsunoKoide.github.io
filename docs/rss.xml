<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ADd7</title><link>https://natsunokoide.github.io/</link><description>C++ / C# / Unity 
 You are welcome to send us your valuable comments.  E-mail:yujiaqifinn@outlook.com</description><copyright>ADd7</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://i.postimg.cc/dtT4J441/image.png</url><title>avatar</title><link>https://natsunokoide.github.io/</link></image><lastBuildDate>Thu, 01 Aug 2024 11:46:53 +0000</lastBuildDate><managingEditor>ADd7</managingEditor><ttl>60</ttl><webMaster>ADd7</webMaster><item><title>面试150-17-LeetCode13.罗马数字转整数</title><link>https://natsunokoide.github.io//post/mian-shi-150-17-LeetCode13.-luo-ma-shu-zi-zhuan-zheng-shu.html</link><description>### 题目&#13;
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/mian-shi-150-17-LeetCode13.-luo-ma-shu-zi-zhuan-zheng-shu.html</guid><pubDate>Thu, 01 Aug 2024 11:46:17 +0000</pubDate></item><item><title>LuaMgr——版本一</title><link>https://natsunokoide.github.io//post/LuaMgr%E2%80%94%E2%80%94-ban-ben-yi.html</link><description>### LuaMgr——版本一&#13;
### 内容&#13;
**主要用于封装xlua的文件执行垃圾回收销毁&#13;
   关键内容 在于 对于本地文件的lua读取以及对于ab包内的lua读取 （重定向）&#13;
   提供可以获取_G表中 的全部lua全局变量 的属性**&#13;
&#13;
### 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.IO;&#13;
using UnityEngine;&#13;
using XLua;&#13;
&#13;
&#13;
/// &lt;summary&gt;&#13;
/// Lua管理器&#13;
/// &lt;/summary&gt;&#13;
public class LuaMgr : BaseManager&lt;LuaMgr&gt;&#13;
{&#13;
    private LuaEnv luaEnv;&#13;
&#13;
    public LuaTable Global&#13;
    {&#13;
        get&#13;
        {&#13;
            return luaEnv.Global;&#13;
        }&#13;
    }&#13;
&#13;
    private void Init()&#13;
    {&#13;
        //已经初始化 就直接返回&#13;
        if (luaEnv != null) return;&#13;
        //初始化&#13;
        luaEnv = new LuaEnv();&#13;
        //加载脚本 重定向&#13;
        luaEnv.AddLoader(MyCustomLoader);&#13;
        luaEnv.AddLoader(MyCustomABLoader);&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// DoString函数的简化版本&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='fileName'&gt;&lt;/param&gt;&#13;
    public void DoLuaFile(string fileName)&#13;
    {&#13;
        string str = string.Format('require('{0}')', fileName);&#13;
        DoString(str);&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 执行lua语言&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='str'&gt;&lt;/param&gt;&#13;
    public void DoString(string str)&#13;
    {&#13;
        luaEnv.DoString(str);&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 释放lua 垃圾&#13;
    /// &lt;/summary&gt;&#13;
    public void Tick()&#13;
    {&#13;
        luaEnv.Tick();&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 销毁解析器&#13;
    /// &lt;/summary&gt;&#13;
    public void Dispose()&#13;
    {&#13;
        luaEnv.Dispose();&#13;
        luaEnv = null;&#13;
    }&#13;
&#13;
    private byte[] MyCustomLoader(ref string filePath)&#13;
    {&#13;
        //Debug.Log(filePath);&#13;
&#13;
        //传入的参数是 require 执行的lua的脚本文件名&#13;
        //拼接一个lua文件的所在路径&#13;
        string path = Application.dataPath + '/Lua/' + filePath + '.lua';&#13;
        Debug.Log(path);&#13;
        //有路径就加载文件&#13;
        //file 只是点 c#提供的文件读写类&#13;
        if (File.Exists(path))&#13;
        {&#13;
            return File.ReadAllBytes(path);&#13;
        }&#13;
        else&#13;
        {&#13;
            Debug.Log('重定向失败，文件名为' + filePath);&#13;
        }&#13;
&#13;
        return null;&#13;
    }&#13;
&#13;
    private byte[] MyCustomABLoader(ref string filePath)&#13;
    {&#13;
        #region ab包内加载lua文件（不使用ab管理器）&#13;
        //Debug.Log('进入AB包加载 重定向函数');&#13;
        ////从AB包中加载lua文件&#13;
        ////加载AB包&#13;
        //string path = Application.streamingAssetsPath + '/lua';&#13;
        //AssetBundle ab = AssetBundle.LoadFromFile(path);&#13;
&#13;
        ////加载Lua文件 返回&#13;
        //TextAsset tx = ab.LoadAsset&lt;TextAsset&gt;(filePath + '.lua');&#13;
        ////加载Lua文件 byte数组&#13;
        //return tx.bytes;&#13;
        #endregion&#13;
&#13;
        #region  ab包内加载lua文件（使用ab管理器）&#13;
        TextAsset lua = ABMgr.GetInstance().LoadRes&lt;TextAsset&gt;('lua', filePath + '.lua');&#13;
        if (lua != null)&#13;
            return lua.bytes;&#13;
        else&#13;
            Debug.Log('MyCustomABLoader重定向失败，文件名为：' + filePath);&#13;
        return null;&#13;
        #endregion&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LuaMgr%E2%80%94%E2%80%94-ban-ben-yi.html</guid><pubDate>Thu, 11 Jul 2024 07:34:57 +0000</pubDate></item><item><title>BinaryDataMgr</title><link>https://natsunokoide.github.io//post/BinaryDataMgr.html</link><description>### 工具相关说明&#13;
**&#13;
1.Excel文件应该放置在ArtRes/Excel当中&#13;
如果想要修改 就去修改ExcelTool当中的EXCEL_PATH路径变量&#13;
2.配置表规则&#13;
	第一行：字段名&#13;
	第二行：字段类型（字段类型一定不要配置错误，字段类型目前只支持int float bool string）&#13;
	如果想要再添加类型，需要在ExcelTool的GenerateExcelBinary方法中&#13;
	和BinaryDataMgr的LoadTable方法当中对应添加读写的逻辑&#13;
	第三行：主键是哪一个字段 需要通过key来标识主键&#13;
	第四行：描述信息（只是给别人看，不会有别的作用）&#13;
	第五行~第n行：就是具体数据信息&#13;
	下方的表名决定了数据结构类，容器类，2进制文件的文件名&#13;
3.生成的容器类和数据结构类可以在ExcelTool当中修改DATA_CLASS_PATH和DATA_CONTAINER_PATH&#13;
变量来进行更改&#13;
4.生成2进制文件的路径可以在BinaryDataMgr当中的DATA_BINARY_PATH变量来进行修改&#13;
**&#13;
&#13;
### 脚本说明&#13;
**&#13;
ExcelTool：用于设置unity 的编辑器功能 和excel的读取写入 以及 excel文件摆放位置&#13;
BinaryDataMgr：实现容器类 数据结构类 以及二进制表的读取&#13;
**&#13;
&#13;
### 代码&#13;
### ExcelTool&#13;
```js&#13;
using Excel;&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Data;&#13;
using System.IO;&#13;
using System.Text;&#13;
using UnityEditor;&#13;
using UnityEngine;&#13;
&#13;
public class ExcelTool&#13;
{&#13;
    /// &lt;summary&gt;&#13;
    /// excel文件存放的路径&#13;
    /// &lt;/summary&gt;&#13;
    public static string EXCEL_PATH = Application.dataPath + '/ArtRes/Excel/';&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 数据结构类脚本存储位置路径&#13;
    /// &lt;/summary&gt;&#13;
    public static string DATA_CLASS_PATH = Application.dataPath + '/Scripts/ExcelData/DataClass/';&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 容器类脚本存储位置路径&#13;
    /// &lt;/summary&gt;&#13;
    public static string DATA_CONTAINER_PATH = Application.dataPath + '/Scripts/ExcelData/Container/';&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 真正内容开始的行号&#13;
    /// &lt;/summary&gt;&#13;
    public static int BEGIN_INDEX = 4;&#13;
&#13;
    [MenuItem('GameTool/GenerateExcel')]&#13;
    private static void GenerateExcelInfo()&#13;
    {&#13;
        //记在指定路径中的所有Excel文件 用于生成对应的3个文件&#13;
        DirectoryInfo dInfo = Directory.CreateDirectory(EXCEL_PATH);&#13;
        //得到指定路径中的所有文件信息 相当于就是得到所有的Excel表&#13;
        FileInfo[] files = dInfo.GetFiles();&#13;
        //数据表容器&#13;
        DataTableCollection tableConllection;&#13;
        for (int i = 0; i &lt; files.Length; i++)&#13;
        {&#13;
            //如果不是excel文件就不要处理了&#13;
            if (files[i].Extension != '.xlsx' &amp;&amp;&#13;
                files[i].Extension != '.xls')&#13;
                continue;&#13;
            //打开一个Excel文件得到其中的所有表的数据&#13;
            using (FileStream fs = files[i].Open(FileMode.Open, FileAccess.Read))&#13;
            {&#13;
                IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);&#13;
                tableConllection = excelReader.AsDataSet().Tables;&#13;
                fs.Close();&#13;
            }&#13;
&#13;
            //遍历文件中的所有表的信息&#13;
            foreach (DataTable table in tableConllection)&#13;
            {&#13;
                //生成数据结构类&#13;
                GenerateExcelDataClass(table);&#13;
                //生成容器类&#13;
                GenerateExcelContainer(table);&#13;
                //生成2进制数据&#13;
                GenerateExcelBinary(table);&#13;
            }&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 生成Excel表对应的数据结构类&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='table'&gt;&lt;/param&gt;&#13;
    private static void GenerateExcelDataClass(DataTable table)&#13;
    {&#13;
        //字段名行&#13;
        DataRow rowName = GetVariableNameRow(table);&#13;
        //字段类型行&#13;
        DataRow rowType = GetVariableTypeRow(table);&#13;
&#13;
        //判断路径是否存在 没有的话 就创建文件夹&#13;
        if (!Directory.Exists(DATA_CLASS_PATH))&#13;
            Directory.CreateDirectory(DATA_CLASS_PATH);&#13;
        //如果我们要生成对应的数据结构类脚本 其实就是通过代码进行字符串拼接 然后存进文件就行了&#13;
        string str = 'public class ' + table.TableName + '\n{\n';&#13;
&#13;
        //变量进行字符串拼接&#13;
        for (int i = 0; i &lt; table.Columns.Count; i++)&#13;
        {&#13;
            str += '    public ' + rowType[i].ToString() + ' ' + rowName[i].ToString() + ';\n';&#13;
        }&#13;
&#13;
        str += '}';&#13;
&#13;
        //把拼接好的字符串存到指定文件中去&#13;
        File.WriteAllText(DATA_CLASS_PATH + table.TableName + '.cs', str);&#13;
&#13;
        //刷新Project窗口&#13;
        AssetDatabase.Refresh();&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 生成Excel表对应的数据容器类&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='table'&gt;&lt;/param&gt;&#13;
    private static void GenerateExcelContainer(DataTable table)&#13;
    {&#13;
        //得到主键索引&#13;
        int keyIndex = GetKeyIndex(table);&#13;
        //得到字段类型行&#13;
        DataRow rowType = GetVariableTypeRow(table);&#13;
        //没有路径创建路径&#13;
        if (!Directory.Exists(DATA_CONTAINER_PATH))&#13;
            Directory.CreateDirectory(DATA_CONTAINER_PATH);&#13;
&#13;
        string str = 'using System.Collections.Generic;\n';&#13;
&#13;
        str += 'public class ' + table.TableName + 'Container' + '\n{\n';&#13;
&#13;
        str += '    ';&#13;
        str += 'public Dictionary&lt;' + rowType[keyIndex].ToString() + ', ' + table.TableName + '&gt;';&#13;
        str += 'dataDic = new ' + 'Dictionary&lt;' + rowType[keyIndex].ToString() + ', ' + table.TableName + '&gt;();\n';&#13;
&#13;
        str += '}';&#13;
&#13;
        File.WriteAllText(DATA_CONTAINER_PATH + table.TableName + 'Container.cs', str);&#13;
&#13;
        //刷新Project窗口&#13;
        AssetDatabase.Refresh();&#13;
    }&#13;
&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 生成excel2进制数据&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='table'&gt;&lt;/param&gt;&#13;
    private static void GenerateExcelBinary(DataTable table)&#13;
    {&#13;
        //没有路径创建路径&#13;
        if (!Directory.Exists(BinaryDataMgr.DATA_BINARY_PATH))&#13;
            Directory.CreateDirectory(BinaryDataMgr.DATA_BINARY_PATH);&#13;
&#13;
        //创建一个2进制文件进行写入&#13;
        using (FileStream fs = new FileStream(BinaryDataMgr.DATA_BINARY_PATH + table.TableName + '.tang', FileMode.OpenOrCreate, FileAccess.Write))&#13;
        {&#13;
            //存储具体的excel对应的2进制信息&#13;
            //1.先要存储我们需要写多少行的数据 方便我们读取&#13;
            //-4的原因是因为 前面4行是配置规则 并不是我们需要记录的数据内容&#13;
            fs.Write(BitConverter.GetBytes(table.Rows.Count - 4), 0, 4);&#13;
            //2.存储主键的变量名&#13;
            string keyName = GetVariableNameRow(table)[GetKeyIndex(table)].ToString();&#13;
            byte[] bytes = Encoding.UTF8.GetBytes(keyName);&#13;
            //存储字符串字节数组的长度&#13;
            fs.Write(BitConverter.GetBytes(bytes.Length), 0, 4);&#13;
            //存储字符串字节数组&#13;
            fs.Write(bytes, 0, bytes.Length);&#13;
&#13;
            //遍历所有内容的行 进行2进制的写入&#13;
            DataRow row;&#13;
            //得到类型行 根据类型来决定应该如何写入数据&#13;
            DataRow rowType = GetVariableTypeRow(table);&#13;
            for (int i = BEGIN_INDEX; i &lt; table.Rows.Count; i++)&#13;
            {&#13;
                //得到一行的数据&#13;
                row = table.Rows[i];&#13;
                for (int j = 0; j &lt; table.Columns.Count; j++)&#13;
                {&#13;
                    switch (rowType[j].ToString())&#13;
                    {&#13;
                        case 'int':&#13;
                            fs.Write(BitConverter.GetBytes(int.Parse(row[j].ToString())), 0, 4);&#13;
                            break;&#13;
                        case 'float':&#13;
                            fs.Write(BitConverter.GetBytes(float.Parse(row[j].ToString())), 0, 4);&#13;
                            break;&#13;
                        case 'bool':&#13;
                            fs.Write(BitConverter.GetBytes(bool.Parse(row[j].ToString())), 0, 1);&#13;
                            break;&#13;
                        case 'string':&#13;
                            bytes = Encoding.UTF8.GetBytes(row[j].ToString());&#13;
                            //写入字符串字节数组的长度&#13;
                            fs.Write(BitConverter.GetBytes(bytes.Length), 0, 4);&#13;
                            //写入字符串字节数组&#13;
                            fs.Write(bytes, 0, bytes.Length);&#13;
                            break;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            fs.Close();&#13;
        }&#13;
&#13;
        AssetDatabase.Refresh();&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 获取变量名所在行&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='table'&gt;&lt;/param&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    private static DataRow GetVariableNameRow(DataTable table)&#13;
    {&#13;
        return table.Rows[0];&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 获取变量类型所在行&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='table'&gt;&lt;/param&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    private static DataRow GetVariableTypeRow(DataTable table)&#13;
    {&#13;
        return table.Rows[1];&#13;
    }&#13;
&#13;
    &#13;
    /// &lt;summary&gt;&#13;
    /// 获取主键索引&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='table'&gt;&lt;/param&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    private static int GetKeyIndex(DataTable table)&#13;
    {&#13;
        DataRow row = table.Rows[2];&#13;
        for (int i = 0; i &lt; table.Columns.Count; i++)&#13;
        {&#13;
            if (row[i].ToString() == 'key')&#13;
                return i;&#13;
        }&#13;
        return 0;&#13;
    }&#13;
}&#13;
&#13;
```&#13;
&#13;
### BinaryDataMgr&#13;
```js&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.IO;&#13;
using System.Reflection;&#13;
using System.Runtime.Serialization.Formatters.Binary;&#13;
using System.Text;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 2进制数据管理器&#13;
/// &lt;/summary&gt;&#13;
public class BinaryDataMgr&#13;
{&#13;
    /// &lt;summary&gt;&#13;
    /// 2进制数据存储位置路径&#13;
    /// &lt;/summary&gt;&#13;
    public static string DATA_BINARY_PATH = Application.streamingAssetsPath + '/Binary/';&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 用于存储所有Excel表数据的容器&#13;
    /// &lt;/summary&gt;&#13;
    private Dictionary&lt;string, object&gt; tableDic = new Dictionary&lt;string, object&gt;();&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 数据存储的位置&#13;
    /// &lt;/summary&gt;&#13;
    private static string SAVE_PATH = Application.persistentDataPath + '/Data/';&#13;
&#13;
    private static BinaryDataMgr instance = new BinaryDataMgr();&#13;
    public static BinaryDataMgr Instance =&gt; instance;&#13;
&#13;
    private BinaryDataMgr()&#13;
    {&#13;
        InitData();&#13;
    }&#13;
&#13;
    public void InitData()&#13;
    {&#13;
        &#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 加载Excel表的2进制数据到内存中 &#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name='T'&gt;容器类名&lt;/typeparam&gt;&#13;
    /// &lt;typeparam name='K'&gt;数据结构类类名&lt;/typeparam&gt;&#13;
    public void LoadTable&lt;T,K&gt;()&#13;
    {&#13;
        //读取 excel表对应的2进制文件 来进行解析&#13;
        using (FileStream fs = File.Open(DATA_BINARY_PATH + typeof(K).Name + '.tang', FileMode.Open, FileAccess.Read))&#13;
        {&#13;
            byte[] bytes = new byte[fs.Length];&#13;
            fs.Read(bytes, 0, bytes.Length);&#13;
            fs.Close();&#13;
            //用于记录当前读取了多少字节了&#13;
            int index = 0;&#13;
&#13;
            //读取多少行数据&#13;
            int count = BitConverter.ToInt32(bytes, index);&#13;
            index += 4;&#13;
&#13;
            //读取主键的名字&#13;
            int keyNameLength = BitConverter.ToInt32(bytes, index);&#13;
            index += 4;&#13;
            string keyName = Encoding.UTF8.GetString(bytes, index, keyNameLength);&#13;
            index += keyNameLength;&#13;
&#13;
            //创建容器类对象&#13;
            Type contaninerType = typeof(T);&#13;
            object contaninerObj = Activator.CreateInstance(contaninerType);&#13;
            //得到数据结构类的Type&#13;
            Type classType = typeof(K);&#13;
            //通过反射 得到数据结构类 所有字段的信息&#13;
            FieldInfo[] infos = classType.GetFields();&#13;
&#13;
            //读取每一行的信息&#13;
            for (int i = 0; i &lt; count; i++)&#13;
            {&#13;
                //实例化一个数据结构类 对象&#13;
                object dataObj = Activator.CreateInstance(classType);&#13;
                foreach (FieldInfo info in infos)&#13;
                {&#13;
                    if( info.FieldType == typeof(int) )&#13;
                    {&#13;
                        //相当于就是把2进制数据转为int 然后赋值给了对应的字段&#13;
                        info.SetValue(dataObj, BitConverter.ToInt32(bytes, index));&#13;
                        index += 4;&#13;
                    }&#13;
                    else if (info.FieldType == typeof(float))&#13;
                    {&#13;
                        info.SetValue(dataObj, BitConverter.ToSingle(bytes, index));&#13;
                        index += 4;&#13;
                    }&#13;
                    else if (info.FieldType == typeof(bool))&#13;
                    {&#13;
                        info.SetValue(dataObj, BitConverter.ToBoolean(bytes, index));&#13;
                        index += 1;&#13;
                    }&#13;
                    else if (info.FieldType == typeof(string))&#13;
                    {&#13;
                        //读取字符串字节数组的长度&#13;
                        int length = BitConverter.ToInt32(bytes, index);&#13;
                        index += 4;&#13;
                        info.SetValue(dataObj, Encoding.UTF8.GetString(bytes, index, length));&#13;
                        index += length;&#13;
                    }&#13;
                }&#13;
&#13;
                //读取完一行的数据了 应该把这个数据添加到容器对象中&#13;
                //得到容器对象中的 字典对象&#13;
                object dicObject = contaninerType.GetField('dataDic').GetValue(contaninerObj);&#13;
                //通过字典对象得到其中的 Add方法&#13;
                MethodInfo mInfo = dicObject.GetType().GetMethod('Add');&#13;
                //得到数据结构类对象中 指定主键字段的值&#13;
                object keyValue = classType.GetField(keyName).GetValue(dataObj);&#13;
                mInfo.Invoke(dicObject, new object[] { keyValue, dataObj });&#13;
            }&#13;
&#13;
            //把读取完的表记录下来&#13;
            tableDic.Add(typeof(T).Name, contaninerObj);&#13;
&#13;
            fs.Close();&#13;
        }&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 得到一张表的信息&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name='T'&gt;容器类名&lt;/typeparam&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    public T GetTable&lt;T&gt;() where T:class&#13;
    {&#13;
        string tableName = typeof(T).Name;&#13;
        if (tableDic.ContainsKey(tableName))&#13;
            return tableDic[tableName] as T;&#13;
        return null;&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 存储类对象数据&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='obj'&gt;&lt;/param&gt;&#13;
    /// &lt;param name='fileName'&gt;&lt;/param&gt;&#13;
    public void Save(object obj, string fileName)&#13;
    {&#13;
        //先判断路径文件夹有没有&#13;
        if (!Directory.Exists(SAVE_PATH))&#13;
            Directory.CreateDirectory(SAVE_PATH);&#13;
&#13;
        using (FileStream fs = new FileStream(SAVE_PATH + fileName + '.tang', FileMode.OpenOrCreate, FileAccess.Write))&#13;
        {&#13;
            BinaryFormatter bf = new BinaryFormatter();&#13;
            bf.Serialize(fs, obj);&#13;
            fs.Close();&#13;
        }&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 读取2进制数据转换成对象&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name='T'&gt;&lt;/typeparam&gt;&#13;
    /// &lt;param name='fileName'&gt;&lt;/param&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    public T Load&lt;T&gt;(string fileName) where T:class&#13;
    {&#13;
        //如果不存在这个文件 就直接返回泛型对象的默认值&#13;
        if( !File.Exists(SAVE_PATH + fileName + '.tang') )&#13;
            return default(T);&#13;
&#13;
        T obj;&#13;
        using (FileStream fs = File.Open(SAVE_PATH + fileName + '.tang', FileMode.Open, FileAccess.Read))&#13;
        {&#13;
            BinaryFormatter bf = new BinaryFormatter();&#13;
            obj = bf.Deserialize(fs) as T;&#13;
            fs.Close();&#13;
        }&#13;
&#13;
        return obj;&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/BinaryDataMgr.html</guid><pubDate>Mon, 08 Jul 2024 12:19:36 +0000</pubDate></item><item><title>ExcelRead.unity读取Excel文件并配置在编辑栏</title><link>https://natsunokoide.github.io//post/ExcelRead.unity-du-qu-Excel-wen-jian-bing-pei-zhi-zai-bian-ji-lan.html</link><description>```js&#13;
using Excel;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Data;&#13;
using System.IO;&#13;
using UnityEditor;&#13;
using UnityEngine;&#13;
&#13;
public class LessonExcelRead&#13;
{&#13;
    #region 知识点一  打开Excel表&#13;
    //主要知识点：&#13;
    //1.FileStream 文件流&#13;
    //2.IExccelDataReader读取Excel数据&#13;
    //3.DataSet 数据集合类 将Excel中的数据转存进去&#13;
&#13;
    [MenuItem('GameTool/打开Excel表')]&#13;
    private static void OpenExcel()&#13;
    {&#13;
        using (FileStream fs = File.Open(Application.dataPath + '/ArtRes/Excel/PlayerInfo.xlsx',FileMode.Open,FileAccess.Read))&#13;
        {&#13;
            //利用Excel工具类中的方法读取文件流获取Excel数据&#13;
            IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);&#13;
            //将excel表中数据转换为DataSet数据类型&#13;
            DataSet result = excelReader.AsDataSet();&#13;
            for(int i = 0;i &lt; result.Tables.Count;i++)&#13;
            {&#13;
                Debug.Log('表名 ' + result.Tables[i].TableName);&#13;
                Debug.Log('行数 ' + result.Tables[i].Rows.Count);&#13;
                Debug.Log('列数 ' + result.Tables[i].Columns.Count);&#13;
            }&#13;
            fs.Close();&#13;
        }&#13;
    }&#13;
    #endregion&#13;
&#13;
    #region 知识点二 获取单元格信息&#13;
    private static void ReadExcel()&#13;
    {&#13;
        using (FileStream fs = File.Open(Application.dataPath + '/ArtRes/Excel/PlayerInfo.xlsx', FileMode.Open, FileAccess.Read))&#13;
        {&#13;
            IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);&#13;
            DataSet result = excelReader.AsDataSet();&#13;
            //取excel数据出来&#13;
            for (int i = 0; i &lt; result.Tables.Count; i++)&#13;
            {&#13;
                //得到其中一个表的具体数据&#13;
                DataTable table = result.Tables[i];&#13;
                /*//得到其中一行的数据&#13;
                DataRow row = tabel.Rows[0];&#13;
                //得到行中某一列的信息&#13;
                Debug.Log(row[1].ToString());*/&#13;
                DataRow row;&#13;
                for (int j = 0; j &lt; table.Rows.Count; j++)&#13;
                {&#13;
                    //获取到其中一行&#13;
                    row = table.Rows[j];&#13;
                    Debug.Log('**********************新的一行**************************');&#13;
                    for (int k = 0; k &lt; table.Columns.Count; k++)&#13;
                    {&#13;
                        //打印当前行的所有信息&#13;
                        Debug.Log(row[k].ToString());&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
    #endregion&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/ExcelRead.unity-du-qu-Excel-wen-jian-bing-pei-zhi-zai-bian-ji-lan.html</guid><pubDate>Tue, 02 Jul 2024 11:43:29 +0000</pubDate></item><item><title>BinaryDataMgr二进制数据管理器</title><link>https://natsunokoide.github.io//post/BinaryDataMgr-er-jin-zhi-shu-ju-guan-li-qi.html</link><description>’‘’js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.IO;&#13;
using System.Runtime.Serialization.Formatters.Binary;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 2进制数据管理器&#13;
/// &lt;/summary&gt;&#13;
public class BinaryDataMgr&#13;
{&#13;
    private static BinaryDataMgr instance = new BinaryDataMgr();&#13;
    public static BinaryDataMgr Instance =&gt; instance;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 数据存储的位置&#13;
    /// &lt;/summary&gt;&#13;
    private static string SAVE_PATH = Application.persistentDataPath + '/Data/';&#13;
&#13;
    private BinaryDataMgr()&#13;
    {&#13;
&#13;
    }&#13;
&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 存储类对象数据&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='obj'&gt;&lt;/param&gt;&#13;
    /// &lt;param name='fileName'&gt;&lt;/param&gt;&#13;
    public void Save(object obj, string fileName)&#13;
    {&#13;
        //先判断路径文件夹有没有&#13;
        if (!Directory.Exists(SAVE_PATH))&#13;
            Directory.CreateDirectory(SAVE_PATH);&#13;
&#13;
        using (FileStream fs = new FileStream(SAVE_PATH + fileName + '.tang', FileMode.OpenOrCreate, FileAccess.Write))&#13;
        {&#13;
            BinaryFormatter bf = new BinaryFormatter();&#13;
            bf.Serialize(fs, obj);&#13;
            fs.Close();&#13;
        }&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 读取2进制数据转换成对象&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name='T'&gt;&lt;/typeparam&gt;&#13;
    /// &lt;param name='fileName'&gt;&lt;/param&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    public T Load&lt;T&gt;(string fileName) where T:class&#13;
    {&#13;
        //如果不存在这个文件 就直接返回泛型对象的默认值&#13;
        if( !File.Exists(SAVE_PATH + fileName + '.tang') )&#13;
            return default(T);&#13;
&#13;
        T obj;&#13;
        using (FileStream fs = File.Open(SAVE_PATH + fileName + '.tang', FileMode.Open, FileAccess.Read))&#13;
        {&#13;
            BinaryFormatter bf = new BinaryFormatter();&#13;
            obj = bf.Deserialize(fs) as T;&#13;
            fs.Close();&#13;
        }&#13;
&#13;
        return obj;&#13;
    }&#13;
}&#13;
&#13;
'''。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/BinaryDataMgr-er-jin-zhi-shu-ju-guan-li-qi.html</guid><pubDate>Mon, 01 Jul 2024 13:43:30 +0000</pubDate></item><item><title>Addressable.AddressablesMgr管理器</title><link>https://natsunokoide.github.io//post/Addressable.AddressablesMgr-guan-li-qi.html</link><description>```js&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.AddressableAssets;&#13;
using UnityEngine.ResourceManagement.AsyncOperations;&#13;
&#13;
public class AddressablesMgr&#13;
{&#13;
    private static AddressablesMgr instance = new AddressablesMgr();&#13;
    public static AddressablesMgr Instance =&gt; instance;&#13;
&#13;
    //有一个容器 帮助我们存储 异步加载的返回值&#13;
    public Dictionary&lt;string, IEnumerator&gt; resDic = new Dictionary&lt;string, IEnumerator&gt;();&#13;
&#13;
    private AddressablesMgr() { }&#13;
&#13;
    //异步加载资源的方法&#13;
    public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;AsyncOperationHandle&lt;T&gt;&gt; callBack)&#13;
    {&#13;
        //由于存在同名 不同类型资源的区分加载&#13;
        //所以我们通过名字和类型拼接作为 key&#13;
        string keyName = name + '_' + typeof(T).Name;&#13;
        AsyncOperationHandle&lt;T&gt; handle;&#13;
        //如果已经加载过该资源&#13;
        if (resDic.ContainsKey(keyName))&#13;
        {&#13;
            //获取异步加载返回的操作内容&#13;
            handle = (AsyncOperationHandle&lt;T&gt;)resDic[keyName];&#13;
&#13;
            //判断 这个异步加载是否结束&#13;
            if(handle.IsDone)&#13;
            {&#13;
                //如果成功 就不需要异步了 直接相当于同步调用了 这个委托函数 传入对应的返回值&#13;
                callBack(handle);&#13;
            }&#13;
            //还没有加载完成&#13;
            else&#13;
            {&#13;
                //如果这个时候 还没有异步加载完成 那么我们只需要 告诉它 完成时做什么就行了&#13;
                handle.Completed += (obj) =&gt; {&#13;
                    if (obj.Status == AsyncOperationStatus.Succeeded)&#13;
                        callBack(obj);&#13;
                };&#13;
            }&#13;
            return;&#13;
        }&#13;
        &#13;
        //如果没有加载过该资源&#13;
        //直接进行异步加载 并且记录&#13;
        handle = Addressables.LoadAssetAsync&lt;T&gt;(name);&#13;
        handle.Completed += (obj)=&gt; {&#13;
            if (obj.Status == AsyncOperationStatus.Succeeded)&#13;
                callBack(obj);&#13;
            else&#13;
            {&#13;
                Debug.LogWarning(keyName + '资源加载失败');&#13;
                if(resDic.ContainsKey(keyName))&#13;
                    resDic.Remove(keyName);&#13;
            }&#13;
        };&#13;
        resDic.Add(keyName, handle);&#13;
    }&#13;
&#13;
    //释放资源的方法 &#13;
    public void Release&lt;T&gt;(string name)&#13;
    {&#13;
        //由于存在同名 不同类型资源的区分加载&#13;
        //所以我们通过名字和类型拼接作为 key&#13;
        string keyName = name + '_' + typeof(T).Name;&#13;
        if(resDic.ContainsKey(keyName))&#13;
        {&#13;
            //取出对象 移除资源 并且从字典里面移除&#13;
            AsyncOperationHandle&lt;T&gt; handle = (AsyncOperationHandle&lt;T&gt;)resDic[keyName];&#13;
            Addressables.Release(handle);&#13;
            resDic.Remove(keyName);&#13;
        }&#13;
    }&#13;
&#13;
    //异步加载多个资源 或者 加载指定资源&#13;
    public void LoadAssetAsync&lt;T&gt;(Addressables.MergeMode mode, Action&lt;T&gt; callBack, params string[] keys)&#13;
    {&#13;
        //1.构建一个keyName  之后用于存入到字典中&#13;
        List&lt;string&gt; list = new List&lt;string&gt;(keys);&#13;
        string keyName = '';&#13;
        foreach (string key in list)&#13;
            keyName += key + '_';&#13;
        keyName += typeof(T).Name;&#13;
        //2.判断是否存在已经加载过的内容 &#13;
        //存在做什么&#13;
        AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle;&#13;
        if (resDic.ContainsKey(keyName))&#13;
        {&#13;
            handle = (AsyncOperationHandle&lt;IList&lt;T&gt;&gt;)resDic[keyName];&#13;
            //异步加载是否结束&#13;
            if(handle.IsDone)&#13;
            {&#13;
                foreach (T item in handle.Result)&#13;
                    callBack(item);&#13;
            }&#13;
            else&#13;
            {&#13;
                handle.Completed += (obj) =&gt;&#13;
                {&#13;
                    //加载成功才调用外部传入的委托函数&#13;
                    if(obj.Status == AsyncOperationStatus.Succeeded)&#13;
                    {&#13;
                        foreach (T item in handle.Result)&#13;
                            callBack(item);&#13;
                    }&#13;
                };&#13;
            }&#13;
            return;&#13;
        }&#13;
        //不存在做什么&#13;
        handle = Addressables.LoadAssetsAsync&lt;T&gt;(list, callBack, mode);&#13;
        handle.Completed += (obj) =&gt;&#13;
        {&#13;
            if(obj.Status == AsyncOperationStatus.Failed)&#13;
            {&#13;
                Debug.LogError('资源加载失败' + keyName);&#13;
                if (resDic.ContainsKey(keyName))&#13;
                    resDic.Remove(keyName);&#13;
            }&#13;
        };&#13;
        resDic.Add(keyName, handle);&#13;
    }&#13;
&#13;
    public void LoadAssetAsync&lt;T&gt;(Addressables.MergeMode mode, Action&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; callBack, params string[] keys)&#13;
    {&#13;
&#13;
    }&#13;
&#13;
    public void Releas&lt;T&gt;(params string[] keys)&#13;
    {&#13;
        //1.构建一个keyName  之后用于存入到字典中&#13;
        List&lt;string&gt; list = new List&lt;string&gt;(keys);&#13;
        string keyName = '';&#13;
        foreach (string key in list)&#13;
            keyName += key + '_';&#13;
        keyName += typeof(T).Name;&#13;
        &#13;
        if(resDic.ContainsKey(keyName))&#13;
        {&#13;
            //取出字典里面的对象&#13;
            AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle = (AsyncOperationHandle&lt;IList&lt;T&gt;&gt;)resDic[keyName];&#13;
            Addressables.Release(handle);&#13;
            resDic.Remove(keyName);&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    //清空资源&#13;
    public void Clear()&#13;
    {&#13;
        resDic.Clear();&#13;
        AssetBundle.UnloadAllAssetBundles(true);&#13;
        Resources.UnloadUnusedAssets();&#13;
        GC.Collect();&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Addressable.AddressablesMgr-guan-li-qi.html</guid><pubDate>Sun, 30 Jun 2024 08:13:28 +0000</pubDate></item><item><title>GameFrame.计时器管理——计时器item</title><link>https://natsunokoide.github.io//post/GameFrame.-ji-shi-qi-guan-li-%E2%80%94%E2%80%94-ji-shi-qi-item.html</link><description>### 前提条件&#13;
该计时器item继承了缓存池管理器 并继承了 重置接口&#13;
&#13;
### TimerItem&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 计时器对象 里面存储了计时器的相关数据&#13;
/// &lt;/summary&gt;&#13;
public class TimerItem : IPoolObject&#13;
{&#13;
    /// &lt;summary&gt;&#13;
    /// 唯一ID&#13;
    /// &lt;/summary&gt;&#13;
    public int keyID;&#13;
    /// &lt;summary&gt;&#13;
    /// 计时结束后的委托回调&#13;
    /// &lt;/summary&gt;&#13;
    public UnityAction overCallBack;&#13;
    /// &lt;summary&gt;&#13;
    /// 间隔一定时间去执行的委托回调&#13;
    /// &lt;/summary&gt;&#13;
    public UnityAction callBack;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 表示计时器总的计时时间 毫秒：1s = 1000ms&#13;
    /// &lt;/summary&gt;&#13;
    public int allTime;&#13;
    /// &lt;summary&gt;&#13;
    /// 记录一开始计时时的总时间 用于时间重置&#13;
    /// &lt;/summary&gt;&#13;
    public int maxAllTime;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 间隔执行回调的时间 毫秒 毫秒：1s = 1000ms&#13;
    /// &lt;/summary&gt;&#13;
    public int intervalTime;&#13;
    /// &lt;summary&gt;&#13;
    /// 记录一开始的间隔时间&#13;
    /// &lt;/summary&gt;&#13;
    public int maxIntervalTime;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 是否在进行计时&#13;
    /// &lt;/summary&gt;&#13;
    public bool isRuning;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 初始化计时器数据&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='keyID'&gt;唯一ID&lt;/param&gt;&#13;
    /// &lt;param name='allTime'&gt;总的时间&lt;/param&gt;&#13;
    /// &lt;param name='overCallBack'&gt;总时间计时结束后的回调&lt;/param&gt;&#13;
    /// &lt;param name='intervalTime'&gt;间隔执行的时间&lt;/param&gt;&#13;
    /// &lt;param name='callBack'&gt;间隔执行时间结束后的回调&lt;/param&gt;&#13;
    public void InitInfo(int keyID, int allTime, UnityAction overCallBack, int intervalTime = 0, UnityAction callBack = null)&#13;
    {&#13;
        this.keyID = keyID;&#13;
        this.maxAllTime = this.allTime = allTime;&#13;
        this.overCallBack = overCallBack;&#13;
        this.maxIntervalTime = this.intervalTime = intervalTime;&#13;
        this.callBack = callBack;&#13;
        this.isRuning = true;&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 重置计时器&#13;
    /// &lt;/summary&gt;&#13;
    public void ResetTimer()&#13;
    {&#13;
        this.allTime = this.maxAllTime;&#13;
        this.intervalTime = this.maxIntervalTime;&#13;
        this.isRuning = true;&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 缓存池回收时  清除相关引用数据&#13;
    /// &lt;/summary&gt;&#13;
    public void ResetInfo()&#13;
    {&#13;
        overCallBack = null;&#13;
        callBack = null;&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/GameFrame.-ji-shi-qi-guan-li-%E2%80%94%E2%80%94-ji-shi-qi-item.html</guid><pubDate>Wed, 12 Jun 2024 13:44:38 +0000</pubDate></item><item><title>GameFrame.缓存池（自定义数据类数据结构）</title><link>https://natsunokoide.github.io//post/GameFrame.-huan-cun-chi-%EF%BC%88-zi-ding-yi-shu-ju-lei-shu-ju-jie-gou-%EF%BC%89.html</link><description>### 作用&#13;
在GameFrame.缓存池（对象池）的基础上 进行自定义数据类和数据结构的优化&#13;
&#13;
### 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 抽屉（池子中的数据）对象&#13;
/// &lt;/summary&gt;&#13;
public class PoolData&#13;
{&#13;
    //用来存储抽屉中的对象 记录的是没有使用的对象&#13;
    private Stack&lt;GameObject&gt; dataStack = new Stack&lt;GameObject&gt;();&#13;
&#13;
    //用来记录使用中的对象的 &#13;
    private List&lt;GameObject&gt; usedList = new List&lt;GameObject&gt;();&#13;
&#13;
    //抽屉上限 场景上同时存在的对象的上限个数&#13;
    private int maxNum;&#13;
&#13;
    //抽屉根对象 用来进行布局管理的对象&#13;
    private GameObject rootObj;&#13;
&#13;
    //获取容器中是否有对象&#13;
    public int Count =&gt; dataStack.Count;&#13;
&#13;
    public int UsedCount =&gt; usedList.Count;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 进行使用中对象数量和最大容量进行比较 小于返回true 需要实例化&#13;
    /// &lt;/summary&gt;&#13;
    public bool NeedCreate =&gt; usedList.Count &lt; maxNum;&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 初始化构造函数&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='root'&gt;柜子（缓存池）父对象&lt;/param&gt;&#13;
    /// &lt;param name='name'&gt;抽屉父对象的名字&lt;/param&gt;&#13;
    public PoolData(GameObject root, string name, GameObject usedObj)&#13;
    {&#13;
        //开启功能时 才会动态创建 建立父子关系&#13;
        if(PoolMgr.isOpenLayout)&#13;
        {&#13;
            //创建抽屉父对象&#13;
            rootObj = new GameObject(name);&#13;
            //和柜子父对象建立父子关系&#13;
            rootObj.transform.SetParent(root.transform);&#13;
        }&#13;
&#13;
        //创建抽屉时 外部肯定是会动态创建一个对象的&#13;
        //我们应该将其记录到 使用中的对象容器中&#13;
        PushUsedList(usedObj);&#13;
&#13;
        PoolObj poolObj = usedObj.GetComponent&lt;PoolObj&gt;();&#13;
        if (poolObj == null)&#13;
        {&#13;
            Debug.LogError('请为使用缓存池功能的预设体对象挂载PoolObj脚本 用于设置数量上限');&#13;
            return;&#13;
        }&#13;
        //记录上限数量值&#13;
        maxNum = poolObj.maxNum;&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 从抽屉中弹出数据对象&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;returns&gt;想要的对象数据&lt;/returns&gt;&#13;
    public GameObject Pop()&#13;
    {&#13;
        //取出对象&#13;
        GameObject obj;&#13;
&#13;
        if (Count &gt; 0)&#13;
        {&#13;
            //从没有的容器当中取出使用&#13;
            obj = dataStack.Pop();&#13;
            //现在要使用了 应该要用使用中的容器记录它&#13;
            usedList.Add(obj);&#13;
        }&#13;
        else&#13;
        {&#13;
            //取0索引的对象 代表的就是使用时间最长的对象&#13;
            obj = usedList[0];&#13;
            //并且把它从使用着的对象中移除&#13;
            usedList.RemoveAt(0);&#13;
            //由于它还要拿出去用，所以我们应该把它又记录到 使用中的容器中去 &#13;
            //并且添加到尾部 表示 比较新的开始&#13;
            usedList.Add(obj);&#13;
        }&#13;
&#13;
        //激活对象&#13;
        obj.SetActive(true);&#13;
        //断开父子关系&#13;
        if (PoolMgr.isOpenLayout)&#13;
            obj.transform.SetParent(null);&#13;
&#13;
        return obj;&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 将物体放入到抽屉对象中&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='obj'&gt;&lt;/param&gt;&#13;
    public void Push(GameObject obj)&#13;
    {&#13;
        //失活放入抽屉的对象&#13;
        obj.SetActive(false);&#13;
        //放入对应抽屉的根物体中 建立父子关系&#13;
        if (PoolMgr.isOpenLayout)&#13;
            obj.transform.SetParent(rootObj.transform);&#13;
        //通过栈记录对应的对象数据&#13;
        dataStack.Push(obj);&#13;
        //这个对象已经不再使用了 应该把它从记录容器中移除&#13;
        usedList.Remove(obj);&#13;
    }&#13;
&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 将对象压入到使用中的容器中记录&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='obj'&gt;&lt;/param&gt;&#13;
    public void PushUsedList(GameObject obj)&#13;
    {&#13;
        usedList.Add(obj);&#13;
    }&#13;
}&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 方便在字典当中用里式替换原则 存储子类对象&#13;
/// &lt;/summary&gt;&#13;
public abstract class PoolObjectBase { }&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 用于存储 数据结构类 和 逻辑类 （不继承mono的）容器类&#13;
/// &lt;/summary&gt;&#13;
/// &lt;typeparam name='T'&gt;&lt;/typeparam&gt;&#13;
public class PoolObject&lt;T&gt; : PoolObjectBase where T:class&#13;
{&#13;
    public Queue&lt;T&gt; poolObjs = new Queue&lt;T&gt;();&#13;
}&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 想要被复用的 数据结构类、逻辑类 都必须要继承该接口&#13;
/// &lt;/summary&gt;&#13;
public interface IPoolObject&#13;
{&#13;
    /// &lt;summary&gt;&#13;
    /// 重置数据的方法&#13;
    /// &lt;/summary&gt;&#13;
    void ResetInfo();&#13;
}&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 缓存池(对象池)模块 管理器&#13;
/// &lt;/summary&gt;&#13;
public class PoolMgr : BaseManager&lt;PoolMgr&gt;&#13;
{&#13;
    //柜子容器当中有抽屉的体现&#13;
    //值 其实代表的就是一个 抽屉对象&#13;
    private Dictionary&lt;string, PoolData&gt; poolDic = new Dictionary&lt;string, PoolData&gt;();&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 用于存储数据结构类、逻辑类对象的 池子的字典容器&#13;
    /// &lt;/summary&gt;&#13;
    private Dictionary&lt;string, PoolObjectBase&gt; poolObjectDic = new Dictionary&lt;string, PoolObjectBase&gt;();&#13;
&#13;
    //池子根对象&#13;
    private GameObject poolObj;&#13;
&#13;
    //是否开启布局功能&#13;
    public static bool isOpenLayout = true;&#13;
&#13;
    private PoolMgr() {&#13;
&#13;
        //如果根物体为空 就创建&#13;
        if (poolObj == null &amp;&amp; isOpenLayout)&#13;
            poolObj = new GameObject('Pool');&#13;
&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 拿东西的方法&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='name'&gt;抽屉容器的名字&lt;/param&gt;&#13;
    /// &lt;returns&gt;从缓存池中取出的对象&lt;/returns&gt;&#13;
    public GameObject GetObj(string name)&#13;
    {&#13;
        //如果根物体为空 就创建&#13;
        if (poolObj == null &amp;&amp; isOpenLayout)&#13;
            poolObj = new GameObject('Pool');&#13;
&#13;
        GameObject obj;&#13;
&#13;
        #region 加入了数量上限后的逻辑判断&#13;
        if(!poolDic.ContainsKey(name) ||&#13;
            (poolDic[name].Count == 0 &amp;&amp; poolDic[name].NeedCreate))&#13;
        {&#13;
            //动态创建对象&#13;
            //没有的时候 通过资源加载 去实例化出一个GameObject&#13;
            obj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));&#13;
            //避免实例化出来的对象 默认会在名字后面加一个(Clone)&#13;
            //我们重命名过后 方便往里面放&#13;
            obj.name = name;&#13;
&#13;
            //创建抽屉&#13;
            if(!poolDic.ContainsKey(name))&#13;
                poolDic.Add(name, new PoolData(poolObj, name, obj));&#13;
            else//实例化出来的对象 需要记录到使用中的对象容器中&#13;
                poolDic[name].PushUsedList(obj);&#13;
        }&#13;
        //当抽屉中有对象 或者 使用中的对象超上限了 直接去取出来用&#13;
        else&#13;
        {&#13;
            obj = poolDic[name].Pop();&#13;
        }&#13;
&#13;
        #endregion&#13;
&#13;
&#13;
        #region 没有加入 上限时的逻辑&#13;
        ////有抽屉 并且 抽屉里 有对象 才去直接拿&#13;
        //if (poolDic.ContainsKey(name) &amp;&amp; poolDic[name].Count &gt; 0)&#13;
        //{&#13;
        //    //弹出栈中的对象 直接返回给外部使用&#13;
        //    obj = poolDic[name].Pop();&#13;
        //}&#13;
        ////否则，就应该去创造&#13;
        //else&#13;
        //{&#13;
        //    //没有的时候 通过资源加载 去实例化出一个GameObject&#13;
        //    obj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));&#13;
        //    //避免实例化出来的对象 默认会在名字后面加一个(Clone)&#13;
        //    //我们重命名过后 方便往里面放&#13;
        //    obj.name = name;&#13;
        //}&#13;
        #endregion&#13;
        return obj;&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 获取自定义的数据结构类和逻辑类对象 （不继承Mono的）&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name='T'&gt;数据类型&lt;/typeparam&gt;&#13;
    /// &lt;returns&gt;&lt;/returns&gt;&#13;
    public T GetObj&lt;T&gt;(string nameSpace = '') where T:class,IPoolObject,new()&#13;
    {&#13;
        //池子的名字 是根据类的类型来决定的 就是它的类名&#13;
        string poolName = nameSpace + '_' + typeof(T).Name;&#13;
        //有池子&#13;
        if(poolObjectDic.ContainsKey(poolName))&#13;
        {&#13;
            PoolObject&lt;T&gt; pool = poolObjectDic[poolName] as PoolObject&lt;T&gt;;&#13;
            //池子当中是否有可以复用的内容&#13;
            if(pool.poolObjs.Count &gt; 0)&#13;
            {&#13;
                //从队列中取出对象 进行复用&#13;
                T obj = pool.poolObjs.Dequeue() as T;&#13;
                return obj;&#13;
            }&#13;
            //池子当中是空的&#13;
            else&#13;
            {&#13;
                //必须保证存在无参构造函数 where new()&#13;
                T obj = new T();&#13;
                return obj;&#13;
            }&#13;
        }&#13;
        else//没有池子&#13;
        {&#13;
            T obj = new T();&#13;
            return obj;&#13;
        }&#13;
        &#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 往缓存池中放入对象&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;param name='name'&gt;抽屉（对象）的名字&lt;/param&gt;&#13;
    /// &lt;param name='obj'&gt;希望放入的对象&lt;/param&gt;&#13;
    public void PushObj(GameObject obj)&#13;
    {&#13;
        #region 因为失活 父子关系都放入了 抽屉对象中处理 所以不需要再处理这些内容了&#13;
        ////总之，目的就是要把对象隐藏起来&#13;
        ////并不是直接移除对象 而是将对象失活 一会儿再用 用的时候再激活它&#13;
        ////除了这种方式，还可以把对象放倒屏幕外看不见的地方&#13;
        //obj.SetActive(false);&#13;
&#13;
        ////把失活的对象（要放入抽屉中的对象） 父对象先设置为 柜子（缓存池）根对象&#13;
        //obj.transform.SetParent(poolObj.transform);&#13;
        #endregion&#13;
&#13;
        //没有抽屉 创建抽屉&#13;
        //if (!poolDic.ContainsKey(obj.name))&#13;
        //    poolDic.Add(obj.name, new PoolData(poolObj, obj.name));&#13;
&#13;
        //往抽屉当中放对象&#13;
        poolDic[obj.name].Push(obj);&#13;
&#13;
        ////如果存在对应的抽屉容器 直接放&#13;
        //if(poolDic.ContainsKey(name))&#13;
        //{&#13;
        //    //往栈（抽屉）中放入对象&#13;
        //    poolDic[name].Push(obj);&#13;
        //}&#13;
        ////否则 需要先创建抽屉 再放&#13;
        //else&#13;
        //{&#13;
        //    //先创建抽屉&#13;
        //    poolDic.Add(name, new Stack&lt;GameObject&gt;());&#13;
        //    //再往抽屉里面放&#13;
        //    poolDic[name].Push(obj);&#13;
        //}&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 将自定义数据结构类和逻辑类 放入池子中&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name='T'&gt;对应类型&lt;/typeparam&gt;&#13;
    public void PushObj&lt;T&gt;(T obj, string nameSpace = '') where T:class,IPoolObject&#13;
    {&#13;
        //如果想要压入null对象 是不被允许的&#13;
        if (obj == null)&#13;
            return;&#13;
        //池子的名字 是根据类的类型来决定的 就是它的类名&#13;
        string poolName = nameSpace + '_' + typeof(T).Name;&#13;
        //有池子&#13;
        PoolObject&lt;T&gt; pool;&#13;
        if (poolObjectDic.ContainsKey(poolName))&#13;
            //取出池子 压入对象&#13;
            pool = poolObjectDic[poolName] as PoolObject&lt;T&gt;;&#13;
        else//没有池子&#13;
        {&#13;
            pool = new PoolObject&lt;T&gt;();&#13;
            poolObjectDic.Add(poolName, pool);&#13;
        }&#13;
        //在放入池子中之前 先重置对象的数据&#13;
        obj.ResetInfo();&#13;
        pool.poolObjs.Enqueue(obj);&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// 用于清除整个柜子当中的数据 &#13;
    /// 使用场景 主要是 切场景时&#13;
    /// &lt;/summary&gt;&#13;
    public void ClearPool()&#13;
    {&#13;
        poolDic.Clear();&#13;
        poolObj = null;&#13;
        poolObjectDic.Clear();&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/GameFrame.-huan-cun-chi-%EF%BC%88-zi-ding-yi-shu-ju-lei-shu-ju-jie-gou-%EF%BC%89.html</guid><pubDate>Wed, 12 Jun 2024 09:10:27 +0000</pubDate></item><item><title>GameFrame.缓存池（对象池）</title><link>https://natsunokoide.github.io//post/GameFrame.-huan-cun-chi-%EF%BC%88-dui-xiang-chi-%EF%BC%89.html</link><description>### 缓存池（对象池）&#13;
### 作用&#13;
**缓存池（对象池）的主要作用是优化资源管理，提高程序性能。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/GameFrame.-huan-cun-chi-%EF%BC%88-dui-xiang-chi-%EF%BC%89.html</guid><pubDate>Thu, 18 Apr 2024 03:59:53 +0000</pubDate></item><item><title>LeetCode2007.从双倍数组中还原数组</title><link>https://natsunokoide.github.io//post/LeetCode2007.-cong-shuang-bei-shu-zu-zhong-huan-yuan-shu-zu.html</link><description>### 题目&#13;
一个整数数组 original 可以转变成一个 双倍 数组 changed ，转变方式为将 original 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode2007.-cong-shuang-bei-shu-zu-zhong-huan-yuan-shu-zu.html</guid><pubDate>Thu, 18 Apr 2024 03:28:01 +0000</pubDate></item><item><title>GameFrame.公共Mono模块</title><link>https://natsunokoide.github.io//post/GameFrame.-gong-gong-Mono-mo-kuai.html</link><description>### 公共Mono模块&#13;
### 实现功能&#13;
 （1）实现一个单例模式的Mono模块&#13;
 （2）能使其他没有继承Mono的脚本 进行帧更行等操作&#13;
 （3）本质上是使不继承mono的脚本在公共Mono模块中添加事件&#13;
 （4）由于公共Mono模块是继承了单例模式管理类的所以自带Mono的功能所以还可以实现协程的功能（Coroutine）&#13;
          实现方法是在不继承Mono的脚本中 用公共Mono模块点出协程使用：MonoMgr.Instance.StartCoroutine(Test());&#13;
&#13;
&gt; 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 公共Mono模块管理器&#13;
/// &lt;/summary&gt;&#13;
public class MonoMgr : SingleAutoMono&lt;MonoMgr&gt;&#13;
{&#13;
    private event UnityAction updateEvent;&#13;
    private event UnityAction fixedUpdateEvent;&#13;
    private event UnityAction lateUpdateEvent;&#13;
&#13;
    //添加更新监听函数&#13;
    public void AddUpdateListener(UnityAction updateFun)&#13;
    {&#13;
        updateEvent += updateFun;&#13;
    }&#13;
    public void AddFixedUpdateListener(UnityAction updateFun)&#13;
    {&#13;
        fixedUpdateEvent += updateFun;&#13;
    }&#13;
    public void AddLateUpdateListener(UnityAction updateFun)&#13;
    {&#13;
        lateUpdateEvent += updateFun;&#13;
    }&#13;
&#13;
    //移除更新函数&#13;
    public void RemoveUpdateListener(UnityAction updateFun)&#13;
    {&#13;
        updateEvent -= updateFun;&#13;
    }&#13;
    public void RemoveFixedUpdateListener(UnityAction updateFun)&#13;
    {&#13;
        fixedUpdateEvent -= updateFun;&#13;
    }&#13;
    public void RemoveLateUpdateListener(UnityAction updateFun)&#13;
    {&#13;
        lateUpdateEvent -= updateFun;&#13;
    }&#13;
&#13;
    private void Update()&#13;
    {&#13;
        updateEvent?.Invoke();&#13;
    }&#13;
&#13;
    private void FixedUpdate()&#13;
    {&#13;
        fixedUpdateEvent?.Invoke();&#13;
    }&#13;
&#13;
    private void LateUpdate()&#13;
    {&#13;
        lateUpdateEvent?.Invoke();&#13;
    }&#13;
}&#13;
&#13;
```&#13;
&#13;
&gt; 测试脚本&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
//没有继承mono，测试利用monomgr实现无mono的子脚本更新帧&#13;
public class Test6Mgr : BaseManager&lt;Test6Mgr&gt;&#13;
{&#13;
    //定义一个协程用于协程赋值&#13;
    private Coroutine testFun;&#13;
&#13;
    public void IcanUpdate()&#13;
    {&#13;
        MonoMgr.Instance.AddUpdateListener(MyUpdate);&#13;
        testFun = MonoMgr.Instance.StartCoroutine(Test());&#13;
    }&#13;
&#13;
    public void IcanStopUpdate()&#13;
    {&#13;
        MonoMgr.Instance.RemoveUpdateListener(MyUpdate);&#13;
        MonoMgr.Instance.StopCoroutine(testFun);&#13;
    }&#13;
&#13;
    private IEnumerator Test()&#13;
    {&#13;
        yield return new WaitForSeconds(3f);&#13;
        Debug.Log('TestTeat');&#13;
    }&#13;
&#13;
    private void MyUpdate()&#13;
    {&#13;
        Debug.Log('1231312');&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&gt; main函数&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Main : MonoBehaviour&#13;
{&#13;
    private void Start()&#13;
    {&#13;
    }&#13;
&#13;
&#13;
    // Update is called once per frame&#13;
    void Update()&#13;
    {&#13;
        if (Input.GetKeyDown(KeyCode.Space))&#13;
            Test6Mgr.Instance.IcanUpdate();&#13;
&#13;
        if (Input.GetKeyUp(KeyCode.Space))&#13;
            Test6Mgr.Instance.IcanStopUpdate();&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/GameFrame.-gong-gong-Mono-mo-kuai.html</guid><pubDate>Wed, 17 Apr 2024 13:24:40 +0000</pubDate></item><item><title>GameFrame.单例模式基类</title><link>https://natsunokoide.github.io//post/GameFrame.-dan-li-mo-shi-ji-lei.html</link><description>### 单例模式基类&#13;
&#13;
### 不继承Mono的单例模式基类&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class BaseManager&lt;T&gt; where T : class,new ()&#13;
{&#13;
    private static T instance;&#13;
    public static T Instance&#13;
    {&#13;
        get&#13;
        {&#13;
            if(instance == null)&#13;
            {&#13;
                instance = new T();&#13;
            }&#13;
            return instance;&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 继承Mono的单例模式基类（挂载式）&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 挂载式 继承Mono 的单例模式基类&#13;
/// &lt;/summary&gt;&#13;
public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour&#13;
{&#13;
    private static T instance;&#13;
    public static T Instance =&gt; instance;&#13;
    protected virtual void Awake()&#13;
    {&#13;
        instance = this as T;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 继承Mono的单例模式基类（自动挂载式）&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 自动挂载 继承Mono的单例模式基类 （推荐使用）&#13;
/// &lt;/summary&gt;&#13;
/// &lt;typeparam name='T'&gt;&lt;/typeparam&gt;&#13;
public class SingleAutoMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour&#13;
{&#13;
    private static T instance;&#13;
    public static T Instance&#13;
    {&#13;
        get&#13;
        {&#13;
            if(instance == null)&#13;
            {&#13;
                //动态创建 动态挂载&#13;
                //在场景上 创建 空物体&#13;
                GameObject obj = new GameObject();&#13;
                //得到T脚本的类名 为对象改名 在编辑器中可以更加明确的看到该单例模式脚本对象&#13;
                obj.name = typeof(T).ToString();&#13;
                //动态挂载对应的单例模式脚本&#13;
                instance = obj.AddComponent&lt;T&gt;();&#13;
                //过场景的时候不移除&#13;
                GameObject.DontDestroyOnLoad(instance);&#13;
            }&#13;
            return instance;&#13;
        }&#13;
    }&#13;
&#13;
    protected virtual void Awake()&#13;
    {&#13;
        instance = this as T;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 安全性优化后的无Mono单例模式基类&#13;
```js&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Reflection;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 安全性优化后的无Mono单例模式基类&#13;
/// 1.class 前加 abstract 防止基类在其他地方被new&#13;
/// 2.利用反射的方式获取子类T中的构造函数信息，使用无参构造实例化instance&#13;
/// &lt;/summary&gt;&#13;
/// &lt;typeparam name='T'&gt;&lt;/typeparam&gt;&#13;
public abstract class BaseManagerPro&lt;T&gt; where T : class&#13;
{&#13;
    private static T instance;&#13;
    //提供给外部一个bool变量用于判断是否已经存在单例模式&#13;
    //程序员在子类里利用这个bool进行判断即可&#13;
    protected bool InstanceIsNull =&gt; instane == null;&#13;
    public static T Instance&#13;
    {&#13;
        get&#13;
        {&#13;
            if(instance == null)&#13;
            {&#13;
                //利用 反射 得到无参私有构造函数 用来对象的实例化&#13;
                Type type = typeof(T);&#13;
                ConstructorInfo info = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, Type.EmptyTypes, null);&#13;
                instance = info?.Invoke(null) as T;&#13;
                //还有一种方法也可以实现私有构造函数实例化对象&#13;
                //instance = Activator.CreateInstance(typeof(T), true) as T;&#13;
                if (info == null) Debug.LogError('没有对应的无参构造函数');&#13;
            }&#13;
            return instance;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```&#13;
&#13;
### 安全性优化后的无Mono单例模式基类 （加锁的版本）&#13;
```js&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Reflection;&#13;
using UnityEngine;&#13;
&#13;
/// &lt;summary&gt;&#13;
/// 安全性优化后的无Mono单例模式基类&#13;
/// 1.class 前加 abstract 防止基类在其他地方被new&#13;
/// 2.利用反射的方式获取子类T中的构造函数信息，使用无参构造实例化instance&#13;
/// &lt;/summary&gt;&#13;
/// &lt;typeparam name='T'&gt;&lt;/typeparam&gt;&#13;
public abstract class BaseManagerPro&lt;T&gt; where T : class&#13;
{&#13;
    private static T instance;&#13;
    //readonly：这表明一旦 lockObj 在构造函数中或者在声明时被初始化之后，就不能被修改。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/GameFrame.-dan-li-mo-shi-ji-lei.html</guid><pubDate>Tue, 16 Apr 2024 04:41:37 +0000</pubDate></item><item><title>UI.Demo.面板管理类</title><link>https://natsunokoide.github.io//post/UI.Demo.-mian-ban-guan-li-lei.html</link><description>### UI.Demo.面板管理类&#13;
&#13;
### 内容&#13;
1. 单例模式&#13;
2. 构造函数管理画布获取以及过场景不移除画布的功能&#13;
3. 显示i面板&#13;
4. 隐藏面板&#13;
5. 获取面板&#13;
&#13;
_该管理类非常重要，多思多想，难度不大_&#13;
&#13;
&gt; 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
//管理器 一般都是单例模式&#13;
public class UIManager : MonoBehaviour&#13;
{&#13;
    //继承了mono 必须要 对instance进行实例化！！！！！！！！！！！！！！！！！&#13;
    //private static UIManager instace; 这样写是错的 ！！！！！！！！！！！！！！！&#13;
    private static UIManager instance = new UIManager();&#13;
    public static UIManager Instance =&gt; instace;&#13;
&#13;
    //存储面板的容器&#13;
    private Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;();&#13;
    //得到Canvas对象&#13;
    private Transform canvasTrans;&#13;
&#13;
    //在构造函数里获取画布对象的位置信息 以及 不让画布对象被移除&#13;
    private UIManager()&#13;
    {&#13;
        //视频中的写法&#13;
        /*//得到场景上创建好的 Canvas对象&#13;
        canvasTrans = GameObject.Find('Canvas').transform;&#13;
        //让 Canvas对象 过场景 不移除 &#13;
        //我们都是通过 动态创建 和 动态删除 来显示 隐藏面板的 所以不删除它 影响不大&#13;
        GameObject.DontDestroyOnLoad(canvasTrans.gameObject);*/&#13;
&#13;
        //自己的写法&#13;
        GameObject canvasObj = GameObject.Find('Canvas');&#13;
        if (canvasObj != null) canvasTrans = canvasObj.transform;&#13;
        DontDestroyOnLoad(canvasObj);&#13;
    }&#13;
&#13;
    //显示面板&#13;
    public T ShowPanel&lt;T&gt;() where T : BasePanel&#13;
    {&#13;
        //规定 泛型T 的类型和面板名一致 （方便使用）&#13;
        string panelName = typeof(T).Name;&#13;
        //判断是否已经存在该面板 如果有 不用创建 返回外部直接使用&#13;
        if (panelDic.ContainsKey(panelName)) return panelDic[panelName] as T;&#13;
&#13;
        //显示面板的核心逻辑就是 动态创建界面预制体 并 设置 位置父对象&#13;
        GameObject panelObj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;('UI/' + panelName));&#13;
        panelObj.transform.SetParent(canvasTrans,false);&#13;
&#13;
        //获取面板预制体上的脚本&#13;
        T panel = panelObj.GetComponent&lt;T&gt;();&#13;
        //把脚本存储到对应的字典中&#13;
        panelDic.Add(panelName, panel);&#13;
&#13;
        //调用显示自己的逻辑&#13;
        panel.ShowMe();&#13;
        return panel;&#13;
    }&#13;
&#13;
    //隐藏面板&#13;
    //参数：isFade表示是否需要淡入淡出&#13;
    public void HidePanel&lt;T&gt;(bool isFade = true) where T : BasePanel&#13;
    {&#13;
        //通过规则+泛型得到面板的名字&#13;
        string panelName = typeof(T).Name;&#13;
        //判断当前 有没有该名字的面板&#13;
        if(panelDic.ContainsKey(panelName))&#13;
        {&#13;
            if(isFade)&#13;
            {&#13;
                panelDic[panelName].HideMe(() =&gt;&#13;
                {&#13;
                    //面板淡出后执行删除面板&#13;
                    GameObject.Destroy(panelDic[panelName].gameObject);&#13;
                    //删除面板的同时 在字典里把 该面板清楚&#13;
                    panelDic.Remove(panelName);&#13;
                });&#13;
            }&#13;
            else&#13;
            {&#13;
                GameObject.Destroy(panelDic[panelName].gameObject);&#13;
                panelDic.Remove(panelName);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    //获取面板&#13;
    public T GetPanel&lt;T&gt;() where T : BasePanel&#13;
    {&#13;
        //通过规则+泛型得到面板的名字&#13;
        string panelName = typeof(T).Name;&#13;
        //判断是否已经存在该面板 如果有 不用创建 返回外部直接使用&#13;
        if (panelDic.ContainsKey(panelName)) return panelDic[panelName] as T;&#13;
        //如果没有该泛型（名字）的面板 则返回空&#13;
        return null;&#13;
    }&#13;
&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.Demo.-mian-ban-guan-li-lei.html</guid><pubDate>Wed, 10 Apr 2024 04:52:23 +0000</pubDate></item><item><title>UI.Demo.面板基类</title><link>https://natsunokoide.github.io//post/UI.Demo.-mian-ban-ji-lei.html</link><description>### UI.Demo.面板基类&#13;
&#13;
### 内容&#13;
&#13;
1. 唤醒界面 触发 画布组件判断&#13;
2. 写一个初始化抽象方法给之后的界面继承&#13;
3. 写显示和关闭（淡入淡出的函数）&#13;
4. 淡出时 添加事件用于 让管理器删除界面&#13;
5. 淡入淡出的update逻辑（包括速度和alpha判断）&#13;
&#13;
&gt; 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
&#13;
public abstract class BasePanel : MonoBehaviour&#13;
{&#13;
    //画布组件——用于控制界面淡入淡出&#13;
    private CanvasGroup canvasGroup;&#13;
    //淡入淡出效果速度&#13;
    private float alphaSpeed = 10;&#13;
    //是否显示&#13;
    private bool isShow;&#13;
    //当自己淡出成功时 要执行委托函数&#13;
    private UnityAction hideCallBack;&#13;
&#13;
    protected virtual void Awake()&#13;
    {&#13;
        //获取画布组件，如果画布组件为null，代码加入组件&#13;
        canvasGroup = GetComponent&lt;CanvasGroup&gt;();&#13;
        if (canvasGroup == null) canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();&#13;
    }&#13;
&#13;
    protected virtual void Start()&#13;
    {&#13;
        Init();&#13;
    }&#13;
&#13;
    public abstract void Init();&#13;
&#13;
    public virtual void ShowMe()&#13;
    {&#13;
        isShow = true;&#13;
        canvasGroup.alpha = 0;&#13;
    }&#13;
&#13;
    public virtual void HideMe(UnityAction callBack)&#13;
    {&#13;
        isShow = false;&#13;
        canvasGroup.alpha = 1;&#13;
        //记录传入的 当淡出成功后 会执行的函数&#13;
        hideCallBack = callBack;&#13;
    }&#13;
&#13;
    // Update is called once per frame&#13;
    void Update()&#13;
    {&#13;
        //淡入效果&#13;
        if(isShow &amp;&amp; canvasGroup.alpha != 1)&#13;
        {&#13;
            canvasGroup.alpha += alphaSpeed * Time.deltaTime;&#13;
            if (canvasGroup.alpha &gt;= 1) canvasGroup.alpha = 1;&#13;
        }&#13;
        //淡出效果&#13;
        else if(!isShow)&#13;
        {&#13;
            canvasGroup.alpha -= alphaSpeed * Time.deltaTime;&#13;
            if (canvasGroup.alpha &lt;= 0)&#13;
            {&#13;
                canvasGroup.alpha = 0;&#13;
                //管理器 删除 自己&#13;
                hideCallBack?.Invoke();&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.Demo.-mian-ban-ji-lei.html</guid><pubDate>Wed, 10 Apr 2024 03:50:33 +0000</pubDate></item><item><title>JsonMgr（包含JsonUtility和LitJson两种序列化Json文件方法的管理器）</title><link>https://natsunokoide.github.io//post/JsonMgr%EF%BC%88-bao-han-JsonUtility-he-LitJson-liang-zhong-xu-lie-hua-Json-wen-jian-fang-fa-de-guan-li-qi-%EF%BC%89.html</link><description>&gt; 管理器代码&#13;
```js&#13;
using LitJson;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.IO;&#13;
using UnityEngine;&#13;
&#13;
public enum JsonType&#13;
{&#13;
    JsonUtlity,&#13;
    LitJson,&#13;
}&#13;
&#13;
/// &lt;summary&gt;&#13;
/// Json数据管理类 主要要能甘于 Json序列化存储到硬盘 和 反序列化从硬盘中读取到内存中&#13;
/// &lt;/summary&gt;&#13;
public class JsonMgr&#13;
{&#13;
    //不继承mono就new一个instance出来 如果继承就在awake函数里赋予&#13;
    private static JsonMgr instance = new JsonMgr();&#13;
    public static JsonMgr Instacne =&gt; instance;&#13;
&#13;
    private JsonMgr() { }&#13;
&#13;
    //存储Json数据 序列化&#13;
    public void SaveData(object data,string fileName,JsonType type = JsonType.LitJson)&#13;
    {&#13;
        //确定存储路径&#13;
        string path = Application.persistentDataPath + '/' + fileName + '.json';&#13;
        string jsonStr = '';&#13;
        switch (type)&#13;
        {&#13;
            case JsonType.JsonUtlity:&#13;
                jsonStr = JsonUtility.ToJson(data);&#13;
                break;&#13;
            case JsonType.LitJson:&#13;
                jsonStr = JsonMapper.ToJson(data);&#13;
                break;&#13;
        }&#13;
        //把序列化的Json字符串 存储到指定路径的文件中&#13;
        File.WriteAllText(path, jsonStr);&#13;
    }&#13;
&#13;
    //where : new() 泛型约束 ： 表示类型参数T必须具有一个公开的无参数的构造函数&#13;
    public T LoadData&lt;T&gt;(string fileName,JsonType type = JsonType.LitJson) where T : new()&#13;
    {&#13;
        //判断默认数据文件中是否有想要的数据 如果有从中获取&#13;
        string path = Application.streamingAssetsPath + '/' + fileName + '.json';&#13;
        if(!File.Exists(path)) path = Application.persistentDataPath + '/' + fileName + '.json';&#13;
        if(!File.Exists(path)) return new T(); // 因为有 where T : new() 约束，这里可以安全地创建T类型的实例&#13;
        //泛型约束是用来限制泛型类型参数可以代表的数据类型范围的。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/JsonMgr%EF%BC%88-bao-han-JsonUtility-he-LitJson-liang-zhong-xu-lie-hua-Json-wen-jian-fang-fa-de-guan-li-qi-%EF%BC%89.html</guid><pubDate>Tue, 09 Apr 2024 12:15:41 +0000</pubDate></item><item><title>ScriptableObject.利用json使scriptableobject真持久化</title><link>https://natsunokoide.github.io//post/ScriptableObject.-li-yong-json-shi-scriptableobject-zhen-chi-jiu-hua.html</link><description>### 利用json实现持久化&#13;
**通过在继承scriptableobject父类的数据脚本中，写（1）判断文件是否存在 若存在直接使用 （2）写一个保存函数 用于持久化数据 **&#13;
&#13;
### （1）判断文件是否存在 若存在直接使用&#13;
```js&#13;
    private void Awake()&#13;
    {&#13;
        //在awake函数里判断一下硬盘里是否有这个数据&#13;
        if (File.Exists(Application.persistentDataPath + '/SettingInfo.json'))&#13;
        {&#13;
            string str = File.ReadAllText(Application.persistentDataPath + '/SettingInfo.json');&#13;
            JsonUtility.FromJsonOverwrite(str, this);&#13;
        }&#13;
    }&#13;
```&#13;
&#13;
### （2）写一个保存函数 用于持久化数据 &#13;
```js&#13;
    /// &lt;summary&gt;&#13;
    /// 保存到本地持久化&#13;
    /// &lt;/summary&gt;&#13;
    public void Save()&#13;
    {&#13;
        string str = JsonUtility.ToJson(this);&#13;
        File.WriteAllText(Application.persistentDataPath + '/SettingInfo.json', str);&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/ScriptableObject.-li-yong-json-shi-scriptableobject-zhen-chi-jiu-hua.html</guid><pubDate>Tue, 09 Apr 2024 09:13:43 +0000</pubDate></item><item><title>SciptabelObject.数据文件创建</title><link>https://natsunokoide.github.io//post/SciptabelObject.-shu-ju-wen-jian-chuang-jian.html</link><description>### SciptabelObject.数据文件创建&#13;
&#13;
### 方法一 —— 特性一 —— [CreateAssetMenu(fileName = 'MyData',menuName = '我的数据',order = 0)]&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Video;&#13;
&#13;
[CreateAssetMenu(fileName = 'MyData',menuName = '我的数据',order = 0)]&#13;
public class MyData : ScriptableObject&#13;
{&#13;
    public int i;&#13;
    public float f;&#13;
    public bool b;&#13;
&#13;
    public GameObject obj;&#13;
    public Material m;&#13;
    public AudioClip audioClip;&#13;
    public VideoClip videoClip;&#13;
}&#13;
```&#13;
&#13;
### 方法二 —— 特性二 —— [MenuItem('ScriptableObject/CreateMyData')]&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEditor;&#13;
using UnityEngine;&#13;
&#13;
public class ScriptableObjectTool : MonoBehaviour&#13;
{&#13;
    [MenuItem('ScriptableObject/CreateMyData')]&#13;
    public static void CreateMyData()&#13;
    {&#13;
        //书写创建数据资源文件的代码&#13;
        MyData asset = ScriptableObject.CreateInstance&lt;MyData&gt;();&#13;
        //通过编辑器api 创建一个数据资源文件&#13;
        AssetDatabase.CreateAsset(asset, 'Assets/Resources/MyDataTest.asset');&#13;
        //保存创建的资源&#13;
        AssetDatabase.SaveAssets();&#13;
        //刷新一次界面&#13;
        AssetDatabase.Refresh();&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/SciptabelObject.-shu-ju-wen-jian-chuang-jian.html</guid><pubDate>Tue, 09 Apr 2024 07:07:22 +0000</pubDate></item><item><title>LeetCode 2009.使数组连续的最少操作数</title><link>https://natsunokoide.github.io//post/LeetCode%202009.-shi-shu-zu-lian-xu-de-zui-shao-cao-zuo-shu.html</link><description>### 题目&#13;
给你一个整数数组 nums 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202009.-shi-shu-zu-lian-xu-de-zui-shao-cao-zuo-shu.html</guid><pubDate>Tue, 09 Apr 2024 03:11:20 +0000</pubDate></item><item><title>LeetCode1379.找出克隆二叉树中的相同节点</title><link>https://natsunokoide.github.io//post/LeetCode1379.-zhao-chu-ke-long-er-cha-shu-zhong-de-xiang-tong-jie-dian.html</link><description>### 题目&#13;
 给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original 中的目标节点 target。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode1379.-zhao-chu-ke-long-er-cha-shu-zhong-de-xiang-tong-jie-dian.html</guid><pubDate>Wed, 03 Apr 2024 03:28:28 +0000</pubDate></item><item><title>UI.UGUI.RectTransformUtility中转换屏幕坐标到UI坐标系</title><link>https://natsunokoide.github.io//post/UI.UGUI.RectTransformUtility-zhong-zhuan-huan-ping-mu-zuo-biao-dao-UI-zuo-biao-xi.html</link><description>### RectTransformUtility类 用于转换ui坐标的类&#13;
### RectTransformUtility.ScreenPointToLocalPointInRectangle的使用&#13;
&#13;
&gt; 屏幕点转当前坐标点&#13;
&#13;
```js&#13;
    private Vector2 nowPos;&#13;
    public void OnDrag(PointerEventData eventData)&#13;
    {&#13;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(&#13;
            //相对父对象&#13;
            this.transform.parent as RectTransform,&#13;
            //屏幕点&#13;
            eventData.position,&#13;
            //摄像机&#13;
            eventData.enterEventCamera,&#13;
            //目标点&#13;
            out nowPos&#13;
            );&#13;
        //通过RectTransformUtility.ScreenPointToLocalPointInRectangle函数out出来的目标点&#13;
        //将目标点赋值给挂载对象即可实现坐标转换&#13;
        this.transform.localPosition = nowPos;&#13;
        //上方这种方式 用于优化下方代码 &#13;
        //this.transform.position += new Vector3(eventData.delta.x, eventData.delta.y, 0);&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.UGUI.RectTransformUtility-zhong-zhuan-huan-ping-mu-zuo-biao-dao-UI-zuo-biao-xi.html</guid><pubDate>Tue, 02 Apr 2024 07:53:59 +0000</pubDate></item><item><title>UI.UGUI.EventTrigger摇杆应用</title><link>https://natsunokoide.github.io//post/UI.UGUI.EventTrigger-yao-gan-ying-yong.html</link><description>### EventTrigger摇杆应用&#13;
**本文使用EventTrigger实现手机游戏的摇杆控制玩家移动的功能。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.UGUI.EventTrigger-yao-gan-ying-yong.html</guid><pubDate>Tue, 02 Apr 2024 07:29:55 +0000</pubDate></item><item><title>LeetCode331.验证二叉树的前序序列化</title><link>https://natsunokoide.github.io//post/LeetCode331.-yan-zheng-er-cha-shu-de-qian-xu-xu-lie-hua.html</link><description>### 题目&#13;
序列化二叉树的一种方法是使用 前序遍历 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode331.-yan-zheng-er-cha-shu-de-qian-xu-xu-lie-hua.html</guid><pubDate>Sun, 31 Mar 2024 01:43:01 +0000</pubDate></item><item><title>LeetCode 322+518  零钱兑换Ⅰ+Ⅱ </title><link>https://natsunokoide.github.io//post/LeetCode%20322%2B518%20%20-ling-qian-dui-huan-%E2%85%A0%2B%E2%85%A1%20.html</link><description>### 题目（322）&#13;
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20322%2B518%20%20-ling-qian-dui-huan-%E2%85%A0%2B%E2%85%A1%20.html</guid><pubDate>Mon, 25 Mar 2024 07:45:18 +0000</pubDate></item><item><title>LeetCode 2671.频率跟踪器</title><link>https://natsunokoide.github.io//post/LeetCode%202671.-pin-lv-gen-zong-qi.html</link><description>### 题目&#13;
请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202671.-pin-lv-gen-zong-qi.html</guid><pubDate>Thu, 21 Mar 2024 06:07:02 +0000</pubDate></item><item><title>LeetCode.303 区域和检索 - 数组不可变</title><link>https://natsunokoide.github.io//post/LeetCode.303%20-qu-yu-he-jian-suo-%20-%20-shu-zu-bu-ke-bian.html</link><description>### 题目&#13;
给定一个整数数组  nums，处理以下类型的多个查询:&#13;
计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right&#13;
实现 NumArray 类：&#13;
NumArray(int[] nums) 使用数组 nums 初始化对象&#13;
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )&#13;
&#13;
### 示例&#13;
输入：&#13;
['NumArray', 'sumRange', 'sumRange', 'sumRange']&#13;
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]&#13;
输出：&#13;
[null, 1, -1, -3]&#13;
&#13;
解释：&#13;
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);&#13;
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)&#13;
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) &#13;
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&#13;
&#13;
&gt; 代码 （前缀和秒杀）&#13;
```js&#13;
class NumArray {&#13;
public:&#13;
    vector&lt;int&gt; sums;&#13;
    NumArray(vector&lt;int&gt;&amp; nums) {&#13;
        int n = nums.size();&#13;
        sums.resize(n + 1);&#13;
        for(int i = 0;i &lt; n;i++) sums[i + 1] = sums[i] + nums[i]; &#13;
    }&#13;
    &#13;
    int sumRange(int left, int right) {&#13;
        return sums[right + 1] - sums[left];&#13;
    }&#13;
};&#13;
&#13;
/**&#13;
 * Your NumArray object will be instantiated and called as such:&#13;
 * NumArray* obj = new NumArray(nums);&#13;
 * int param_1 = obj-&gt;sumRange(left,right);&#13;
 */&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode.303%20-qu-yu-he-jian-suo-%20-%20-shu-zu-bu-ke-bian.html</guid><pubDate>Mon, 18 Mar 2024 06:39:14 +0000</pubDate></item><item><title>LeetCode 2684.矩阵中移动的最大次数</title><link>https://natsunokoide.github.io//post/LeetCode%202684.-ju-zhen-zhong-yi-dong-de-zui-da-ci-shu.html</link><description>### 题目&#13;
给你一个下标从 0 开始、大小为 m x n 的矩阵 grid ，矩阵由若干 正 整数组成。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202684.-ju-zhen-zhong-yi-dong-de-zui-da-ci-shu.html</guid><pubDate>Sat, 16 Mar 2024 08:48:03 +0000</pubDate></item><item><title>LeetCode 2312.卖木头块</title><link>https://natsunokoide.github.io//post/LeetCode%202312.-mai-mu-tou-kuai.html</link><description>### 题目&#13;
给你两个整数 m 和 n ，分别表示一块矩形木块的高和宽。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202312.-mai-mu-tou-kuai.html</guid><pubDate>Fri, 15 Mar 2024 03:51:29 +0000</pubDate></item><item><title>LeetCode 1261.在受污染的二叉树中查找元素</title><link>https://natsunokoide.github.io//post/LeetCode%201261.-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su.html</link><description>### 题目&#13;
给出一个满足下述规则的二叉树：&#13;
&#13;
1.root.val == 0&#13;
2.如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1&#13;
   如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2&#13;
4.现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%201261.-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su.html</guid><pubDate>Tue, 12 Mar 2024 05:26:09 +0000</pubDate></item><item><title>LeetCode 2575.找出字符串的可整除数组</title><link>https://natsunokoide.github.io//post/LeetCode%202575.-zhao-chu-zi-fu-chuan-de-ke-zheng-chu-shu-zu.html</link><description>### 题目&#13;
给你一个下标从 0 开始的字符串 word ，长度为 n ，由从 0 到 9 的数字组成。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202575.-zhao-chu-zi-fu-chuan-de-ke-zheng-chu-shu-zu.html</guid><pubDate>Thu, 07 Mar 2024 05:04:32 +0000</pubDate></item><item><title>LeetCode 2917.找出数组中的K-or值</title><link>https://natsunokoide.github.io//post/LeetCode%202917.-zhao-chu-shu-zu-zhong-de-K-or-zhi.html</link><description>### 题目&#13;
给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202917.-zhao-chu-shu-zu-zhong-de-K-or-zhi.html</guid><pubDate>Wed, 06 Mar 2024 06:58:31 +0000</pubDate></item><item><title>LeetCode 1976.到达目的地的方案数</title><link>https://natsunokoide.github.io//post/LeetCode%201976.-dao-da-mu-de-di-de-fang-an-shu.html</link><description>### 题目&#13;
你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%201976.-dao-da-mu-de-di-de-fang-an-shu.html</guid><pubDate>Tue, 05 Mar 2024 09:57:12 +0000</pubDate></item><item><title>LeetCode 225.用队列实现栈</title><link>https://natsunokoide.github.io//post/LeetCode%20225.-yong-dui-lie-shi-xian-zhan.html</link><description>### 题目&#13;
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20225.-yong-dui-lie-shi-xian-zhan.html</guid><pubDate>Sun, 03 Mar 2024 10:24:08 +0000</pubDate></item><item><title>LeetCode 2368.受限条件下可到达节点的数目</title><link>https://natsunokoide.github.io//post/LeetCode%202368.-shou-xian-tiao-jian-xia-ke-dao-da-jie-dian-de-shu-mu.html</link><description>### 题目&#13;
现有一棵由 n 个节点组成的无向树，节点编号从 0 到 n - 1 ，共有 n - 1 条边。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202368.-shou-xian-tiao-jian-xia-ke-dao-da-jie-dian-de-shu-mu.html</guid><pubDate>Sat, 02 Mar 2024 04:22:44 +0000</pubDate></item><item><title>LeetCode 2369.检查数组是否存在有效划分</title><link>https://natsunokoide.github.io//post/LeetCode%202369.-jian-cha-shu-zu-shi-fou-cun-zai-you-xiao-hua-fen.html</link><description>### 题目&#13;
给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202369.-jian-cha-shu-zu-shi-fou-cun-zai-you-xiao-hua-fen.html</guid><pubDate>Fri, 01 Mar 2024 04:39:59 +0000</pubDate></item><item><title>Acwing 1015.摘花生</title><link>https://natsunokoide.github.io//post/Acwing%201015.-zhai-hua-sheng.html</link><description>### 题目&#13;
Hello Kitty想摘点花生送给她喜欢的米老鼠。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%201015.-zhai-hua-sheng.html</guid><pubDate>Thu, 29 Feb 2024 05:07:46 +0000</pubDate></item><item><title>LeetCode 2673.使二叉树所有路径值相等的最小代价</title><link>https://natsunokoide.github.io//post/LeetCode%202673.-shi-er-cha-shu-suo-you-lu-jing-zhi-xiang-deng-de-zui-xiao-dai-jia.html</link><description>### 题目&#13;
给你一个整数 n 表示一棵 满二叉树 里面节点的数目，节点编号从 1 到 n 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202673.-shi-er-cha-shu-suo-you-lu-jing-zhi-xiang-deng-de-zui-xiao-dai-jia.html</guid><pubDate>Wed, 28 Feb 2024 03:57:19 +0000</pubDate></item><item><title>LeetCode 204.计数质数</title><link>https://natsunokoide.github.io//post/LeetCode%20204.-ji-shu-zhi-shu.html</link><description>### 题目&#13;
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20204.-ji-shu-zhi-shu.html</guid><pubDate>Tue, 27 Feb 2024 04:25:41 +0000</pubDate></item><item><title>LeetCode 938.二叉搜索树的范围和</title><link>https://natsunokoide.github.io//post/LeetCode%20938.-er-cha-sou-suo-shu-de-fan-wei-he.html</link><description>### 题目&#13;
给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20938.-er-cha-sou-suo-shu-de-fan-wei-he.html</guid><pubDate>Sun, 25 Feb 2024 16:27:09 +0000</pubDate></item><item><title>LeetCode  235.二叉搜索树的最近公共祖先</title><link>https://natsunokoide.github.io//post/LeetCode%20%20235.-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian.html</link><description>### 题目&#13;
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20%20235.-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian.html</guid><pubDate>Sat, 24 Feb 2024 16:52:39 +0000</pubDate></item><item><title>LeetCode 2583. 二叉树中的第K大层的和</title><link>https://natsunokoide.github.io//post/LeetCode%202583.%20-er-cha-shu-zhong-de-di-K-da-ceng-de-he.html</link><description>### 题目&#13;
给你一棵二叉树的根节点 root 和一个正整数 k 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202583.%20-er-cha-shu-zhong-de-di-K-da-ceng-de-he.html</guid><pubDate>Sat, 24 Feb 2024 10:42:06 +0000</pubDate></item><item><title>LeetCode 2476 二叉搜索树最近的节点查询</title><link>https://natsunokoide.github.io//post/LeetCode%202476%20-er-cha-sou-suo-shu-zui-jin-de-jie-dian-cha-xun.html</link><description>### 题目&#13;
给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%202476%20-er-cha-sou-suo-shu-zui-jin-de-jie-dian-cha-xun.html</guid><pubDate>Sat, 24 Feb 2024 10:35:00 +0000</pubDate></item><item><title>LeetCode 106.从中序与后序遍历序列构造二叉树</title><link>https://natsunokoide.github.io//post/LeetCode%20106.-cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu.html</link><description>### 题目&#13;
给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20106.-cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu.html</guid><pubDate>Wed, 21 Feb 2024 04:47:49 +0000</pubDate></item><item><title>LeetCode 105. 从前序与中序遍历序列构造二叉树</title><link>https://natsunokoide.github.io//post/LeetCode%20105.%20-cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu.html</link><description>### 题目&#13;
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20105.%20-cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu.html</guid><pubDate>Tue, 20 Feb 2024 05:34:48 +0000</pubDate></item><item><title>LeetCode 145.二叉树的后序遍历 + LeetCode 590.N叉树的后序遍历</title><link>https://natsunokoide.github.io//post/LeetCode%20145.-er-cha-shu-de-hou-xu-bian-li-%20%2B%20LeetCode%20590.N-cha-shu-de-hou-xu-bian-li.html</link><description>### 题目（145）&#13;
给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20145.-er-cha-shu-de-hou-xu-bian-li-%20%2B%20LeetCode%20590.N-cha-shu-de-hou-xu-bian-li.html</guid><pubDate>Mon, 19 Feb 2024 04:55:58 +0000</pubDate></item><item><title>LeetCode 144.二叉树的前序遍历 + LeetCode 589.N叉树的前序遍历</title><link>https://natsunokoide.github.io//post/LeetCode%20144.-er-cha-shu-de-qian-xu-bian-li-%20%2B%20LeetCode%20589.N-cha-shu-de-qian-xu-bian-li.html</link><description>### 题目（144）&#13;
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20144.-er-cha-shu-de-qian-xu-bian-li-%20%2B%20LeetCode%20589.N-cha-shu-de-qian-xu-bian-li.html</guid><pubDate>Sun, 18 Feb 2024 05:25:40 +0000</pubDate></item><item><title>LeetCode 429.N叉树的层序遍历</title><link>https://natsunokoide.github.io//post/LeetCode%20429.N-cha-shu-de-ceng-xu-bian-li.html</link><description>### 题目&#13;
给定一个 N 叉树，返回其节点值的层序遍历。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20429.N-cha-shu-de-ceng-xu-bian-li.html</guid><pubDate>Sat, 17 Feb 2024 08:59:25 +0000</pubDate></item><item><title>LeetCode 102.二叉树的层序遍历 + LeetCode 103.二叉树的锯齿形层序遍历</title><link>https://natsunokoide.github.io//post/LeetCode%20102.-er-cha-shu-de-ceng-xu-bian-li-%20%2B%20LeetCode%20103.-er-cha-shu-de-ju-chi-xing-ceng-xu-bian-li.html</link><description>### 题目（102）&#13;
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/LeetCode%20102.-er-cha-shu-de-ceng-xu-bian-li-%20%2B%20LeetCode%20103.-er-cha-shu-de-ju-chi-xing-ceng-xu-bian-li.html</guid><pubDate>Fri, 16 Feb 2024 06:26:54 +0000</pubDate></item><item><title>Acwing 894.拆分-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</link><description>### 题目&#13;
给定 n&#13;
 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</guid><pubDate>Mon, 12 Feb 2024 09:33:44 +0000</pubDate></item><item><title>UI.NGUI.Anchor组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Anchor-zu-jian.html</link><description>### Anchor组件&#13;
### 参数&#13;
![参数 anchor](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/62284219-2224-4053-af2e-648f06fd00a2)&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Anchor-zu-jian.html</guid><pubDate>Sun, 11 Feb 2024 05:59:11 +0000</pubDate></item><item><title>Acwing 852.spfa判断负环</title><link>https://natsunokoide.github.io//post/Acwing%20852.spfa-pan-duan-fu-huan.html</link><description>### 题目&#13;
给定一个 n个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20852.spfa-pan-duan-fu-huan.html</guid><pubDate>Sun, 11 Feb 2024 05:40:08 +0000</pubDate></item><item><title>UI.NGUI.ScrollView组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.ScrollView-zu-jian-%20.html</link><description>### ScrollView组件 &#13;
&#13;
### 作用和制作&#13;
1）ScrollView是什么&#13;
滚动视图&#13;
我们现在用于编程的VS代码窗口就是典型的滚动视图&#13;
游戏中主要用于 背包、商店、排行榜等等功能&#13;
2）制作ScrollView&#13;
1.直接工具栏创建即可 NGUI——Create——ScrollView&#13;
2.若需要ScrollBar 自行添加水平和竖直&#13;
&#13;
&gt; 第三点非常重要 如果不添加脚本和碰撞器 会拖不动&#13;
&#13;
3.添加子对象 为子对象添加Drag Scroll View和碰撞器&#13;
&#13;
### 参数&#13;
![参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/d6218278-b9fc-4b5d-9ce8-af018df870bd)&#13;
![参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/b323daee-18d1-458b-b398-80fa84903770)&#13;
![参数3](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/1eba1c22-06de-4837-be6b-87e0fb3b223d)&#13;
&#13;
### 设置30格背包格子（自己定义位置信息+更新滚动条的api）&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class BagPanel : MonoBehaviour&#13;
{&#13;
    private static BagPanel instance;&#13;
    public static BagPanel Instance =&gt; instance;&#13;
&#13;
    private void Awake()&#13;
    {&#13;
        instance = this;&#13;
    }&#13;
&#13;
    public UIScrollView sv;&#13;
    public UIButton btnClose;&#13;
&#13;
    private void Start()&#13;
    {&#13;
        //按下关闭按钮 隐藏界面&#13;
        btnClose.onClick.Add(new EventDelegate(() =&gt;&#13;
        {&#13;
            this.gameObject.SetActive(false);&#13;
        }));&#13;
&#13;
        //动态创建30格背包格子&#13;
        for (int i = 0; i &lt; 60; i++)&#13;
        {&#13;
            GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;('Item'));&#13;
            obj.transform.SetParent(sv.transform, false);&#13;
            //通过自己的代码逻辑设置框的位置&#13;
            // % + / 非常经典的一维转二维位置&#13;
            obj.transform.localPosition = new Vector3(120 * (i % 5), 120 * (i / 5), 0);&#13;
        }&#13;
&#13;
        //通过sv控制 滚动条更新&#13;
        sv.UpdateScrollbars();&#13;
&#13;
        this.gameObject.SetActive(false);&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.ScrollView-zu-jian-%20.html</guid><pubDate>Fri, 09 Feb 2024 06:03:58 +0000</pubDate></item><item><title>Acwing 851.spfa求最短路</title><link>https://natsunokoide.github.io//post/Acwing%20851.spfa-qiu-zui-duan-lu.html</link><description>### 题目&#13;
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20851.spfa-qiu-zui-duan-lu.html</guid><pubDate>Thu, 08 Feb 2024 16:24:29 +0000</pubDate></item><item><title>UI.NGUI.ScrollBar和ProgressBar组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.ScrollBar-he-ProgressBar-zu-jian.html</link><description>### ScrollBar和ProgressBar组件&#13;
### 作用&#13;
1.ScrollBar滚动条一般不单独使用 都是配合滚动视图使用 类似VS右侧的滚动条&#13;
2.ProgressBar进度条 一般不咋使用   一般直接用Sprite的Filed填充模式即可&#13;
&#13;
### 制作&#13;
1）制作Scrollbar&#13;
1.两个Sprite 1个背景 1个滚动条&#13;
2.背景父对象添加脚本&#13;
3.添加碰撞器&#13;
4.关联对象&#13;
&#13;
1）制作ProgressBar&#13;
1.两个Sprite 1个背景 1个进度条&#13;
2.背景父对象添加脚本&#13;
3.关联对象&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.ScrollBar-he-ProgressBar-zu-jian.html</guid><pubDate>Thu, 08 Feb 2024 11:33:55 +0000</pubDate></item><item><title>UI.NGUI.Slider组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Slider-zu-jian.html</link><description>### Slider组件&#13;
&#13;
### 参数&#13;
![参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/ccd56038-cc70-4eac-a9c5-93d91e27ab80)&#13;
&#13;
&#13;
&gt; 注意Slider与之前学习组件不同多了一个委托函数slider.onDragFinished可以直接+=lamda表达式！！！！！！！！！！！！！！！！！！！！&#13;
&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson10 : MonoBehaviour&#13;
{&#13;
    public UISlider slider;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 Slider是啥&#13;
        //滑动条控件&#13;
        //主要用于设置音乐音效大小等&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Slider&#13;
        //1.3个sprite 1个做根对象为背景  2个子对象 1个进度 1个滑动块 &#13;
        //2.设置层级&#13;
        //3.为根背景添加Slider脚本&#13;
        //4.添加碰撞器（父对象或者滑块）&#13;
        //5.关联3个对象&#13;
        #endregion&#13;
&#13;
        #region 知识点 监听事件的两种方式&#13;
        //1.拖曳脚本关联&#13;
        //2.通过代码关联&#13;
        slider.onChange.Add(new EventDelegate(() =&gt; {&#13;
&#13;
            print('通过代码监听' + slider.value);&#13;
        }));&#13;
&#13;
        slider.onDragFinished += () =&gt; {&#13;
            print('拖曳结束' + slider.value);&#13;
        };&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void OnChange()&#13;
    {&#13;
        print('值变化' + slider.value);&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Slider-zu-jian.html</guid><pubDate>Wed, 07 Feb 2024 14:45:22 +0000</pubDate></item><item><title>UI.NGUI.PopupList组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.PopupList-zu-jian-%20.html</link><description>### PopupList组件 &#13;
&#13;
### 参数&#13;
![参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/5f1e4f50-e74b-40c0-ad2b-0a6a976590f2)&#13;
![参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/c377a1f7-da85-458c-b0db-39d57a150217)&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson9 : MonoBehaviour&#13;
{&#13;
    public UIPopupList list;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 PopupList是啥？&#13;
        //下拉列表 &#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Popuplist&#13;
        //1.一个sprite做背景 一个lable做显示内容&#13;
        //2.添加PopupList脚本&#13;
        //3.添加碰撞器&#13;
        //4.关联lable做信息更新，选择Label中的SetCurrentSelection函数&#13;
        #endregion&#13;
&#13;
        #region 知识点 添加新选项 + 监听事件的两种方式&#13;
        //1.拖曳代码&#13;
        //2.代码关联&#13;
        list.items.Add('新加 选项4');&#13;
&#13;
        list.onChange.Add(new EventDelegate(() =&gt; {&#13;
&#13;
            print('代码添加的监听' + list.value);&#13;
        }));&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void OnChange()&#13;
    {&#13;
        print('选项变化' + list.value);&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.PopupList-zu-jian-%20.html</guid><pubDate>Wed, 07 Feb 2024 12:52:19 +0000</pubDate></item><item><title>UI.NGUI.Input组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.Input-zu-jian-%20.html</link><description>### Input组件 &#13;
&#13;
### 参数&#13;
![input参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/531345f0-7ac1-4ebf-9c3f-6cde944796de)&#13;
![input参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/e52ef3c0-5b14-45a2-9a6f-c7f1eee0ea3a)&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson8 : MonoBehaviour&#13;
{&#13;
    public UIInput input;&#13;
&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 Input是啥&#13;
        //输入框&#13;
        //可以用来制作账号密码聊天输入框&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Input&#13;
        //1.1个Sprite做背景 1个Label显示文字&#13;
        //2.为Sprint添加Input脚本&#13;
        //3.添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点 监听事件的两种方式&#13;
        //1.拖曳脚本&#13;
        //2.通过代码关联&#13;
&#13;
        input.onSubmit.Add(new EventDelegate(() =&gt;&#13;
        {&#13;
            print('完成输入 通关代码添加的监听函数');&#13;
        }));&#13;
&#13;
        input.onChange.Add(new EventDelegate(() =&gt;&#13;
        {&#13;
            print('输入变化 通关代码添加的监听函数');&#13;
        }));&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void OnSubmit()&#13;
    {&#13;
        print('输入完成' + input.value);&#13;
    }&#13;
&#13;
    public void OnChange()&#13;
    {&#13;
        print('输入变化' + input.value);&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Input-zu-jian-%20.html</guid><pubDate>Wed, 07 Feb 2024 06:52:38 +0000</pubDate></item><item><title>Acwing 845.八数码（华容道最小步数）</title><link>https://natsunokoide.github.io//post/Acwing%20845.-ba-shu-ma-%EF%BC%88-hua-rong-dao-zui-xiao-bu-shu-%EF%BC%89.html</link><description>### 题目&#13;
在一个 3×3的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3的网格中。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20845.-ba-shu-ma-%EF%BC%88-hua-rong-dao-zui-xiao-bu-shu-%EF%BC%89.html</guid><pubDate>Wed, 07 Feb 2024 06:18:21 +0000</pubDate></item><item><title>UI.NGUI.Toggle单选多选组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Toggle-dan-xuan-duo-xuan-zu-jian.html</link><description>### Toggle单选多选组件&#13;
&#13;
### 参数&#13;
![toggle参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/5b2f6a06-f73d-4446-b978-3a9db45445a5)&#13;
&#13;
### 代码与解析&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson7 : MonoBehaviour&#13;
{&#13;
    public UIToggle tog1;&#13;
    public UIToggle tog2;&#13;
    public UIToggle tog3;&#13;
&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 Toggle用来干啥&#13;
        //单选框 多选框都可以使用它来制作&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Toggle&#13;
        //1.2个Sprite 1父1子&#13;
        //2.为父对象添加Toggle脚本&#13;
        //3.添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点四 监听事件的两种方式&#13;
        //1.拖代码（button类似）&#13;
        //2.代码进行监听添加&#13;
        tog1.onChange.Add(new EventDelegate(Change2));&#13;
        tog2.onChange.Add(new EventDelegate(Change2));&#13;
        tog3.onChange.Add(new EventDelegate(Change2));&#13;
        #endregion&#13;
    }&#13;
&#13;
    private void Change2()&#13;
    {&#13;
        print('代码监听');&#13;
    }&#13;
&#13;
    //可以将toggle设置为同一级 这样就可以实现if~else if的单选判断&#13;
    public void Change()&#13;
    {&#13;
        print('Toggle变化执行的内容');&#13;
&#13;
        if (tog1.value)&#13;
        {&#13;
            print('tog1选中');&#13;
        }&#13;
        else if (tog2.value)&#13;
        {&#13;
            print('tog2选中');&#13;
        }&#13;
        else if (tog3.value)&#13;
        {&#13;
            print('tog3选中');&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Toggle-dan-xuan-duo-xuan-zu-jian.html</guid><pubDate>Tue, 06 Feb 2024 13:54:36 +0000</pubDate></item><item><title>UI.NGUI.Button按钮组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Button-an-niu-zu-jian.html</link><description>### Button按钮组件&#13;
&#13;
### 参数&#13;
![按钮参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/9882d3df-1237-497e-a8d2-ae6b9af0ae9c)&#13;
&#13;
### 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson6 : MonoBehaviour&#13;
{&#13;
    public UIButton btn;&#13;
&#13;
    void Start()&#13;
    {&#13;
        #region 知识点 所有组合控件的共同特点&#13;
        //1.在3个基础组件对象上添加对应组件&#13;
        //2.如果希望响应点击等事件 需要添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点 Button是用来干嘛的&#13;
        //UI界面中的按钮 当点击按钮后我们可以进行一些处理&#13;
        #endregion&#13;
&#13;
        #region 知识点 制作Button&#13;
        //1.一个Sprite（需要文字再加一个Label子对象）&#13;
        //2.为Sprite添加Button脚本&#13;
        //3.添加碰撞器&#13;
        #endregion&#13;
&#13;
        #region 知识点 监听事件的两种方式&#13;
        //1.拖脚本&#13;
        //直接在unity编辑器中进行 把脚本托给Ngui对象然后在编辑器里面选&#13;
        //2.代码获取按钮对象监听&#13;
        btn.onClick.Add(new EventDelegate(ClickDo2));&#13;
&#13;
        btn.onClick.Add(new EventDelegate(() =&gt; {&#13;
            print('那么大表达式添加的 点击事件处理');&#13;
        }));&#13;
        #endregion&#13;
    }&#13;
&#13;
    public void ClickDoSomthing()&#13;
    {&#13;
        print('按钮点击');&#13;
    }&#13;
&#13;
    public void ClickDo2()&#13;
    {&#13;
        print('按钮点击2');&#13;
    }&#13;
&#13;
    #region 总结&#13;
    //1.button的制作流程&#13;
    //  3个基础组件构成 任意一个基础组件 往上面添加Button脚本 再添加碰撞器 就可以让它变成一个按钮&#13;
    //2.事件的监听&#13;
    // 通过 拖曳 或者 代码的形式 可以进行按钮的 点击事件 监听&#13;
    #endregion&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Button-an-niu-zu-jian.html</guid><pubDate>Tue, 06 Feb 2024 07:20:53 +0000</pubDate></item><item><title>Acwing 240.食物链</title><link>https://natsunokoide.github.io//post/Acwing%20240.-shi-wu-lian.html</link><description>### 题目&#13;
动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20240.-shi-wu-lian.html</guid><pubDate>Tue, 06 Feb 2024 06:48:52 +0000</pubDate></item><item><title>UI.NGUI.Texture控件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.Texture-kong-jian-%20.html</link><description>### Texture控件 &#13;
&#13;
### 基本参数&#13;
![texture控件](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/bcda5c29-4928-4824-85a1-af5cddbfb27a)&#13;
&#13;
### 代码&#13;
```js&#13;
    public UITexture tex;&#13;
    void Start()&#13;
    {&#13;
        #region Texture用来干啥&#13;
        //Sprite只能显示图集中图片 一般用于显示中小图片&#13;
        //如果使用大尺寸图片 没有必要打图集&#13;
        //直接使用Texture组件进行大图片显示&#13;
        #endregion&#13;
&#13;
        #region  代码设置&#13;
        //加载图片 &#13;
        Texture texture = Resources.Load&lt;Texture&gt;('BK');&#13;
        //改变图片&#13;
        if (texture != null)&#13;
            tex.mainTexture = texture;&#13;
        #endregion&#13;
    }&#13;
```&#13;
&#13;
### 细节&#13;
创建texture 将图片放入需要查看图片的原始分辨率并进行调整&#13;
若为背景大图 需要对UIRoot组件进行 修改 保证 大图的清晰与准确。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Texture-kong-jian-%20.html</guid><pubDate>Mon, 05 Feb 2024 14:24:03 +0000</pubDate></item><item><title>UI.NGUI.Lable控件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Lable-kong-jian.html</link><description>### Lable控件&#13;
&#13;
### 基础参数&#13;
![lable参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/01edb567-8c90-4fb7-a9d5-a415bcd72758)&#13;
![lable参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/3b92ad46-8f64-40c1-8f0a-69fa4fe82a19)&#13;
&#13;
### 富文本内容&#13;
![富文本](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/2abe1dbf-53a3-4fa9-83ae-577555be69b0)&#13;
&#13;
### 代码相关&#13;
1.创建： public UILable lable；&#13;
2.得到内容： lable.text = ' xxxx '；。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Lable-kong-jian.html</guid><pubDate>Mon, 05 Feb 2024 14:08:22 +0000</pubDate></item><item><title>UI.NGUI.Sprite控件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Sprite-kong-jian.html</link><description>### Sprite控件&#13;
&#13;
### 作用&#13;
NGUI中所有中小尺寸图片显示都用Sprite显示，使用它来显示图集中的单个图片资源&#13;
&#13;
### 参数&#13;
![sprite参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/b745b945-4b7f-4daf-8980-d8f7e0f94b07)&#13;
![sprite参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/b0e6998e-9c62-4420-bee0-f2fc941de96e)&#13;
![sprite参数3](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/146cb5b7-786b-4c0e-812e-93347c226da0)&#13;
&#13;
### 代码相关内容&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson3 : MonoBehaviour&#13;
{&#13;
    //定义精灵图&#13;
    public UISprite sprite;&#13;
    void Start()&#13;
    {&#13;
        //设置长宽&#13;
        sprite.width = 200;&#13;
        sprite.height = 300;&#13;
&#13;
        //改变为当前图集中选择的图片&#13;
        sprite.spriteName = 'bk';&#13;
&#13;
        //2.改变为其它图集中的图片&#13;
        //先加载图集&#13;
        //图集在 NGUIAtlas 类中 使用Resources直接加载&#13;
        NGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;('Atlas/login');&#13;
        sprite.atlas = atlas;&#13;
        //再设置图片&#13;
        sprite.spriteName = 'ui_DL_anniuxiao_01';&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Sprite-kong-jian.html</guid><pubDate>Mon, 05 Feb 2024 13:46:16 +0000</pubDate></item><item><title>UI.NGUI.图集</title><link>https://natsunokoide.github.io//post/UI.NGUI.-tu-ji.html</link><description>### 图集&#13;
&#13;
### 定义&#13;
 NGUI中的最小图片控件Sprite要使用图集中的图片进行显示&#13;
图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集&#13;
目的：提高渲染性能&#13;
&#13;
### 打开图集编辑器&#13;
方法一：Project右键打开&#13;
方法二：上方工具栏NGUI——Open——Atlas Maker&#13;
&#13;
### 图集文件内容&#13;
1.图集文件&#13;
2.图集材质&#13;
3.图集图片&#13;
&#13;
### 图集工具参数&#13;
![图集工具参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/19129d99-3fb8-4c01-a0b2-be1e0dbe01b1)&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.-tu-ji.html</guid><pubDate>Sun, 04 Feb 2024 13:35:47 +0000</pubDate></item><item><title>UI.NGUI.EventSystem组件 </title><link>https://natsunokoide.github.io//post/UI.NGUI.EventSystem-zu-jian-%20.html</link><description>### EventSystem控件 &#13;
![EventSystem参数1](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/859b8eca-d747-473d-bc55-807fc3ac5608)&#13;
![EventSystem参数2](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/ff0e2ea5-d8b9-4455-95b6-60f4357296f7)&#13;
&#13;
### 总结&#13;
1.如果没有EventSystem，没有办法监听玩家输入&#13;
2.创建UI时的 2DUI 和3DUI 主要就是摄像机的模式不一样&#13;
EventSystem的2D和3D主要是 采用2D碰撞器 还是3D碰撞器 不能直接改变摄像机模式。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.EventSystem-zu-jian-%20.html</guid><pubDate>Sun, 04 Feb 2024 09:19:21 +0000</pubDate></item><item><title>UI.NGUI.Panel组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Panel-zu-jian.html</link><description>### Panel控件参数&#13;
![panel重要参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/a6c67231-ec59-4f4f-82f9-73cbd2682191)&#13;
![panel次要参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/e53f032f-4957-4995-b905-0f631d3516fb)&#13;
&#13;
### 总结&#13;
1.没有Panel父对象 UI控件看不到&#13;
2.Panel一般用于管理面板 控制层级&#13;
3.Panel可以有多个 一般一个Panel管理一个面板&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Panel-zu-jian.html</guid><pubDate>Sun, 04 Feb 2024 08:19:59 +0000</pubDate></item><item><title>UI.NGUI.Root组件</title><link>https://natsunokoide.github.io//post/UI.NGUI.Root-zu-jian.html</link><description>![root控件参数](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/2b6b910f-977c-48d2-8170-43b7b68e8f16)&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/UI.NGUI.Root-zu-jian.html</guid><pubDate>Sun, 04 Feb 2024 07:42:17 +0000</pubDate></item><item><title>Acwing 143.最大异或对</title><link>https://natsunokoide.github.io//post/Acwing%20143.-zui-da-yi-huo-dui.html</link><description>### 题目&#13;
在给定的 N个整数 A1，A2……AN中选出两个进行 xor（异或）运算，得到的结果最大是多少？&#13;
&#13;
### 输入格式&#13;
第一行输入一个整数 N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20143.-zui-da-yi-huo-dui.html</guid><pubDate>Sun, 04 Feb 2024 06:36:30 +0000</pubDate></item><item><title>Acwing 831. KMP字符串</title><link>https://natsunokoide.github.io//post/Acwing%20831.%20KMP-zi-fu-chuan.html</link><description>###  题目&#13;
### KMP字符串 经典问题&#13;
给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20831.%20KMP-zi-fu-chuan.html</guid><pubDate>Sat, 03 Feb 2024 13:06:11 +0000</pubDate></item><item><title>数据持久化.XmlDataMgr</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XmlDataMgr.html</link><description>### xml管理脚本&#13;
&#13;
&gt; 使用这个管理脚本若要序列化字典数据类型需要自己写一个继承IXmlSerializer接口的Dictionnary&#13;
&#13;
```js&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.IO;&#13;
using System.Xml.Serialization;&#13;
using UnityEngine;&#13;
&#13;
public class XmlDataMgr &#13;
{&#13;
    private static XmlDataMgr instance = new XmlDataMgr();&#13;
    public static XmlDataMgr Instance =&gt; instance;&#13;
    private XmlDataMgr() { }&#13;
&#13;
    public void SaveData(object data,string fileName)&#13;
    {&#13;
        //得到路径&#13;
        string path = Application.persistentDataPath + '/' + fileName + '.xml';&#13;
        //存储文件&#13;
        using (StreamWriter writer = new StreamWriter(path))&#13;
        {&#13;
            //序列化&#13;
            XmlSerializer s = new XmlSerializer(data.GetType());&#13;
            s.Serialize(writer, data);&#13;
        }&#13;
    }&#13;
&#13;
    public object LoadData(Type type,string fileName)&#13;
    {&#13;
        //判断文件是否存在&#13;
        string path = Application.persistentDataPath + '/' + fileName + '.xml';&#13;
        //存在就读取&#13;
        if(!File.Exists(path))&#13;
        {&#13;
            path = Application.streamingAssetsPath + '/' + fileName + '.xml';&#13;
            if(!File.Exists(path))&#13;
            {&#13;
                //如果两个路径都没有文件 那么new一个type类型对象返回给外部 都是默认值&#13;
                return Activator.CreateInstance(type);&#13;
            }&#13;
        }&#13;
        using (StreamReader reader = new StreamReader(path))&#13;
        {&#13;
            //反序列化&#13;
            XmlSerializer s = new XmlSerializer(type);&#13;
            return s.Deserialize(reader);&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XmlDataMgr.html</guid><pubDate>Fri, 02 Feb 2024 06:55:39 +0000</pubDate></item><item><title>Acwing 3302.表达式求值</title><link>https://natsunokoide.github.io//post/Acwing%203302.-biao-da-shi-qiu-zhi.html</link><description>### 题目&#13;
给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%203302.-biao-da-shi-qiu-zhi.html</guid><pubDate>Fri, 02 Feb 2024 06:04:28 +0000</pubDate></item><item><title>Acwing 125.耍杂技的牛</title><link>https://natsunokoide.github.io//post/Acwing%20125.-shua-za-ji-de-niu.html</link><description>### 题目&#13;
农民约翰的 N 头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20125.-shua-za-ji-de-niu.html</guid><pubDate>Thu, 01 Feb 2024 13:37:55 +0000</pubDate></item><item><title>数据持久化.XML的序列化反序列化</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-de-xu-lie-hua-fan-xu-lie-hua.html</link><description>### 1.序列化&#13;
定义： 把对象转化为可传输的字节序列过程称为序列化。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-de-xu-lie-hua-fan-xu-lie-hua.html</guid><pubDate>Tue, 30 Jan 2024 07:53:30 +0000</pubDate></item><item><title>Acwing 104.货仓选址</title><link>https://natsunokoide.github.io//post/Acwing%20104.-huo-cang-xuan-zhi.html</link><description>### 题目&#13;
在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20104.-huo-cang-xuan-zhi.html</guid><pubDate>Tue, 30 Jan 2024 06:54:17 +0000</pubDate></item><item><title>Acwing 913.排队打水</title><link>https://natsunokoide.github.io//post/Acwing%20913.-pai-dui-da-shui.html</link><description>### 题目&#13;
有 n个人排队到 1个水龙头处打水，第 i个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？&#13;
&#13;
### 输入格式&#13;
第一行包含整数 n。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20913.-pai-dui-da-shui.html</guid><pubDate>Tue, 30 Jan 2024 06:28:21 +0000</pubDate></item><item><title>Acwing 148.合并果子</title><link>https://natsunokoide.github.io//post/Acwing%20148.-he-bing-guo-zi.html</link><description>### 题目&#13;
在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20148.-he-bing-guo-zi.html</guid><pubDate>Mon, 29 Jan 2024 13:37:22 +0000</pubDate></item><item><title>Acwing 907.区间覆盖</title><link>https://natsunokoide.github.io//post/Acwing%20907.-qu-jian-fu-gai.html</link><description>### 题目&#13;
给定 N个闭区间 [ai,bi]以及一个线段区间 [s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20907.-qu-jian-fu-gai.html</guid><pubDate>Sun, 28 Jan 2024 13:40:43 +0000</pubDate></item><item><title>数据持久化.XML文件存储</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-cun-chu.html</link><description>### XML文件存储&#13;
&#13;
### 存储位置分析&#13;
&#13;
1. 存储xml文件 在Unity中一定是使用各平台都可读可写可找到的路径&#13;
2. Resources 可读 不可写 打包后找不到  （×）&#13;
3. Application.streamingAssetsPath 可读 PC端可写 iosmac不可写 找得到  （×）&#13;
4. Application.dataPath 打包后找不到（×）&#13;
5. Application.persistentDataPath 可读可写找得到 （√）&#13;
&#13;
### 存储xml文件&#13;
**XmlDocument 需要引入头文件using System.Xml;**&#13;
&gt; 代码&#13;
```js&#13;
//关键类 XmlDocument 用于创建节点 存储文件&#13;
//关键类 XmlDeclaration 用于添加版本信息&#13;
//关键类 XmlElement 节点类&#13;
&#13;
        //存储有5步&#13;
        //1.创建文本对象&#13;
        XmlDocument xml = new XmlDocument();&#13;
&#13;
        //2.添加固定版本信息&#13;
        //这一句代码 相当于就是创建&lt;?xml version='1.0' encoding='UTF-8'?&gt;这句内容&#13;
        XmlDeclaration xmlDec = xml.CreateXmlDeclaration('1.0', 'UTF-8', '');&#13;
        //创建完成过后 要添加进入 文本对象中&#13;
        xml.AppendChild(xmlDec);&#13;
&#13;
        //3.添加根节点&#13;
        XmlElement root = xml.CreateElement('Root');&#13;
        xml.AppendChild(root);&#13;
&#13;
        //4.为根节点添加子节点&#13;
        //加了一个 name子节点&#13;
        XmlElement name = xml.CreateElement('name');&#13;
        name.InnerText = '唐老狮';&#13;
        root.AppendChild(name);&#13;
&#13;
        XmlElement atk = xml.CreateElement('atk');&#13;
        atk.InnerText = '10';&#13;
        root.AppendChild(atk);&#13;
&#13;
        XmlElement listInt = xml.CreateElement('listInt');&#13;
        for (int i = 1; i &lt;= 3; i++)&#13;
        {&#13;
            XmlElement childNode = xml.CreateElement('int');&#13;
            childNode.InnerText = i.ToString();&#13;
            listInt.AppendChild(childNode);&#13;
        }&#13;
        root.AppendChild(listInt);&#13;
&#13;
        XmlElement itemList = xml.CreateElement('itemList');&#13;
        for (int i = 1; i &lt;= 3; i++)&#13;
        {&#13;
            XmlElement childNode = xml.CreateElement('Item');&#13;
            //添加属性&#13;
            childNode.SetAttribute('id', i.ToString());&#13;
            childNode.SetAttribute('num', (i * 10).ToString());&#13;
            itemList.AppendChild(childNode);&#13;
        }&#13;
        root.AppendChild(itemList);&#13;
&#13;
        //5.保存&#13;
        xml.Save(path);&#13;
```&#13;
&#13;
&gt; 上述代码得到的xml文件&#13;
&#13;
```js&#13;
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&#13;
&lt;Root&gt;&#13;
  &lt;name&gt;ADd7&lt;/name&gt;&#13;
  &lt;atk&gt;10&lt;/atk&gt;&gt;&#13;
  &lt;listInt&gt;&#13;
    &lt;int&gt;1&lt;/int&gt;&#13;
    &lt;int&gt;2&lt;/int&gt;&#13;
    &lt;int&gt;3&lt;/int&gt;&#13;
  &lt;/listInt&gt;&#13;
  &lt;itemList&gt;&#13;
    &lt;Item id='1' num='10' /&gt;&#13;
    &lt;Item id='2' num='20' /&gt;&#13;
    &lt;Item id='3' num='30' /&gt;&#13;
  &lt;/itemList&gt;&#13;
&lt;/Root&gt;&#13;
```&#13;
&#13;
### 文件的修改（添加/移除）&#13;
**判断文件是否存在 这个功能是在using System.IO中的**&#13;
&gt; 代码&#13;
```js&#13;
        //1.先判断是否存在文件&#13;
        if (File.Exists(path))&#13;
        {&#13;
            //2.加载后 直接添加节点 移除节点即可&#13;
            XmlDocument newXml = new XmlDocument();&#13;
            newXml.Load(path);&#13;
&#13;
            //修改就是在原有文件基础上 去移除 或者添加&#13;
            //移除&#13;
            //XmlNode node = newXml.SelectSingleNode('Root').SelectSingleNode('atk');&#13;
            //这种是一种简便写法 通过/来区分父子关系&#13;
            node = newXml.SelectSingleNode('Root/atk');&#13;
            //得到自己的父节点&#13;
            XmlNode root2 = newXml.SelectSingleNode('Root');&#13;
            //移除子节点方法&#13;
            root2.RemoveChild(node);&#13;
&#13;
            //添加节点&#13;
            XmlElement speed = newXml.CreateElement('moveSpeed');&#13;
            speed.InnerText = '20';&#13;
            root2.AppendChild(speed);&#13;
&#13;
            //改了记得存&#13;
            newXml.Save(path);&#13;
        }&#13;
```&#13;
&#13;
&gt; 上述代码得到的修改后xml文件&#13;
```js&#13;
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&#13;
&lt;Root&gt;&#13;
  &lt;name&gt;ADd7&lt;/name&gt;&#13;
  &lt;listInt&gt;&#13;
    &lt;int&gt;1&lt;/int&gt;&#13;
    &lt;int&gt;2&lt;/int&gt;&#13;
    &lt;int&gt;3&lt;/int&gt;&#13;
  &lt;/listInt&gt;&#13;
  &lt;itemList&gt;&#13;
    &lt;Item id='1' num='10' /&gt;&#13;
    &lt;Item id='2' num='20' /&gt;&#13;
    &lt;Item id='3' num='30' /&gt;&#13;
  &lt;/itemList&gt;&#13;
  &lt;speed&gt;2&lt;/speed&gt;&#13;
&lt;/Root&gt;&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-cun-chu.html</guid><pubDate>Sat, 27 Jan 2024 06:31:53 +0000</pubDate></item><item><title>Acwing 906.区间分组</title><link>https://natsunokoide.github.io//post/Acwing%20906.-qu-jian-fen-zu.html</link><description>### 题目 &#13;
给定 N个闭区间 [ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20906.-qu-jian-fen-zu.html</guid><pubDate>Fri, 26 Jan 2024 16:30:41 +0000</pubDate></item><item><title>数据持久化.XML文件读取</title><link>https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-du-qu.html</link><description>### XML文件读取&#13;
**总结**&#13;
**1.读取XML文件**&#13;
XmlDocument xml = new XmlDocument();&#13;
读取文本方式1-xml.LoadXml(传入xml文本字符串)&#13;
读取文本方式2-xml.Load(传入路径)&#13;
&#13;
**2.读取元素和属性**&#13;
获取单个节点 : XmlNode node = xml.SelectSingleNode(节点名)&#13;
获取多个节点 : XmlNodeList nodeList = xml.SelectNodes(节点名)&#13;
&#13;
获取节点元素内容：node.InnerText&#13;
获取节点元素属性：&#13;
1.item.Attributes['属性名'].Value&#13;
2.item.Attributes.GetNamedItem('属性名').Value&#13;
&#13;
通过迭代器遍历或者循环遍历XmlNodeList对象 可以获取到各单个元素节点&#13;
&#13;
&gt; 代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Xml;&#13;
using UnityEngine;&#13;
&#13;
public class LoadXml : MonoBehaviour&#13;
{&#13;
    void Start()&#13;
    {&#13;
        //1.使用Resources提取出的资源，得到xml的text并进行加载&#13;
        XmlDocument xml = new XmlDocument();&#13;
        TextAsset asset = Resources.Load&lt;TextAsset&gt;('TestXml');&#13;
        //print(asset.text);&#13;
        //loadxml 直接翻译字符串为xml&#13;
        xml.LoadXml(asset.text);&#13;
        //2.直接通过xml的路径加载&#13;
        //xml.Load(Application.streamingAssetsPath + '/TestXml.xml');&#13;
&#13;
&#13;
        //节点信息类&#13;
        //XmlNode 单个节点信息&#13;
        //XmlNodeList 多个节点信息类&#13;
        XmlNode root = xml.SelectSingleNode('Root');&#13;
        //通过根节点找子节点&#13;
        XmlNode nodeName = root.SelectSingleNode('name');&#13;
        //得到个子节点通过 InnerText读取里面的内容&#13;
        print(nodeName.InnerText);&#13;
        XmlNode nodeAge = root.SelectSingleNode('age');&#13;
        print(nodeAge.InnerText);&#13;
&#13;
        XmlNode nodeItem = root.SelectSingleNode('Item');&#13;
        //得到带属性的节点内容&#13;
        //第一种&#13;
        print(nodeItem.Attributes['id'].Value);&#13;
        print(nodeItem.Attributes['num'].Value);&#13;
        //第二种（了解）&#13;
        print(nodeItem.Attributes.GetNamedItem('id').Value);&#13;
&#13;
        //获取一个节点下 所有同名节点的方式&#13;
        XmlNodeList friendList = root.SelectNodes('Friend');&#13;
        //遍历方式1：迭代器遍历&#13;
        foreach (XmlNode item in friendList)&#13;
        {&#13;
            print(item.SelectSingleNode('id').Value);&#13;
            print(item.SelectSingleNode('name').Value);&#13;
        }&#13;
&#13;
        //遍历方式2：for循环&#13;
        for (int i = 0; i &lt; friendList.Count; i++)&#13;
        {&#13;
            print(friendList[i].SelectSingleNode('id').Value);&#13;
            print(friendList[i].SelectSingleNode('name').Value);&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```&#13;
### 在playerInfo类中写一个加载xml数据的LoadData（）函数&#13;
### 用于解析一个xml文件并将内容赋予到一个新的playerInfo上去&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Xml;&#13;
using UnityEngine;&#13;
&#13;
public class Item&#13;
{&#13;
    public int id;&#13;
    public int num;&#13;
}&#13;
&#13;
public class playerInfo&#13;
{&#13;
    public string name;&#13;
    public int atk;&#13;
    public int def;&#13;
    public float moveSpeed;&#13;
    public float roundSpeed;&#13;
    public Item weapon;&#13;
    public List&lt;int&gt; listInt;&#13;
    public List&lt;Item&gt; itemList;&#13;
    public Dictionary&lt;int, Item&gt; itemDic;&#13;
&#13;
    public void LoadData(string fileName)&#13;
    {&#13;
        //加载XML文件信息&#13;
        XmlDocument xml = new XmlDocument();&#13;
        //加载&#13;
        xml.Load(Application.streamingAssetsPath + '/' + fileName + '.xml');&#13;
&#13;
        //从文件中加载出具体的数据&#13;
        //加载根节点 才能加载后面的内容&#13;
        XmlNode playerInfo = xml.SelectSingleNode('PlayerInfo');&#13;
        //通过根节点 去加载具体的信息&#13;
        //不是属性的化用 InnerText 属性的化用Attributes&#13;
        this.name = playerInfo.SelectSingleNode('name').InnerText;&#13;
        this.atk = int.Parse(playerInfo.SelectSingleNode('atk').InnerText);&#13;
        this.def = int.Parse(playerInfo.SelectSingleNode('def').InnerText);&#13;
        this.moveSpeed = float.Parse(playerInfo.SelectSingleNode('moveSpeed').InnerText);&#13;
        this.roundSpeed = float.Parse(playerInfo.SelectSingleNode('roundSpeed').InnerText);&#13;
&#13;
        XmlNode weaponNode = playerInfo.SelectSingleNode('weapon');&#13;
        //实例化不能忘记&#13;
        this.weapon = new Item();&#13;
        this.weapon.id = int.Parse(weaponNode.SelectSingleNode('id').InnerText);&#13;
        this.weapon.num = int.Parse(weaponNode.SelectSingleNode('num').InnerText);&#13;
&#13;
        XmlNode listIntNode = playerInfo.SelectSingleNode('listInt');&#13;
        XmlNodeList intList = listIntNode.SelectNodes('int');&#13;
        this.listInt = new List&lt;int&gt;();&#13;
        for (int i = 0; i &lt; intList.Count; i++)&#13;
        {&#13;
            this.listInt.Add(int.Parse(intList[i].InnerText));&#13;
        }&#13;
&#13;
        XmlNode itemList = playerInfo.SelectSingleNode('itemList');&#13;
        XmlNodeList items = itemList.SelectNodes('Item');&#13;
        this.itemList = new List&lt;Item&gt;();&#13;
        //对单一类别的节点 用 foreach和for都可以&#13;
        foreach (XmlNode item in items)&#13;
        {&#13;
            Item item2 = new Item();&#13;
            item2.id = int.Parse(item.Attributes['id'].Value);&#13;
            item2.num = int.Parse(item.Attributes['num'].Value);&#13;
            this.itemList.Add(item2);&#13;
        }&#13;
&#13;
        XmlNode itemDic = playerInfo.SelectSingleNode('itemDic');&#13;
        XmlNodeList keyInt = itemDic.SelectNodes('int');&#13;
        XmlNodeList valueItem = itemDic.SelectNodes('Item');&#13;
&#13;
        this.itemDic = new Dictionary&lt;int, Item&gt;();&#13;
        for (int i = 0; i &lt; keyInt.Count; i++)&#13;
        {&#13;
            int key = int.Parse(keyInt[i].InnerText);&#13;
            Item item1 = new Item();&#13;
            item1.id = int.Parse(valueItem[i].Attributes['id'].Value);&#13;
            item1.num = int.Parse(valueItem[i].Attributes['num'].Value);&#13;
            this.itemDic.Add(key, item1);&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
### 测试&#13;
```js&#13;
    void Start()&#13;
    {&#13;
        playerInfo p = new playerInfo();&#13;
        p.LoadData('PlayerInfo');&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/shu-ju-chi-jiu-hua-.XML-wen-jian-du-qu.html</guid><pubDate>Thu, 25 Jan 2024 07:24:48 +0000</pubDate></item><item><title>Acwing.905 区间选点+AcWing 908. 最大不相交区间数量</title><link>https://natsunokoide.github.io//post/Acwing.905%20-qu-jian-xuan-dian-%2BAcWing%20908.%20-zui-da-bu-xiang-jiao-qu-jian-shu-liang.html</link><description>### 908与905的代码完全一样 思路相似不做额外篇幅&#13;
### 题目&#13;
给定 N个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing.905%20-qu-jian-xuan-dian-%2BAcWing%20908.%20-zui-da-bu-xiang-jiao-qu-jian-shu-liang.html</guid><pubDate>Thu, 25 Jan 2024 03:33:34 +0000</pubDate></item><item><title>Unity.射线检测（fps游戏相关）</title><link>https://natsunokoide.github.io//post/Unity.-she-xian-jian-ce-%EF%BC%88fps-you-xi-xiang-guan-%EF%BC%89.html</link><description>### 射线检测&#13;
&#13;
&gt; 重点内容是 ： 物体信息类 RaycastHit 以及RaycastHit[]数组&#13;
&#13;
&gt; 数组有特殊的api :RaycastAll 用法与 Raycast类似&#13;
&#13;
&gt; 特殊api：RaycastNonAlloc 返回的是碰撞器的数量&#13;
&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson23 : MonoBehaviour&#13;
{&#13;
    void Start()&#13;
    {&#13;
        #region 知识点一 什么是射线检测&#13;
        //物理系统中 &#13;
        //目前我们学习的物体相交判断&#13;
        //1.碰撞检测——必备条件 1刚体2碰撞器&#13;
        //2.范围检测——必备条件 碰撞器&#13;
&#13;
        //如果想要做这样的碰撞检测呢？&#13;
        //1.鼠标选择场景上一物体&#13;
        //2.FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）&#13;
        //等等 需要判断一条线和物体的碰撞情况&#13;
&#13;
        //射线检测 就是来解决这些问题的&#13;
        //它可以在指定点发射一个指定方向的射线&#13;
        //判断该射线与哪些碰撞器相交，得到对应对象&#13;
        #endregion&#13;
&#13;
        #region 知识点二 射线对象&#13;
        //1.3D世界中的射线&#13;
        //假设有一条&#13;
        //起点为坐标(1,0,0)&#13;
        //方向为世界坐标Z轴正方向的射线&#13;
        //注意：&#13;
        //理解参数含义&#13;
        //参数一：起点&#13;
        //参数二：方向（一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量）&#13;
&#13;
        //目前只是申明了一个射线对象 对于我们来说 没有任何的用处&#13;
        Ray r = new Ray(Vector3.right, Vector3.forward);&#13;
&#13;
        //Ray中的参数&#13;
        print(r.origin);//起点,参数1&#13;
        print(r.direction);//方向，参数2&#13;
&#13;
        //2.摄像机发射出的射线&#13;
        // 得到一条从屏幕位置作为起点&#13;
        // 摄像机视口方向为 方向的射线&#13;
        //很重要的API&#13;
        Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);&#13;
&#13;
&#13;
        //注意：&#13;
        //单独的射线对于我们来说没有实际的意义&#13;
        //我们需要用它结合物理系统进行射线碰撞判断&#13;
        #endregion&#13;
&#13;
        #region 知识点三 碰撞检测函数&#13;
        //Physics类中提供了很多进行射线检测的静态函数&#13;
        //注意：&#13;
        //射线检测是瞬时的&#13;
        //执行代码时进行一次射线检测&#13;
&#13;
        //1.最原始的射线检测&#13;
        // 准备一条射线&#13;
        Ray r3 = new Ray(Vector3.zero, Vector3.forward);&#13;
        // 进行射线检测 如果碰撞到对象 返回true&#13;
        //参数一：射线&#13;
        //参数二: 检测的最大距离 超出这个距离不检测&#13;
        //参数三：检测指定层级（不填检测所有层）&#13;
        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：bool 当碰撞到对象时 返回 true 没有 返回false&#13;
&#13;
        if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
            print('碰撞到了对象');&#13;
        }&#13;
&#13;
        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断&#13;
        //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向&#13;
        if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
            print('碰撞到了对象2');&#13;
        }&#13;
&#13;
        //2.获取相交的单个物体信息&#13;
        //物体信息类 RaycastHit&#13;
        RaycastHit hitInfo;&#13;
        //参数一：射线&#13;
        //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中&#13;
        //参数三：距离&#13;
        //参数四：检测指定层级（不填检测所有层）&#13;
        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        if (Physics.Raycast(r3, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
            print('碰撞到了物体 得到了信息');&#13;
&#13;
            //碰撞器信息&#13;
            print('碰撞到物体的名字' + hitInfo.collider.gameObject.name);&#13;
            //碰撞到的点&#13;
            print(hitInfo.point);&#13;
            //法线信息&#13;
            print(hitInfo.normal);&#13;
&#13;
            //得到碰撞到对象的位置&#13;
            print(hitInfo.transform.position);&#13;
&#13;
            //得到碰撞到对象 离自己的距离&#13;
            print(hitInfo.distance);&#13;
&#13;
            //RaycastHit 该类 对于我们的意义&#13;
            //它不仅可以得到我们碰撞到的对象信息&#13;
            //还可以得到一些 碰撞的点 距离 法线等等的信息&#13;
        }&#13;
&#13;
        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断&#13;
        if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal))&#13;
        {&#13;
&#13;
        }&#13;
&#13;
        //3.获取相交的多个物体&#13;
        //可以得到碰撞到的多个对象&#13;
        //如果没有 就是容量为0的数组&#13;
        //参数一：射线&#13;
        //参数二：距离&#13;
        //参数三：检测指定层级（不填检测所有层）&#13;
        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal);&#13;
        for (int i = 0; i &lt; hits.Length; i++)&#13;
        {&#13;
            print('碰到的所有物体 名字分别是' + hits[i].collider.gameObject.name);&#13;
        }&#13;
&#13;
        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断&#13;
        //之前的参数一射线 通过两个点传入&#13;
        hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal);&#13;
&#13;
        //还有一种函数 返回的碰撞的数量 通过out得到数据&#13;
        if (Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster'), QueryTriggerInteraction.UseGlobal) &gt; 0)&#13;
        {&#13;
&#13;
        }&#13;
        #endregion&#13;
        #region 知识点四 使用时注意的问题&#13;
        //注意：&#13;
        //距离、层级两个参数 都是int类型&#13;
        //当我们传入参数时 一定要明确传入的参数代表的是距离还是层级&#13;
&#13;
        //以下 这样写是错误的 因为第二个参数 代表的是距离 不应该是层级 但这个在ide里面是不会报错的&#13;
        if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer('Monster')))&#13;
        {&#13;
        }&#13;
        #endregion&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 实现鼠标点击场景上的一面墙 点击位置创建子弹特效和弹孔&#13;
_子弹特效和弹孔 已经放入到Resources文件夹_&#13;
```js&#13;
//实现鼠标点击场景上的一面墙 点击位置创建子弹特效和弹孔&#13;
        if (Input.GetMouseButtonDown(0))&#13;
        {&#13;
            if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),&#13;
                               out info,&#13;
                               1000,&#13;
                               1 &lt;&lt; LayerMask.NameToLayer('Monster')))&#13;
            {&#13;
                //碰撞到的点和法线向量&#13;
                //创建打击特效（特效是一个gameobject）&#13;
                GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;('Effect/HitEff'));&#13;
                obj.transform.position = info.point + info.normal * 0.3f;&#13;
                //让特效朝向屏幕&#13;
                //让物体看向法向量  这个法向量是垂直于面的向量 &#13;
                obj.transform.rotation = Quaternion.LookRotation(info.normal);&#13;
                Destroy(obj, 0.8f);&#13;
                //创建弹孔&#13;
                GameObject obj1 = Instantiate(Resources.Load&lt;GameObject&gt;('Effect/DDD'));&#13;
                obj1.transform.position = info.point + info.normal * 0.3f;&#13;
                //让特效朝向屏幕 //让物体看向法向量  这个法向量是垂直于面的向量 &#13;
                obj1.transform.rotation = Quaternion.LookRotation(info.normal);&#13;
            }&#13;
        }&#13;
```&#13;
&#13;
### 点击立方体 常按可以拖动在平面上移动点击右键取消选中&#13;
```js&#13;
if (Input.GetMouseButtonDown(0))&#13;
        {&#13;
            if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),out info,1000,1 &lt;&lt; LayerMask.NameToLayer('Player')))&#13;
            {&#13;
                nowSelObj = info.transform;&#13;
            }&#13;
        }&#13;
        //注意此处 GetMouseButton(0) 和上方鼠标选定 GetMouseButtonDown(0)的区别 前者是常按 后者是 按一下&#13;
        if (Input.GetMouseButton(0) &amp;&amp; nowSelObj != null)&#13;
        {&#13;
            if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),out info,1000, 1 &lt;&lt; LayerMask.NameToLayer('Floor')))&#13;
            {&#13;
                nowSelObj.position = info.point + Vector3.up * offSetY;&#13;
            }&#13;
        }&#13;
&#13;
        &#13;
        if(Input.GetMouseButtonDown(1))&#13;
        {&#13;
            nowSelObj = null;  &#13;
        }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-she-xian-jian-ce-%EF%BC%88fps-you-xi-xiang-guan-%EF%BC%89.html</guid><pubDate>Wed, 24 Jan 2024 14:38:57 +0000</pubDate></item><item><title>Acwing 901.滑雪</title><link>https://natsunokoide.github.io//post/Acwing%20901.-hua-xue.html</link><description>### 题目&#13;
给定一个 R行 C列的矩阵，表示一个矩形网格滑雪场。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20901.-hua-xue.html</guid><pubDate>Wed, 24 Jan 2024 12:50:58 +0000</pubDate></item><item><title>Acwing 285.没有上司的舞会</title><link>https://natsunokoide.github.io//post/Acwing%20285.-mei-you-shang-si-de-wu-hui.html</link><description>### 题目&#13;
Ural 大学有 N名职员，编号为 1∼N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20285.-mei-you-shang-si-de-wu-hui.html</guid><pubDate>Wed, 24 Jan 2024 11:34:56 +0000</pubDate></item><item><title>Unity.物理系统_范围检测</title><link>https://natsunokoide.github.io//post/Unity.-wu-li-xi-tong-_-fan-wei-jian-ce.html</link><description>### 物理系统_范围检测&#13;
&#13;
&gt; 代码总结&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
//重要知识点：&#13;
//关于层级&#13;
//通过名字得到层级编号 LayerMask.NameToLayer&#13;
//我们需要通过编号左移构建二进制数&#13;
//这样每一个编号的层级 都是 对应位为1的2进制数&#13;
//我们通过 位运算 可以选择想要检测层级&#13;
//好处 一个int 就可以表示所有想要检测的层级信息&#13;
&#13;
//层级编号是 0~31 刚好32位&#13;
//是一个int数&#13;
//每一个编号 代表的 都是二进制的一位&#13;
//0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1&#13;
//1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2&#13;
//2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4&#13;
//3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8&#13;
//4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16&#13;
//5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32&#13;
&#13;
public class Lesson22 : MonoBehaviour&#13;
{&#13;
    void Start()&#13;
    {&#13;
        #region 知识点一 什么是范围检测&#13;
        //游戏中瞬时的攻击范围判断一般会使用范围检测&#13;
        //简而言之在指定位置 进行 范围判断 我们可以得到处于指定范围内的 对象 目的是对 对象进行处理比如 受伤 减血等等&#13;
        #endregion&#13;
&#13;
        #region 知识点二 如何进行范围检测&#13;
        //必备条件：想要被范围检测到的对象 必须具备碰撞器&#13;
        //注意点：&#13;
        //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的&#13;
        //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已&#13;
&#13;
        //范围检测API&#13;
        //1.盒状范围检测&#13;
        //参数一：立方体中心点&#13;
        //参数二：立方体三边大小&#13;
        //参数三：立方体角度&#13;
        //参数四：检测指定层级（不填检测所有层）&#13;
        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）&#13;
        print(LayerMask.NameToLayer('UI'));&#13;
        Collider[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up),&#13;
                            1 &lt;&lt; LayerMask.NameToLayer('UI') |&#13;
                            1 &lt;&lt; LayerMask.NameToLayer('Default'), QueryTriggerInteraction.UseGlobal);&#13;
        for (int i = 0; i &lt; colliders.Length; i++)&#13;
        {&#13;
            print(colliders[i].gameObject.name);&#13;
        }&#13;
        //另一个API &#13;
        //返回值：碰撞到的碰撞器数量&#13;
        //参数：传入一个数组进行存储&#13;
        //Physics.OverlapBoxNonAlloc()&#13;
        if (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) { };&#13;
&#13;
        //2.球形范围检测&#13;
        //参数一：中心点&#13;
        //参数二：球半径&#13;
        //参数三：检测指定层级（不填检测所有层）&#13;
        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）&#13;
        colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer('Default'));&#13;
&#13;
        //另一个API &#13;
        //返回值：碰撞到的碰撞器数量&#13;
        //参数：传入一个数组进行存储&#13;
        //Physics.OverlapSphereNonAlloc&#13;
        if (Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0) { };&#13;
&#13;
        //3.胶囊范围检测&#13;
        //参数一：半圆一中心点&#13;
        //参数二：半圆二中心点&#13;
        //参数三：半圆半径&#13;
        //参数四：检测指定层级（不填检测所有层）&#13;
        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal&#13;
        //返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）&#13;
        colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer('UI'), QueryTriggerInteraction.UseGlobal);&#13;
&#13;
        //另一个API &#13;
        //返回值：碰撞到的碰撞器数量&#13;
        //参数：传入一个数组进行存储&#13;
        //Physics.OverlapCapsuleNonAlloc&#13;
        if (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders) != 0) { };&#13;
        #endregion&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 写一个cube wasd移动转向+jkl检测物体&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson22_exercises : MonoBehaviour&#13;
{&#13;
    public float moveSpeed = 10;&#13;
    public float roundSpeed = 20;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        &#13;
    }&#13;
&#13;
    // Update is called once per frame&#13;
    void Update()&#13;
    {&#13;
        //Input.GetAxis('Horizontal'); //控制左右&#13;
        //Input.GetAxis('vertical'); //控制前后&#13;
        //位移&#13;
        this.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis('Vertical'));&#13;
        //旋转&#13;
        this.transform.Rotate(Vector3.up, Input.GetAxis('Horizontal') * roundSpeed * Time.deltaTime);&#13;
&#13;
        if(Input.GetKeyDown(KeyCode.J))&#13;
        {&#13;
            //Vector3.one 创建的是长宽高的一半&#13;
            //Quaternion.identity 单位四元数 用于占位 本质是0，0，0&#13;
            //this.transform.rotation作为第三个参数这样可以让碰撞体和物体一起转动&#13;
            Collider[] colliders = Physics.OverlapBox(this.transform.position + this.transform.forward, Vector3.one * 0.5f,&#13;
                                                      this.transform.rotation,1 &lt;&lt; LayerMask.NameToLayer('Monster'));&#13;
            for (int i = 0; i &lt; colliders.Length; i++)&#13;
            {&#13;
                print('物体受伤' + colliders[i].name);&#13;
            }&#13;
        }&#13;
        else if(Input.GetKeyDown(KeyCode.K))&#13;
        {&#13;
            Collider[] colliders = Physics.OverlapCapsule(this.transform.position,this.transform.position + this.transform.forward * 5,&#13;
                                                          0.5f,1 &lt;&lt; LayerMask.NameToLayer('Monster'));&#13;
            for (int i = 0; i &lt; colliders.Length; i++)&#13;
            {&#13;
                print('物体受伤' + colliders[i].name);&#13;
            }&#13;
        }&#13;
        else if (Input.GetKeyDown(KeyCode.L))&#13;
        {&#13;
            Collider[] colliders = Physics.OverlapSphere(this.transform.position,10,1 &lt;&lt; LayerMask.NameToLayer('Monster'));&#13;
            for (int i = 0; i &lt; colliders.Length; i++)&#13;
            {&#13;
                print('物体受伤' + colliders[i].name);&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-wu-li-xi-tong-_-fan-wei-jian-ce.html</guid><pubDate>Tue, 23 Jan 2024 13:46:07 +0000</pubDate></item><item><title>Unity.代码实现LineRender画圆以及常按画线</title><link>https://natsunokoide.github.io//post/Unity.-dai-ma-shi-xian-LineRender-hua-yuan-yi-ji-chang-an-hua-xian.html</link><description>### LineRender画圆函数&#13;
```js&#13;
public void DrawLineRenderer(Vector3 centerPos, float r, int pointNum)&#13;
    {&#13;
        //动态创建 画线对象&#13;
        GameObject obj = new GameObject();&#13;
        obj.name = 'R';&#13;
        LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();&#13;
        line.loop = false;&#13;
        //设置有多少个点&#13;
        line.positionCount = pointNum;&#13;
        //让其首尾相连&#13;
        line.loop = true;&#13;
&#13;
        //得到每个点之间 间隔的度数&#13;
        float angle = 360f / pointNum;&#13;
&#13;
        //准备得到每一个点&#13;
        for (int i = 0; i &lt; pointNum; i++)&#13;
        {&#13;
            //知识点&#13;
            //1.点加向量 相当于平移点&#13;
            //2.四元数 * 向量 相当于在 旋转向量&#13;
            line.SetPosition(i, centerPos + Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r);&#13;
        }&#13;
    }&#13;
```&#13;
### 常按画线&#13;
```js&#13;
    private LineRenderer line2;&#13;
    private Vector3 nowPos;&#13;
    void Update()&#13;
    {&#13;
        //这样写可以画多条线而不是一直连续 ，鼠标每抬起一次就会创建一条新的linerenderer&#13;
        if (Input.GetMouseButtonDown(0))&#13;
        {&#13;
            GameObject obj = new GameObject();&#13;
            line2 = obj.AddComponent&lt;LineRenderer&gt;();&#13;
            line2.loop = false;&#13;
            line2.startWidth = 0.5f;&#13;
            line2.endWidth = 0.5f;&#13;
&#13;
            line2.positionCount = 0;&#13;
        }&#13;
        //使得用户可以长按鼠标画linerenderer线&#13;
        if (Input.GetMouseButton(0))&#13;
        {&#13;
            line2.positionCount += 1;&#13;
            //如何得到鼠标转世界坐标的 对应点 &#13;
            //知识点&#13;
&#13;
            //1.如何得到鼠标位置&#13;
            //Input.mousePosition&#13;
            //2.怎么把鼠标 屏幕坐标转世界坐标&#13;
            //Camera.main.ScreenToWorldPoint(Input.mousePosition);&#13;
&#13;
            nowPos = Input.mousePosition;&#13;
            //需要把位置往前方推一点 才能让摄像机看到&#13;
            nowPos.z = 10; //修改z非常关键不然相机会记录不到&#13;
            line2.SetPosition(line2.positionCount - 1, Camera.main.ScreenToWorldPoint(nowPos)); //Camera.main.ScreenToWorldPoint非常关键——屏幕坐标转世界坐标操作&#13;
        }&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-dai-ma-shi-xian-LineRender-hua-yuan-yi-ji-chang-an-hua-xian.html</guid><pubDate>Tue, 23 Jan 2024 13:39:36 +0000</pubDate></item><item><title>Acwing 91.最短Hamilton路径</title><link>https://natsunokoide.github.io//post/Acwing%2091.-zui-duan-Hamilton-lu-jing.html</link><description>### 题目&#13;
给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1的最短 Hamilton 路径。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%2091.-zui-duan-Hamilton-lu-jing.html</guid><pubDate>Tue, 23 Jan 2024 08:06:36 +0000</pubDate></item><item><title>Unity.LineRenderer类</title><link>https://natsunokoide.github.io//post/Unity.LineRenderer-lei.html</link><description>### LineRenderer类&#13;
&#13;
&gt; 相关介绍以及常用API说明&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson21 : MonoBehaviour&#13;
{&#13;
    private Material m;&#13;
    void Start()&#13;
    {&#13;
        #region LineRenderer是什么&#13;
        //LineRenderer是Unity提供的一个用于画线的组件&#13;
        //使用它我们可以在场景中绘制线段&#13;
        //一般可以用于&#13;
        //1绘制攻击范围&#13;
        //2武器红外线&#13;
        //3辅助功能&#13;
        //4其它画线功能&#13;
        #endregion&#13;
&#13;
        #region LineRender代码相关  如果忘记了api在lineRenderer类里面自己找&#13;
        //动态添加一个线段，空物体&#13;
        GameObject line = new GameObject();&#13;
        //把空物体对象改名为Line&#13;
        line.name = 'Line';&#13;
        //代码挂载LineRenderer&#13;
        LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;();&#13;
&#13;
        //首尾相连&#13;
        lineRenderer.loop = true;&#13;
&#13;
        //开始结束宽&#13;
        lineRenderer.startWidth = 0.02f;&#13;
        lineRenderer.endWidth = 0.02f;&#13;
&#13;
        //开始结束颜色&#13;
        lineRenderer.startColor = Color.white;&#13;
        lineRenderer.endColor = Color.red;&#13;
&#13;
        //设置材质&#13;
        //使用Resources同步加载&#13;
        m = Resources.Load&lt;Material&gt;('M');&#13;
        lineRenderer.material = m;&#13;
&#13;
        //设置点&#13;
        //一定注意 设置点 要 先设置点的个数&#13;
        lineRenderer.positionCount = 4;&#13;
        //接着就设置 对应每个点的位置&#13;
        //如果设置的点少于positionCount的个数 unity会用0，0，0点填充&#13;
        lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0),&#13;
                                                  new Vector3(0,0,5),&#13;
                                                  new Vector3(5,0,5)});&#13;
        lineRenderer.SetPosition(3, new Vector3(5, 0, 0));&#13;
&#13;
        //是否使用世界坐标系&#13;
        //决定了 是否随对象移动而移动&#13;
        lineRenderer.useWorldSpace = false;&#13;
&#13;
        //让线段受光影响 会接受光数据 进行着色器计算&#13;
        lineRenderer.generateLightingData = true;&#13;
        #endregion&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### LineRenderer类在Unity编辑器中的参数 （出自唐老狮课件）&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/4b4460ce-ebc3-48af-94b8-cb5e4bdea61d)&#13;
&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/422257e6-06c6-49e6-80b4-d526b60348e0)&#13;
&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/47c91c30-901d-4d5b-a2b4-6e411c0dcb64)&#13;
&#13;
![image](https://github.com/NatsunoKoide/natsunokoide.github.io/assets/137853852/00a605af-0d59-40b2-88b8-b43ad0b77983)&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.LineRenderer-lei.html</guid><pubDate>Mon, 22 Jan 2024 14:47:37 +0000</pubDate></item><item><title>Unity.异步加载场景</title><link>https://natsunokoide.github.io//post/Unity.-yi-bu-jia-zai-chang-jing.html</link><description>### 异步加载场景&#13;
&#13;
&gt; 代码以及总结&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.SceneManagement;&#13;
&#13;
public class Lesson20 : MonoBehaviour&#13;
{&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        #region 知识点一 回顾场景同步切换&#13;
        //SceneManager.LoadScene('Lesson20test');&#13;
&#13;
&#13;
        //需要在build settings中添加场景才能使用&#13;
&#13;
        //同步切换的缺点：&#13;
        //1.unity会删除当前场景的所有对象&#13;
        //2.同时加载下一个场景的相关信息&#13;
        //3.当前对象过多或者下一个场景对象过多时 会非常耗时并造成卡顿&#13;
&#13;
        //对于切换的卡顿 可以用异步切换解决这个问题&#13;
        #endregion&#13;
&#13;
        #region 知识点二 场景异步加载&#13;
        //1.通过事件回调函数 实现异步加载&#13;
        //AsyncOperation oa =  SceneManager.LoadSceneAsync('Lesson20test');&#13;
        //当场景异步加载结束后 自动调用事件函数 &#13;
        //如果希望在加载之后做一些说明 可以把逻辑加入到事件中&#13;
        //oa.completed += (a) =&gt;&#13;
        //{&#13;
        //    print('加载结束');&#13;
        //};&#13;
        //oa.completed += LoadOver;&#13;
&#13;
&#13;
        //2.通过协程异步加载&#13;
        //加载场景会把当前场景上 没有特殊处理的对象都删除&#13;
        //所以协程中部分逻辑 可能执行部不了&#13;
&#13;
        //解决办法：让处理场景加载的脚本衣服的对象 过场景时 不被移除&#13;
        //         使用函数 DontDestroyOnLoad（this.gameobject）;&#13;
&#13;
        DontDestroyOnLoad(this.gameObject);&#13;
        StartCoroutine(LoadScenes('Lesson20test'));&#13;
        #endregion&#13;
    }&#13;
&#13;
    private void LoadOver(AsyncOperation ao)&#13;
    {&#13;
        print('loadover');&#13;
    }&#13;
&#13;
    IEnumerator LoadScenes(string name)&#13;
    {&#13;
        AsyncOperation ao = SceneManager.LoadSceneAsync(name);&#13;
        //unity内部会发现是异步加载类型的返回对象 &#13;
        //会等待异步加载结束后 才会执行迭代器之后的内容&#13;
        //协程的好处 是异步加载场景时 可以在加载的同时做一些别的逻辑&#13;
        print('异步加载中');&#13;
        //yield return ao;&#13;
        //print('异步加载后');&#13;
&#13;
&#13;
        //可以在异步加载过程中 更新进度条&#13;
        //第一种 利用场景异步加载的进度 更新 但不准确 不常用&#13;
        while(!ao.isDone)&#13;
        {&#13;
            print(ao.progress);&#13;
            yield return null;&#13;
        }&#13;
        //离开循环 意味着加载结束 进度套满 完成切换 然后对进度条隐藏&#13;
&#13;
&#13;
        //第二种 根据游戏规则 自己定义 进度条变化的条件&#13;
        yield return ao;&#13;
        //场景加载结束 更新20%&#13;
        //接着加载场景的其他信息 比如加载怪物&#13;
        //再更新20% &#13;
        //接着加载场景模型 ……………………&#13;
    }&#13;
}&#13;
&#13;
#region 总结&#13;
//场景异步加载 和 资源异步加载 一样&#13;
//有两种方式&#13;
//1.通过事件回调函数&#13;
//2.协程异步加载&#13;
&#13;
//他们的优缺点表现和资源异步加载 也是一样的&#13;
//1.事件回调函数&#13;
//优点：写法简单，逻辑清晰&#13;
//缺点：只能加载完场景做一些事情 不能再加载过程中处理逻辑&#13;
//2.协程异步加载&#13;
//优点：可以在加载过程中处理逻辑，比如进度条更新等&#13;
//缺点：写法较为麻烦，要通过协程&#13;
#endregion&#13;
&#13;
```&#13;
&#13;
### 写一个异步加载场景的管理器&#13;
&#13;
&gt; 管理器代码&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
using UnityEngine.SceneManagement;&#13;
&#13;
public class SceneMgr &#13;
{&#13;
    private static SceneMgr instance = new SceneMgr();&#13;
    public static SceneMgr Instance =&gt; instance;&#13;
    private SceneMgr() { }&#13;
&#13;
    public void LoadScene(string name,UnityAction action)&#13;
    {&#13;
        AsyncOperation ao = SceneManager.LoadSceneAsync(name);&#13;
        //只是completed加入的委托一定要给予一个参数 此处a并没有用到&#13;
        ao.completed += (a) =&gt;&#13;
         {&#13;
             //通过lamda表达式包裹一层 在内部直接调用外部传入的委托&#13;
             action();&#13;
         };&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&gt; 管理器测试脚本&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson20Test : MonoBehaviour&#13;
{&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        SceneMgr.Instance.LoadScene('Lesson20test', () =&gt; &#13;
        {&#13;
            print('加载结束');&#13;
        });&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-yi-bu-jia-zai-chang-jing.html</guid><pubDate>Mon, 22 Jan 2024 13:49:54 +0000</pubDate></item><item><title>Acwing 291.蒙德里安的梦想</title><link>https://natsunokoide.github.io//post/Acwing%20291.-meng-de-li-an-de-meng-xiang.html</link><description>### 题目&#13;
n×m的棋盘可以摆放不同的1×2小方格的种类数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20291.-meng-de-li-an-de-meng-xiang.html</guid><pubDate>Mon, 22 Jan 2024 09:19:53 +0000</pubDate></item><item><title>Unity.Resources资源卸载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-xie-zai.html</link><description>### Resources资源卸载&#13;
&#13;
1. Resources是否存在重复加载资源以及内存消耗&#13;
Resources加载一次资源后，资源会存放在内存中作为缓存。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-xie-zai.html</guid><pubDate>Sun, 21 Jan 2024 11:13:00 +0000</pubDate></item><item><title>Unity.Resources异步加载管理器</title><link>https://natsunokoide.github.io//post/Unity.Resources-yi-bu-jia-zai-guan-li-qi.html</link><description>### Resources异步加载管理器&#13;
&#13;
### 单例模式实现资源异步加载管理&#13;
**用于对象化resources资源的异步加载，使得其他脚本在加载资源的时候更加便利，只需要输入地址和结束后需要响应的函数即可**&#13;
&#13;
&gt; 异步资源加载管理器代码（ResourcesMgr）&#13;
_运用单例模式进行编写，由于没有继承mono所以instance需要实例化_&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
&#13;
public class ResourcesMgr &#13;
{&#13;
    private static ResourcesMgr instance = new ResourcesMgr();&#13;
    public static ResourcesMgr Instance =&gt; instance;&#13;
    private ResourcesMgr(){}；&#13;
&#13;
    //在Resources类中 对于LoadAsync函数中的泛型T有object约束 所以a as ResourceRequest 需要定义函数内变量的约束&#13;
    //public static ResourceRequest LoadAsync&lt;T&gt;(string path) where T : Object;&#13;
    //泛型unity委托是有参委托&#13;
    public void LoadRes&lt;T&gt;(string address,UnityAction&lt;T&gt; callBack) where T : Object&#13;
    {&#13;
        ResourceRequest rq = Resources.LoadAsync(address);&#13;
        rq.completed += (a) =&gt;&#13;
        {&#13;
            callBack((a as ResourceRequest).asset as T);&#13;
        };&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&gt; 演示如何在text脚本中使用&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson18Text : MonoBehaviour&#13;
{&#13;
    private Texture tex;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        ResourcesMgr.Instance.LoadRes&lt;Texture&gt;('软考', (obj) =&gt;&#13;
        {&#13;
            tex = obj;&#13;
        });&#13;
&#13;
    }&#13;
&#13;
    private void OnGUI()&#13;
    {&#13;
        if(tex != null)&#13;
            GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-yi-bu-jia-zai-guan-li-qi.html</guid><pubDate>Sun, 21 Jan 2024 10:54:46 +0000</pubDate></item><item><title>Acwing 338.计数问题</title><link>https://natsunokoide.github.io//post/Acwing%20338.-ji-shu-wen-ti.html</link><description>### 题目&#13;
给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9的出现次数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20338.-ji-shu-wen-ti.html</guid><pubDate>Sun, 21 Jan 2024 06:44:54 +0000</pubDate></item><item><title>Acwing 900.整数划分（计数DP）</title><link>https://natsunokoide.github.io//post/Acwing%20900.-zheng-shu-hua-fen-%EF%BC%88-ji-shu-DP%EF%BC%89.html</link><description>### 题目&#13;
一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20900.-zheng-shu-hua-fen-%EF%BC%88-ji-shu-DP%EF%BC%89.html</guid><pubDate>Sat, 20 Jan 2024 05:17:20 +0000</pubDate></item><item><title>Acwing 899.编辑距离（最短距离问题的质询版本）</title><link>https://natsunokoide.github.io//post/Acwing%20899.-bian-ji-ju-li-%EF%BC%88-zui-duan-ju-li-wen-ti-de-zhi-xun-ban-ben-%EF%BC%89.html</link><description>### 题目&#13;
给定 n个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-bian-ji-ju-li-%EF%BC%88-zui-duan-ju-li-wen-ti-de-zhi-xun-ban-ben-%EF%BC%89.html</guid><pubDate>Tue, 16 Jan 2024 14:03:31 +0000</pubDate></item><item><title>Unity.Resources资源异步加载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-yi-bu-jia-zai.html</link><description>### Resources异步加载&#13;
### 对于异步加载的定义是什么&#13;
如果加载过大的资源可能会造成程序卡顿&#13;
卡顿的原因就是 从硬盘上把数据读取到内存中 是需要进行计算的&#13;
越大的资源耗时越长，就会造成掉帧卡顿&#13;
&#13;
&gt; Resources异步加载 就是内部新开一个线程进行资源加载 不会造成主线程卡顿&#13;
&#13;
### Resources异步加载方式&#13;
&#13;
1. 通过ResourceRequest中的事件实现异步加载&#13;
```js&#13;
// Unity 在内部 实例化一个rq请求 这个请求会去开一个线程进行资源下载&#13;
ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;('Tex/TestJPG');&#13;
//对资源下载结束这一事件进行监听&#13;
rq.completed += LoadOver;&#13;
//不能直接在 ResourceRequest rq 下一行直接调用 rq.asset 此时资源还没有加载完&#13;
```&#13;
```js&#13;
//completed事件需要形参 AsyncOperation 也就是正在监听是否结束的事件&#13;
private void LoadOver(AsyncOperation rq)&#13;
    {&#13;
        print('加载结束');&#13;
        //asset 是资源对象 加载完毕过后 就能够得到它&#13;
        //需要将AsyncOperation转换为ResourceRequest才能点出asset资源属性才能 再从资源as为目标对象类型&#13;
        tex = (rq as ResourceRequest).asset as Texture;&#13;
    }&#13;
private void OnGUI()&#13;
    {&#13;
        //判定tex对象不为空后 进行gui绘制&#13;
        if (tex != null)&#13;
            GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);&#13;
    }&#13;
```&#13;
2. 通过协程实现 异步加载资源&#13;
```js&#13;
void start()&#13;
{&#13;
     //在start函数中 开启协程 运行 协程函数load&#13;
     StartCoroutine(Load());&#13;
}&#13;
```&#13;
```js&#13;
 IEnumerator Load()&#13;
    {&#13;
        //迭代器函数 当遇到yield return时  就会停止执行之后的代码&#13;
        //协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时&#13;
        ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;('Tex/TestJPG');&#13;
&#13;
        //第一部分&#13;
        //Unity 自己知道 该返回值 意味着你在异步加载资源 &#13;
&#13;
        yield return rq; &#13;
        //通过yield return 一个ResourceRequest 可以让协程知道在运行异步加载&#13;
&#13;
        //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码&#13;
&#13;
         //另一种判断资源是否加载的方式 &#13;
        //判断资源是否加载结束&#13;
        while (!rq.isDone)&#13;
        {&#13;
            //打印当前的 加载进度 &#13;
            //该进度 不会特别准确 过渡也不是特别明显&#13;
            print(rq.progress);&#13;
            yield return null;&#13;
        }&#13;
        tex = rq.asset as Texture;&#13;
&#13;
        //yield return null;&#13;
        ////第二部分&#13;
        //yield return new WaitForSeconds(2f);&#13;
        ////第三部分&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-yi-bu-jia-zai.html</guid><pubDate>Mon, 15 Jan 2024 12:32:58 +0000</pubDate></item><item><title>Unity.Resources资源动态加载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-dong-tai-jia-zai.html</link><description>### Resources资源动态加载&#13;
&#13;
### 1. Resources资源动态加载的作用&#13;
1. 通过代码动态加载Resources文件夹下指定路径资源&#13;
2. 避免繁琐的拖曳操作&#13;
&#13;
### 2.常用资源类型&#13;
1.预设体对象——GameObject&#13;
2.音效文件——AudioClip&#13;
3.文本文件——TextAsset&#13;
4.图片文件——Texture&#13;
5.其它类型&#13;
&#13;
&gt; 预设体对象加载需要实例化,其它资源加载一般直接用&#13;
&#13;
### 3.资源同步加载 普通方法&#13;
&#13;
1. 在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 打包时 Resources文件夹 里的内容 都会打包在一起.&#13;
2. 预设体对象:第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) 第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化&#13;
```js&#13;
Object obj = Resources.Load('Cube');&#13;
Instantiate(obj);&#13;
```&#13;
_预设体的初始化操作是必须的_&#13;
&#13;
3.音效资源:第一步：就是加载数据 第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可&#13;
```js&#13;
public AudioSource audioS;&#13;
Object obj3 = Resources.Load('Music/BKMusic');&#13;
 audioS.clip = obj3 as AudioClip;&#13;
audioS.Play();&#13;
```&#13;
&#13;
4.文本资源:支持主流格式包括 txt,xml,bytes,json,html,csv……&#13;
```js&#13;
 TextAsset ta = Resources.Load('Txt/Test') as TextAsset;&#13;
 print(ta.text);&#13;
```&#13;
&#13;
5.图片资源&#13;
```js&#13;
private Texture tex;&#13;
tex = Resources.Load('Tex/TestJPG') as Texture;&#13;
```&#13;
&#13;
6.资源同名问题&#13;
显然Resources.Load加载同名资源时 无法准确加载出你想要的内容&#13;
解决方案有：&#13;
   (1)加载指定类型的资源&#13;
```js&#13;
 tex = Resources.Load('Tex/TestJPG', typeof(Texture)) as Texture;&#13;
```&#13;
   (2)加载指定名字的所有资源&#13;
```js&#13;
 Object[] objs = Resources.LoadAll('Tex/TestJPG');&#13;
        foreach (Object item in objs)&#13;
            if (item is Texture)&#13;
            else if (item is TextAsset)&#13;
```&#13;
&#13;
### 4. 解决资源类型和同名问题   泛型方法&#13;
&#13;
&gt; unity在Resources中提供了泛型接口 直接在使用的时候定义好类型即可&#13;
```js&#13;
TextAsset ta2 = Resources.Load&lt;TextAsset&gt;('Tex/TestJPG');&#13;
print(ta2.text);&#13;
tex = Resources.Load&lt;Texture&gt;('Tex/TestJPG');&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-dong-tai-jia-zai.html</guid><pubDate>Mon, 15 Jan 2024 07:45:33 +0000</pubDate></item><item><title>Unity.各类特殊文件</title><link>https://natsunokoide.github.io//post/Unity.-ge-lei-te-shu-wen-jian.html</link><description>### 1. 工程路径的获取&#13;
**该方式 获取到的路径 一般情况下 只在 编辑模式下使用&#13;
游戏发布过后 该路径不存在**&#13;
```js&#13;
print(Application.datePath);&#13;
```&#13;
###  2. Resources 资源文件夹&#13;
&#13;
_一般不获取,只能使用Resources相关API进行加载,需要我们自己将创建_&#13;
&#13;
**作用：&#13;
        资源文件夹&#13;
        1-1.需要通过Resources相关API动态加载的资源需要放在其中&#13;
        1-2.该文件夹下所有文件都会被打包出去&#13;
        1-3.打包时Unity会对其压缩加密&#13;
        1-4.该文件夹打包后只读 只能通过Resources相关API加载**&#13;
&#13;
###  3. StreamingAssets 流动资源文件夹&#13;
```js&#13;
print(Application.streamingAssetsPath);&#13;
```&#13;
_可以被主动获取，文件夹需要自己创建 _&#13;
**作用：&#13;
        流文件夹&#13;
        2-1.打包出去不会被压缩加密，可以任由我们摆布&#13;
        2-2.移动平台只读，PC平台可读可写&#13;
        2-3.可以放入一些需要自定义动态加载的初始资源**&#13;
&#13;
### 4. persistentDataPath 持久数据文件夹&#13;
```js&#13;
print(Application.persistentDataPath);&#13;
```&#13;
_可以被主动获取，不需要自己创建文件夹_&#13;
**固定数据文件夹&#13;
        3-1.所有平台都可读可写&#13;
        3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中**&#13;
&#13;
### 5. 其余特殊文件夹&#13;
&#13;
1. Plugins 插件文件夹：一般不获取，自己创建，存放不同平台的插件相关文件。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-ge-lei-te-shu-wen-jian.html</guid><pubDate>Mon, 15 Jan 2024 07:04:08 +0000</pubDate></item><item><title>Acwing 902.最短编辑距离</title><link>https://natsunokoide.github.io//post/Acwing%20902.-zui-duan-bian-ji-ju-li.html</link><description>### 题目&#13;
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：&#13;
1.删除–将字符串 A中的某个字符删除。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20902.-zui-duan-bian-ji-ju-li.html</guid><pubDate>Mon, 15 Jan 2024 04:57:43 +0000</pubDate></item><item><title>Acwing 896.最长上升子序列Ⅱ</title><link>https://natsunokoide.github.io//post/Acwing%20896.-zui-chang-shang-sheng-zi-xu-lie-%E2%85%A1.html</link><description>### 题目&#13;
给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20896.-zui-chang-shang-sheng-zi-xu-lie-%E2%85%A1.html</guid><pubDate>Sun, 14 Jan 2024 14:39:00 +0000</pubDate></item><item><title>Acwing 282.石子合并（区间DP）</title><link>https://natsunokoide.github.io//post/Acwing%20282.-shi-zi-he-bing-%EF%BC%88-qu-jian-DP%EF%BC%89.html</link><description>### 题目&#13;
**设有 N 堆石子排成一排，其编号为 1,2,3,…,N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20282.-shi-zi-he-bing-%EF%BC%88-qu-jian-DP%EF%BC%89.html</guid><pubDate>Fri, 05 Jan 2024 04:06:36 +0000</pubDate></item><item><title>Hot 100-7 LeetCode 42.接雨水</title><link>https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</link><description>### 题目&#13;
**给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</guid><pubDate>Sat, 30 Dec 2023 08:16:36 +0000</pubDate></item><item><title>Acwing 897.最长公共子序列</title><link>https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</link><description>### 题目&#13;
给定两个长度分别为 N 和 M的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</guid><pubDate>Sat, 30 Dec 2023 07:43:48 +0000</pubDate></item><item><title>Acwing 895.最长上升子序列</title><link>https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</link><description>### 题目&#13;
**给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</guid><pubDate>Fri, 29 Dec 2023 04:24:36 +0000</pubDate></item><item><title>Hot 100-6 LeetCode 15.三数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</link><description>### 题目&#13;
**给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</guid><pubDate>Thu, 28 Dec 2023 03:59:27 +0000</pubDate></item><item><title>Hot 100-5 LeetCode 11.盛最多水的容器</title><link>https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</link><description>### 题目&#13;
**给定一个长度为 n 的整数数组 height 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</guid><pubDate>Thu, 28 Dec 2023 03:40:07 +0000</pubDate></item><item><title>Acwing 898.数字三角形</title><link>https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</link><description>### 题目&#13;
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</guid><pubDate>Wed, 27 Dec 2023 01:59:41 +0000</pubDate></item><item><title>Hot 100-4 LeetCode 283.移动零</title><link>https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</link><description>### 题目&#13;
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</guid><pubDate>Tue, 26 Dec 2023 03:01:56 +0000</pubDate></item><item><title>Acwing 9.分组背包问题</title><link>https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</link><description>### 分组背包问题&#13;
有 N 组物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</guid><pubDate>Mon, 25 Dec 2023 04:17:12 +0000</pubDate></item><item><title>Acwing 5.多重背包问题Ⅱ（二进制优化物品个数问题）</title><link>https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</link><description>### 有 N种物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</guid><pubDate>Sun, 24 Dec 2023 06:25:08 +0000</pubDate></item><item><title>Acwing 4.多重背包问题Ⅰ</title><link>https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</link><description>### 题目有 N种物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</guid><pubDate>Sun, 24 Dec 2023 04:34:41 +0000</pubDate></item><item><title>Hot 100-3 LeetCode 128.最长连续序列</title><link>https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</link><description>### 题目&#13;
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</guid><pubDate>Sat, 23 Dec 2023 03:14:47 +0000</pubDate></item><item><title>Acwing 3.完全背包问题 </title><link>https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</link><description>### 完全背包问题&#13;
**有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</guid><pubDate>Sat, 23 Dec 2023 02:28:10 +0000</pubDate></item><item><title>Hot 100-2 LeetCode 49.字母异位词分组</title><link>https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</link><description>### 题目&#13;
**给你一个字符串数组，请你将 字母异位词 组合在一起。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</guid><pubDate>Fri, 22 Dec 2023 04:35:06 +0000</pubDate></item><item><title>Acwing 2.01背包问题（要求一维二维数组两组求解方案）</title><link>https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</link><description>### 0-1背包问题&#13;
**有 N 件物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</guid><pubDate>Fri, 22 Dec 2023 03:13:13 +0000</pubDate></item><item><title>Hot 100-1 LeetCode 1.两数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</link><description>### 题目&#13;
**给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</guid><pubDate>Thu, 21 Dec 2023 05:15:36 +0000</pubDate></item><item><title>Acwing 894.拆分-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</link><description>### Nim游戏的基础理论 在 #4 Nim游戏 中&#13;
### 拆分-Nim游戏 的 思考方式类似于集合-Nim游戏 需要针对不同的局面进行异或 #7 （SG函数）&#13;
&#13;
&gt; 拆分-Nim游戏的核心&#13;
**本题主要在于 每一次拆分两组的数量虽然可以大于原石头堆 但是每一组不可以大于原堆的石头数&#13;
   所以每一轮拆分都会至少使得上一轮的最大值-1，从而遍历所有情况总能使得有一方石头堆归零，无法继续操作。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</guid><pubDate>Thu, 21 Dec 2023 02:09:57 +0000</pubDate></item><item><title>Acwing 893.集合-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</link><description>### 集合-Nim游戏&#13;
**集合类型的Nim游戏问题在Nim之前需要对每一个集合进行SG函数计算并分析SG的结果**&#13;
&#13;
&gt; 知识点 1 mex( )函数&#13;
_mex（）：设集合S是一个非负整数集合，定义mex（S）为求出不属于S的最小非负整数的运算&#13;
  mes（S）= min[x],其中x属于自然数，且x不属于_&#13;
**可以理解为mex就是得出S中不存在的最小的数**&#13;
&#13;
&gt; 知识点 2 SG( )函数&#13;
_SG( ):：在有向图中，对于每个节点x,设x触发共有k条边，分别到达节点y1，y2……yk&#13;
  SG(x)为x的后继节点的SG值构成的集合执行mex（）运算后的值&#13;
  即SG（x） = mex（SG(y1),SG(y2),SG(y3)……SG（yk））&#13;
性质1：SG(i)  = k，则i最大能到达的SG值为k-1&#13;
性质2：非0可以走向0&#13;
性质3：0只能走向非0_&#13;
&#13;
### 本题最重要的定理&#13;
**对于n个图（集合）如果SG（G1）^SG(G2)^……SG(Gn) != 0 则先手必胜，反之先手必败**&#13;
&#13;
_对于理论部分，引用Acwing用户E.lena的手写图解_&#13;
[https://www.acwing.com/solution/content/23435/](url)&#13;
&#13;
### 题目内容&#13;
**给定 n堆石子以及一个由 k个不同正整数构成的数字集合 S。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:58:13 +0000</pubDate></item><item><title>Acwing 892.台阶-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</link><description>### 结论&#13;
**在Acwing 891的基础上，此题将传统Nim游戏问题拓展到台阶，有结论为：如果先手的奇数台阶上的值异或为0，则先手必败，反之亦然。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:02:38 +0000</pubDate></item><item><title>Unity.四元数</title><link>https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</link><description>### 轴-角对&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/fb7ce126-6726-4819-bebf-a2dfa19a1f75)&#13;
&#13;
### unity中的四元数结构体 —— Quaternion&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/db2d3b39-ca81-4b03-85ec-c2898ba6e7ae)&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/90418e9d-fb10-4fc1-a528-0ea20316fe95)&#13;
&#13;
&gt; 四元数公式api的使用用例&#13;
```js&#13;
//写一个 绕轴x 60度旋转 的cube&#13;
        Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30) * Mathf.Deg2Rad);&#13;
        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);&#13;
        obj.transform.rotation = q; &#13;
//q2与q相同 只是api不同&#13;
        Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right);&#13;
```&#13;
&#13;
&gt; 四元数和欧拉角转换&#13;
```js&#13;
        //1.欧拉直接赋值给四元数&#13;
        Quaternion q3 = Quaternion.Euler(120, 0, 0);&#13;
        obj.transform.rotation = q3;&#13;
        //2.四元数转欧拉角&#13;
        print(q3.eulerAngles);&#13;
```&#13;
&#13;
&gt; 四元数相乘——旋转（不会万向节死锁）&#13;
```js&#13;
        this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.forward); &#13;
```&#13;
&#13;
&gt; !!!!写一种会产生万向节死锁的方法（错误案例）&#13;
```js&#13;
        e = this.transform.rotation.eulerAngles;&#13;
        e += Vector3.forward;&#13;
        this.transform.rotation = Quaternion.Euler(e);&#13;
```&#13;
### 单位四元数——代表没有旋转&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/7e3c13a5-2def-426e-a612-2443e74416f6)&#13;
&#13;
```js&#13;
#region 知识点1 单位四元数&#13;
        print(Quaternion.identity);&#13;
        //直接让单位四元数赋值会直接让物体转角全部归零&#13;
        //obj.rotation = Quaternion.identity;&#13;
&#13;
        //Instantiate(obj, Vector3.zero, Quaternion.identity);&#13;
 #endregion&#13;
```&#13;
&#13;
### 四元数中的差值运算 + 通过看向的方式让物体一直盯着目标&#13;
```js&#13;
    public Quaternion start;&#13;
    public float time;&#13;
&#13;
    public Transform lookA;&#13;
    public Transform lookB;&#13;
void Start()&#13;
    {&#13;
        start = B.transform.rotation;&#13;
    }&#13;
void Update()&#13;
    {&#13;
&#13;
        #region 知识点2 插值运算 (在Quaternion中有lerp和slerp 但是lerp效果在大角度中一般所以就用slerp)&#13;
        //无限接近&#13;
        A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.transform.rotation, Time.deltaTime);&#13;
        //匀速  time &gt;= 1 到达目标&#13;
        time += Time.deltaTime;&#13;
        B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);&#13;
        #endregion&#13;
        #region 知识点3 lookrotation&#13;
        //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        lookA.rotation = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        #endregion&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</guid><pubDate>Tue, 19 Dec 2023 05:54:08 +0000</pubDate></item><item><title>Acwing 891.Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</link><description>### Nim游戏中的状态&#13;
**先手必胜状态：先手操作完，可以走到某一个必败状态&#13;
先手必败状态：先手操作完，走不到任何一个必败状态&#13;
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0&#13;
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0**&#13;
&#13;
### 结论&#13;
**假设n堆石头，石头的数量分别是a1，a2，a3……an。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</guid><pubDate>Tue, 19 Dec 2023 02:21:33 +0000</pubDate></item><item><title>Acwing 890.能被整除的数</title><link>https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</link><description>### 容斥原理&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/74e4f052-c584-420d-9027-d5efab16034b)&#13;
&#13;
### 实现思路&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/9ec8a3d0-3385-4127-a98a-217d07e992be)&#13;
&#13;
&gt; 此处给出一个答案用例 &#13;
&#13;
**n= 10，m = 2 ，p1 = 2， p2 = 3 解释为求1-10中能够满足被2或3整除的数字个数，答案为2，3，4，6，8，9，10，共7个**&#13;
&#13;
### Acwing 890.能被整除的数 代码 + 解析&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
using namespace std;&#13;
&#13;
using LL = long long;&#13;
&#13;
const int N = 20;&#13;
int p[N],n,m;&#13;
int res = 0;&#13;
&#13;
int main()&#13;
{&#13;
    cin &gt;&gt; n &gt;&gt; m;&#13;
    //先把输入的质数存到p数组中&#13;
    for(int i = 0;i &lt; m;i++) cin &gt;&gt; p[i];&#13;
    // 1 &lt;&lt; m 代表的是2的m次方 也就是2的m次方个二进制情况&#13;
    for(int i = 1;i &lt; 1 &lt;&lt; m;i++)&#13;
    {&#13;
        int t = 1;//用于记录当前组质数的总乘积&#13;
        int s = 0; //用来记录这一组二进制数有几个1，几个1代表包含几个集合&#13;
        //遍历当前组的各个位置&#13;
        for(int j = 0;j &lt; m;j++)&#13;
        {&#13;
            //判断到当前位置为1&#13;
            if(i &gt;&gt; j &amp; 1)&#13;
            {&#13;
                //质数的总乘积如果已经大于n呢么就break，此集合是空集&#13;
                if((LL)t * p[j] &gt; n) &#13;
                {&#13;
                    t = -1;&#13;
                    break;&#13;
                }&#13;
                s++; //i &gt;&gt; j &amp; 1 判定到当前位是1 s++&#13;
                t *= p[j]; //把当前1位置的质数乘到t中&#13;
            }&#13;
        }&#13;
        if(t != -1) //如果t的值没有超出总数，就对res进行计算&#13;
        {&#13;
            //这里涉及到容斥原理中 计算集合个数的公式 Si = n/pi（向下取整）（n为总数，pi为质数）&#13;
            //之前用t存储当前组所有质数的乘积 因为 S1交S2 = n/（p1*p2），所以使用t的乘积可以多个集合的情况&#13;
            //s代表1的个数，这是因为容斥原理每一项的系数为（-1）的（n-1）次方（n为1的个数）&#13;
            if(s &amp; 1) res += n / t; //(s &amp; 1)若为1 证明当前组包含奇数个集合（奇数个1）&#13;
            //如果是奇数的组合 根据容斥原理 为+号&#13;
            else res -= n / t; //反之为-号&#13;
        }&#13;
    }&#13;
    cout &lt;&lt; res &lt;&lt; endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
_此题涉及到容斥原理 和 二进制处理集合的情况_。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</guid><pubDate>Mon, 18 Dec 2023 09:23:11 +0000</pubDate></item><item><title>Acwing 899.满足条件的01序列</title><link>https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</link><description>### 卡特兰数&#13;
    &#13;
&#13;
&gt; 卡特兰数是组合数学中一个常出现于各种计数问题中的数列。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</guid><pubDate>Sat, 16 Dec 2023 05:23:12 +0000</pubDate></item><item><title>Acwing 888.求组合数IV </title><link>https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</link><description>&#13;
### 求组合数的基础公式：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/d3b140ef-012e-46ab-9edd-974cc4d97757)&#13;
### 其中阶乘可以转化为：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/ec00e7e3-2f42-46a3-bbf5-15df59e956fa)&#13;
&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const int N = 5010;&#13;
&#13;
int primes[N],cnt;&#13;
int sum[N];&#13;
bool st[N];&#13;
&#13;
void get_primes(int n)   //线性筛法求质数 cnt是个数 primes数组里装着质数&#13;
{&#13;
    for(int i = 2;i &lt;= n;i++)&#13;
    {&#13;
        if(!st[i]) primes[cnt++] = i;&#13;
        for(int j = 0;primes[j] * i &lt;= n;j++)&#13;
        {&#13;
            st[primes[j] * i] = true;&#13;
            if(i % primes[j] == 0) break;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int get(int n,int p) //// 求n！中包含p的次数&#13;
{&#13;
    int res = 0;&#13;
    while(n)&#13;
    {&#13;
        res += n/p;&#13;
        n /= p;&#13;
    }&#13;
    return res;&#13;
}&#13;
&#13;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)   //高精度乘法 用vector接收 和 输入 c++才要&#13;
{&#13;
    vector&lt;int&gt; C;&#13;
    int t = 0;&#13;
    for(int i = 0;t || i &lt; A.size();i++)&#13;
    {&#13;
        if(i &lt; A.size()) t += A[i] * b;&#13;
        C.push_back(t % 10);&#13;
        t /= 10;&#13;
    }&#13;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#13;
    return C;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    int a,b;&#13;
    cin &gt;&gt; a &gt;&gt; b;&#13;
    get_primes(a);&#13;
    //循环得到每一个质数的次数（这个次数不能重复）&#13;
    for(int i = 0;i &lt; cnt;i++) //cnt在get_primes函数里&#13;
    {&#13;
        int p = primes[i];&#13;
        sum[i] = get(a,p) - get(a-b,p) - get(b,p);&#13;
    }&#13;
    &#13;
    vector&lt;int&gt; res;&#13;
    res.push_back(1);&#13;
    &#13;
    for(int i = 0;i &lt; cnt;i++) //循环质数的个数&#13;
    {&#13;
        for(int j = 0;j &lt; sum[i];j++)//循环质数的次数&#13;
        {&#13;
            res = mul(res,primes[i]); //算出每一个质数的j次方&#13;
        }&#13;
    }&#13;
    //因为高精度乘法最后的输出是每一个数字以vector的方式呈现的 所以需要遍历整个数组才能得到最后的数字&#13;
    for(int i = res.size() - 1;i &gt;= 0;i--) printf('%d',res[i]);&#13;
    return 0;&#13;
} &#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</guid><pubDate>Thu, 14 Dec 2023 04:27:59 +0000</pubDate></item></channel></rss>