<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ADd7</title><link>https://natsunokoide.github.io/</link><description>C++ / C# / Unity 
 You are welcome to send us your valuable comments.  E-mail:yujiaqifinn@outlook.com</description><copyright>ADd7</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://i.postimg.cc/dtT4J441/image.png</url><title>avatar</title><link>https://natsunokoide.github.io/</link></image><lastBuildDate>Sat, 16 Dec 2023 07:45:59 +0000</lastBuildDate><managingEditor>ADd7</managingEditor><pubDate>Sat, 16 Dec 2023 07:45:59 +0000</pubDate><ttl>60</ttl><webMaster>ADd7</webMaster><item><title>Acwing 899.满足条件的01序列</title><link>https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</link><description>### 卡特兰数&#13;
    卡特兰数是组合数学中一个常出现于各种计数问题中的数列。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</guid><pubDate>Sat, 16 Dec 2023 05:23:12 +0000</pubDate></item><item><title>Acwing 888.求组合数IV </title><link>https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</link><description>&#13;
### 求组合数的基础公式：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/d3b140ef-012e-46ab-9edd-974cc4d97757)&#13;
### 其中阶乘可以转化为：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/ec00e7e3-2f42-46a3-bbf5-15df59e956fa)&#13;
&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const int N = 5010;&#13;
&#13;
int primes[N],cnt;&#13;
int sum[N];&#13;
bool st[N];&#13;
&#13;
void get_primes(int n)   //线性筛法求质数 cnt是个数 primes数组里装着质数&#13;
{&#13;
    for(int i = 2;i &lt;= n;i++)&#13;
    {&#13;
        if(!st[i]) primes[cnt++] = i;&#13;
        for(int j = 0;primes[j] * i &lt;= n;j++)&#13;
        {&#13;
            st[primes[j] * i] = true;&#13;
            if(i % primes[j] == 0) break;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int get(int n,int p) //// 求n！中包含p的次数&#13;
{&#13;
    int res = 0;&#13;
    while(n)&#13;
    {&#13;
        res += n/p;&#13;
        n /= p;&#13;
    }&#13;
    return res;&#13;
}&#13;
&#13;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)   //高精度乘法 用vector接收 和 输入 c++才要&#13;
{&#13;
    vector&lt;int&gt; C;&#13;
    int t = 0;&#13;
    for(int i = 0;t || i &lt; A.size();i++)&#13;
    {&#13;
        if(i &lt; A.size()) t += A[i] * b;&#13;
        C.push_back(t % 10);&#13;
        t /= 10;&#13;
    }&#13;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#13;
    return C;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    int a,b;&#13;
    cin &gt;&gt; a &gt;&gt; b;&#13;
    get_primes(a);&#13;
    //循环得到每一个质数的次数（这个次数不能重复）&#13;
    for(int i = 0;i &lt; cnt;i++) //cnt在get_primes函数里&#13;
    {&#13;
        int p = primes[i];&#13;
        sum[i] = get(a,p) - get(a-b,p) - get(b,p);&#13;
    }&#13;
    &#13;
    vector&lt;int&gt; res;&#13;
    res.push_back(1);&#13;
    &#13;
    for(int i = 0;i &lt; cnt;i++) //循环质数的个数&#13;
    {&#13;
        for(int j = 0;j &lt; sum[i];j++)//循环质数的次数&#13;
        {&#13;
            res = mul(res,primes[i]); //算出每一个质数的j次方&#13;
        }&#13;
    }&#13;
    //因为高精度乘法最后的输出是每一个数字以vector的方式呈现的 所以需要遍历整个数组才能得到最后的数字&#13;
    for(int i = res.size() - 1;i &gt;= 0;i--) printf("%d",res[i]);&#13;
    return 0;&#13;
} &#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</guid><pubDate>Thu, 14 Dec 2023 04:27:59 +0000</pubDate></item></channel></rss>