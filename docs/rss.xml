<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ADd7</title><link>https://natsunokoide.github.io/</link><description>C++ / C# / Unity 
 You are welcome to send us your valuable comments.  E-mail:yujiaqifinn@outlook.com</description><copyright>ADd7</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://i.postimg.cc/dtT4J441/image.png</url><title>avatar</title><link>https://natsunokoide.github.io/</link></image><lastBuildDate>Tue, 19 Dec 2023 02:21:56 +0000</lastBuildDate><managingEditor>ADd7</managingEditor><pubDate>Tue, 19 Dec 2023 02:21:56 +0000</pubDate><ttl>60</ttl><webMaster>ADd7</webMaster><item><title>Acwing 891.Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</link><description>### Nim游戏中的状态&#13;
**先手必胜状态：先手操作完，可以走到某一个必败状态&#13;
先手必败状态：先手操作完，走不到任何一个必败状态&#13;
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0&#13;
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0**&#13;
&#13;
### 结论&#13;
**假设n堆石头，石头的数量分别是a1，a2，a3……an。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</guid><pubDate>Tue, 19 Dec 2023 02:21:33 +0000</pubDate></item><item><title>Acwing 890.能被整除的数</title><link>https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</link><description>### 容斥原理&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/74e4f052-c584-420d-9027-d5efab16034b)&#13;
&#13;
### 实现思路&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/9ec8a3d0-3385-4127-a98a-217d07e992be)&#13;
&#13;
&gt; 此处给出一个答案用例 &#13;
&#13;
**n= 10，m = 2 ，p1 = 2， p2 = 3 解释为求1-10中能够满足被2或3整除的数字个数，答案为2，3，4，6，8，9，10，共7个**&#13;
&#13;
### Acwing 890.能被整除的数 代码 + 解析&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
using namespace std;&#13;
&#13;
using LL = long long;&#13;
&#13;
const int N = 20;&#13;
int p[N],n,m;&#13;
int res = 0;&#13;
&#13;
int main()&#13;
{&#13;
    cin &gt;&gt; n &gt;&gt; m;&#13;
    //先把输入的质数存到p数组中&#13;
    for(int i = 0;i &lt; m;i++) cin &gt;&gt; p[i];&#13;
    // 1 &lt;&lt; m 代表的是2的m次方 也就是2的m次方个二进制情况&#13;
    for(int i = 1;i &lt; 1 &lt;&lt; m;i++)&#13;
    {&#13;
        int t = 1;//用于记录当前组质数的总乘积&#13;
        int s = 0; //用来记录这一组二进制数有几个1，几个1代表包含几个集合&#13;
        //遍历当前组的各个位置&#13;
        for(int j = 0;j &lt; m;j++)&#13;
        {&#13;
            //判断到当前位置为1&#13;
            if(i &gt;&gt; j &amp; 1)&#13;
            {&#13;
                //质数的总乘积如果已经大于n呢么就break，此集合是空集&#13;
                if((LL)t * p[j] &gt; n) &#13;
                {&#13;
                    t = -1;&#13;
                    break;&#13;
                }&#13;
                s++; //i &gt;&gt; j &amp; 1 判定到当前位是1 s++&#13;
                t *= p[j]; //把当前1位置的质数乘到t中&#13;
            }&#13;
        }&#13;
        if(t != -1) //如果t的值没有超出总数，就对res进行计算&#13;
        {&#13;
            //这里涉及到容斥原理中 计算集合个数的公式 Si = n/pi（向下取整）（n为总数，pi为质数）&#13;
            //之前用t存储当前组所有质数的乘积 因为 S1交S2 = n/（p1*p2），所以使用t的乘积可以多个集合的情况&#13;
            //s代表1的个数，这是因为容斥原理每一项的系数为（-1）的（n-1）次方（n为1的个数）&#13;
            if(s &amp; 1) res += n / t; //(s &amp; 1)若为1 证明当前组包含奇数个集合（奇数个1）&#13;
            //如果是奇数的组合 根据容斥原理 为+号&#13;
            else res -= n / t; //反之为-号&#13;
        }&#13;
    }&#13;
    cout &lt;&lt; res &lt;&lt; endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
_此题涉及到容斥原理 和 二进制处理集合的情况_。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</guid><pubDate>Mon, 18 Dec 2023 09:23:11 +0000</pubDate></item><item><title>Acwing 899.满足条件的01序列</title><link>https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</link><description>### 卡特兰数&#13;
    &#13;
&#13;
&gt; 卡特兰数是组合数学中一个常出现于各种计数问题中的数列。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</guid><pubDate>Sat, 16 Dec 2023 05:23:12 +0000</pubDate></item><item><title>Acwing 888.求组合数IV </title><link>https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</link><description>&#13;
### 求组合数的基础公式：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/d3b140ef-012e-46ab-9edd-974cc4d97757)&#13;
### 其中阶乘可以转化为：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/ec00e7e3-2f42-46a3-bbf5-15df59e956fa)&#13;
&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const int N = 5010;&#13;
&#13;
int primes[N],cnt;&#13;
int sum[N];&#13;
bool st[N];&#13;
&#13;
void get_primes(int n)   //线性筛法求质数 cnt是个数 primes数组里装着质数&#13;
{&#13;
    for(int i = 2;i &lt;= n;i++)&#13;
    {&#13;
        if(!st[i]) primes[cnt++] = i;&#13;
        for(int j = 0;primes[j] * i &lt;= n;j++)&#13;
        {&#13;
            st[primes[j] * i] = true;&#13;
            if(i % primes[j] == 0) break;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int get(int n,int p) //// 求n！中包含p的次数&#13;
{&#13;
    int res = 0;&#13;
    while(n)&#13;
    {&#13;
        res += n/p;&#13;
        n /= p;&#13;
    }&#13;
    return res;&#13;
}&#13;
&#13;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)   //高精度乘法 用vector接收 和 输入 c++才要&#13;
{&#13;
    vector&lt;int&gt; C;&#13;
    int t = 0;&#13;
    for(int i = 0;t || i &lt; A.size();i++)&#13;
    {&#13;
        if(i &lt; A.size()) t += A[i] * b;&#13;
        C.push_back(t % 10);&#13;
        t /= 10;&#13;
    }&#13;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#13;
    return C;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    int a,b;&#13;
    cin &gt;&gt; a &gt;&gt; b;&#13;
    get_primes(a);&#13;
    //循环得到每一个质数的次数（这个次数不能重复）&#13;
    for(int i = 0;i &lt; cnt;i++) //cnt在get_primes函数里&#13;
    {&#13;
        int p = primes[i];&#13;
        sum[i] = get(a,p) - get(a-b,p) - get(b,p);&#13;
    }&#13;
    &#13;
    vector&lt;int&gt; res;&#13;
    res.push_back(1);&#13;
    &#13;
    for(int i = 0;i &lt; cnt;i++) //循环质数的个数&#13;
    {&#13;
        for(int j = 0;j &lt; sum[i];j++)//循环质数的次数&#13;
        {&#13;
            res = mul(res,primes[i]); //算出每一个质数的j次方&#13;
        }&#13;
    }&#13;
    //因为高精度乘法最后的输出是每一个数字以vector的方式呈现的 所以需要遍历整个数组才能得到最后的数字&#13;
    for(int i = res.size() - 1;i &gt;= 0;i--) printf("%d",res[i]);&#13;
    return 0;&#13;
} &#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</guid><pubDate>Thu, 14 Dec 2023 04:27:59 +0000</pubDate></item></channel></rss>