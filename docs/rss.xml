<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ADd7</title><link>https://natsunokoide.github.io/</link><description>C++ / C# / Unity 
 You are welcome to send us your valuable comments.  E-mail:yujiaqifinn@outlook.com</description><copyright>ADd7</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://i.postimg.cc/dtT4J441/image.png</url><title>avatar</title><link>https://natsunokoide.github.io/</link></image><lastBuildDate>Sat, 30 Dec 2023 08:46:39 +0000</lastBuildDate><managingEditor>ADd7</managingEditor><pubDate>Sat, 30 Dec 2023 08:46:39 +0000</pubDate><ttl>60</ttl><webMaster>ADd7</webMaster><item><title>Hot 100-7 LeetCode 42.接雨水</title><link>https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</link><description>### 题目&#13;
**给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</guid><pubDate>Sat, 30 Dec 2023 08:16:36 +0000</pubDate></item><item><title>Acwing 897.最长公共子序列</title><link>https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</link><description>### 题目&#13;
给定两个长度分别为 N 和 M的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</guid><pubDate>Sat, 30 Dec 2023 07:43:48 +0000</pubDate></item><item><title>Acwing 895.最长上升子序列</title><link>https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</link><description>### 题目&#13;
**给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</guid><pubDate>Fri, 29 Dec 2023 04:24:36 +0000</pubDate></item><item><title>Hot 100-6 LeetCode 15.三数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</link><description>### 题目&#13;
**给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</guid><pubDate>Thu, 28 Dec 2023 03:59:27 +0000</pubDate></item><item><title>Hot 100-5 LeetCode 11.盛最多水的容器</title><link>https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</link><description>### 题目&#13;
**给定一个长度为 n 的整数数组 height 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</guid><pubDate>Thu, 28 Dec 2023 03:40:07 +0000</pubDate></item><item><title>Acwing 898.数字三角形</title><link>https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</link><description>### 题目&#13;
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</guid><pubDate>Wed, 27 Dec 2023 01:59:41 +0000</pubDate></item><item><title>Hot 100-4 LeetCode 283.移动零</title><link>https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</link><description>### 题目&#13;
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</guid><pubDate>Tue, 26 Dec 2023 03:01:56 +0000</pubDate></item><item><title>Acwing 9.分组背包问题</title><link>https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</link><description>### 分组背包问题&#13;
有 N 组物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</guid><pubDate>Mon, 25 Dec 2023 04:17:12 +0000</pubDate></item><item><title>Acwing 5.多重背包问题Ⅱ（二进制优化物品个数问题）</title><link>https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</link><description>### 有 N种物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</guid><pubDate>Sun, 24 Dec 2023 06:25:08 +0000</pubDate></item><item><title>Acwing 4.多重背包问题Ⅰ</title><link>https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</link><description>### 题目有 N种物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</guid><pubDate>Sun, 24 Dec 2023 04:34:41 +0000</pubDate></item><item><title>Hot 100-3 LeetCode 128.最长连续序列</title><link>https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</link><description>### 题目&#13;
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</guid><pubDate>Sat, 23 Dec 2023 03:14:47 +0000</pubDate></item><item><title>Acwing 3.完全背包问题 </title><link>https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</link><description>### 完全背包问题&#13;
**有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</guid><pubDate>Sat, 23 Dec 2023 02:28:10 +0000</pubDate></item><item><title>Hot 100-2 LeetCode 49.字母异位词分组</title><link>https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</link><description>### 题目&#13;
**给你一个字符串数组，请你将 字母异位词 组合在一起。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</guid><pubDate>Fri, 22 Dec 2023 04:35:06 +0000</pubDate></item><item><title>Acwing 2.01背包问题（要求一维二维数组两组求解方案）</title><link>https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</link><description>### 0-1背包问题&#13;
**有 N 件物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</guid><pubDate>Fri, 22 Dec 2023 03:13:13 +0000</pubDate></item><item><title>Hot 100-1 LeetCode 1.两数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</link><description>### 题目&#13;
**给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</guid><pubDate>Thu, 21 Dec 2023 05:15:36 +0000</pubDate></item><item><title>Acwing 894.拆分-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</link><description>### Nim游戏的基础理论 在 #4 Nim游戏 中&#13;
### 拆分-Nim游戏 的 思考方式类似于集合-Nim游戏 需要针对不同的局面进行异或 #7 （SG函数）&#13;
&#13;
&gt; 拆分-Nim游戏的核心&#13;
**本题主要在于 每一次拆分两组的数量虽然可以大于原石头堆 但是每一组不可以大于原堆的石头数&#13;
   所以每一轮拆分都会至少使得上一轮的最大值-1，从而遍历所有情况总能使得有一方石头堆归零，无法继续操作。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</guid><pubDate>Thu, 21 Dec 2023 02:09:57 +0000</pubDate></item><item><title>Acwing 893.集合-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</link><description>### 集合-Nim游戏&#13;
**集合类型的Nim游戏问题在Nim之前需要对每一个集合进行SG函数计算并分析SG的结果**&#13;
&#13;
&gt; 知识点 1 mex( )函数&#13;
_mex（）：设集合S是一个非负整数集合，定义mex（S）为求出不属于S的最小非负整数的运算&#13;
  mes（S）= min[x],其中x属于自然数，且x不属于_&#13;
**可以理解为mex就是得出S中不存在的最小的数**&#13;
&#13;
&gt; 知识点 2 SG( )函数&#13;
_SG( ):：在有向图中，对于每个节点x,设x触发共有k条边，分别到达节点y1，y2……yk&#13;
  SG(x)为x的后继节点的SG值构成的集合执行mex（）运算后的值&#13;
  即SG（x） = mex（SG(y1),SG(y2),SG(y3)……SG（yk））&#13;
性质1：SG(i)  = k，则i最大能到达的SG值为k-1&#13;
性质2：非0可以走向0&#13;
性质3：0只能走向非0_&#13;
&#13;
### 本题最重要的定理&#13;
**对于n个图（集合）如果SG（G1）^SG(G2)^……SG(Gn) != 0 则先手必胜，反之先手必败**&#13;
&#13;
_对于理论部分，引用Acwing用户E.lena的手写图解_&#13;
[https://www.acwing.com/solution/content/23435/](url)&#13;
&#13;
### 题目内容&#13;
**给定 n堆石子以及一个由 k个不同正整数构成的数字集合 S。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:58:13 +0000</pubDate></item><item><title>Acwing 892.台阶-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</link><description>### 结论&#13;
**在Acwing 891的基础上，此题将传统Nim游戏问题拓展到台阶，有结论为：如果先手的奇数台阶上的值异或为0，则先手必败，反之亦然。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:02:38 +0000</pubDate></item><item><title>Unity.四元数</title><link>https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</link><description>### 轴-角对&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/fb7ce126-6726-4819-bebf-a2dfa19a1f75)&#13;
&#13;
### unity中的四元数结构体 —— Quaternion&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/db2d3b39-ca81-4b03-85ec-c2898ba6e7ae)&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/90418e9d-fb10-4fc1-a528-0ea20316fe95)&#13;
&#13;
&gt; 四元数公式api的使用用例&#13;
```js&#13;
//写一个 绕轴x 60度旋转 的cube&#13;
        Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30) * Mathf.Deg2Rad);&#13;
        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);&#13;
        obj.transform.rotation = q; &#13;
//q2与q相同 只是api不同&#13;
        Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right);&#13;
```&#13;
&#13;
&gt; 四元数和欧拉角转换&#13;
```js&#13;
        //1.欧拉直接赋值给四元数&#13;
        Quaternion q3 = Quaternion.Euler(120, 0, 0);&#13;
        obj.transform.rotation = q3;&#13;
        //2.四元数转欧拉角&#13;
        print(q3.eulerAngles);&#13;
```&#13;
&#13;
&gt; 四元数相乘——旋转（不会万向节死锁）&#13;
```js&#13;
        this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.forward); &#13;
```&#13;
&#13;
&gt; !!!!写一种会产生万向节死锁的方法（错误案例）&#13;
```js&#13;
        e = this.transform.rotation.eulerAngles;&#13;
        e += Vector3.forward;&#13;
        this.transform.rotation = Quaternion.Euler(e);&#13;
```&#13;
### 单位四元数——代表没有旋转&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/7e3c13a5-2def-426e-a612-2443e74416f6)&#13;
&#13;
```js&#13;
#region 知识点1 单位四元数&#13;
        print(Quaternion.identity);&#13;
        //直接让单位四元数赋值会直接让物体转角全部归零&#13;
        //obj.rotation = Quaternion.identity;&#13;
&#13;
        //Instantiate(obj, Vector3.zero, Quaternion.identity);&#13;
 #endregion&#13;
```&#13;
&#13;
### 四元数中的差值运算 + 通过看向的方式让物体一直盯着目标&#13;
```js&#13;
    public Quaternion start;&#13;
    public float time;&#13;
&#13;
    public Transform lookA;&#13;
    public Transform lookB;&#13;
void Start()&#13;
    {&#13;
        start = B.transform.rotation;&#13;
    }&#13;
void Update()&#13;
    {&#13;
&#13;
        #region 知识点2 插值运算 (在Quaternion中有lerp和slerp 但是lerp效果在大角度中一般所以就用slerp)&#13;
        //无限接近&#13;
        A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.transform.rotation, Time.deltaTime);&#13;
        //匀速  time &gt;= 1 到达目标&#13;
        time += Time.deltaTime;&#13;
        B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);&#13;
        #endregion&#13;
        #region 知识点3 lookrotation&#13;
        //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        lookA.rotation = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        #endregion&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</guid><pubDate>Tue, 19 Dec 2023 05:54:08 +0000</pubDate></item><item><title>Acwing 891.Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</link><description>### Nim游戏中的状态&#13;
**先手必胜状态：先手操作完，可以走到某一个必败状态&#13;
先手必败状态：先手操作完，走不到任何一个必败状态&#13;
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0&#13;
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0**&#13;
&#13;
### 结论&#13;
**假设n堆石头，石头的数量分别是a1，a2，a3……an。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</guid><pubDate>Tue, 19 Dec 2023 02:21:33 +0000</pubDate></item><item><title>Acwing 890.能被整除的数</title><link>https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</link><description>### 容斥原理&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/74e4f052-c584-420d-9027-d5efab16034b)&#13;
&#13;
### 实现思路&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/9ec8a3d0-3385-4127-a98a-217d07e992be)&#13;
&#13;
&gt; 此处给出一个答案用例 &#13;
&#13;
**n= 10，m = 2 ，p1 = 2， p2 = 3 解释为求1-10中能够满足被2或3整除的数字个数，答案为2，3，4，6，8，9，10，共7个**&#13;
&#13;
### Acwing 890.能被整除的数 代码 + 解析&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
using namespace std;&#13;
&#13;
using LL = long long;&#13;
&#13;
const int N = 20;&#13;
int p[N],n,m;&#13;
int res = 0;&#13;
&#13;
int main()&#13;
{&#13;
    cin &gt;&gt; n &gt;&gt; m;&#13;
    //先把输入的质数存到p数组中&#13;
    for(int i = 0;i &lt; m;i++) cin &gt;&gt; p[i];&#13;
    // 1 &lt;&lt; m 代表的是2的m次方 也就是2的m次方个二进制情况&#13;
    for(int i = 1;i &lt; 1 &lt;&lt; m;i++)&#13;
    {&#13;
        int t = 1;//用于记录当前组质数的总乘积&#13;
        int s = 0; //用来记录这一组二进制数有几个1，几个1代表包含几个集合&#13;
        //遍历当前组的各个位置&#13;
        for(int j = 0;j &lt; m;j++)&#13;
        {&#13;
            //判断到当前位置为1&#13;
            if(i &gt;&gt; j &amp; 1)&#13;
            {&#13;
                //质数的总乘积如果已经大于n呢么就break，此集合是空集&#13;
                if((LL)t * p[j] &gt; n) &#13;
                {&#13;
                    t = -1;&#13;
                    break;&#13;
                }&#13;
                s++; //i &gt;&gt; j &amp; 1 判定到当前位是1 s++&#13;
                t *= p[j]; //把当前1位置的质数乘到t中&#13;
            }&#13;
        }&#13;
        if(t != -1) //如果t的值没有超出总数，就对res进行计算&#13;
        {&#13;
            //这里涉及到容斥原理中 计算集合个数的公式 Si = n/pi（向下取整）（n为总数，pi为质数）&#13;
            //之前用t存储当前组所有质数的乘积 因为 S1交S2 = n/（p1*p2），所以使用t的乘积可以多个集合的情况&#13;
            //s代表1的个数，这是因为容斥原理每一项的系数为（-1）的（n-1）次方（n为1的个数）&#13;
            if(s &amp; 1) res += n / t; //(s &amp; 1)若为1 证明当前组包含奇数个集合（奇数个1）&#13;
            //如果是奇数的组合 根据容斥原理 为+号&#13;
            else res -= n / t; //反之为-号&#13;
        }&#13;
    }&#13;
    cout &lt;&lt; res &lt;&lt; endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
_此题涉及到容斥原理 和 二进制处理集合的情况_。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</guid><pubDate>Mon, 18 Dec 2023 09:23:11 +0000</pubDate></item><item><title>Acwing 899.满足条件的01序列</title><link>https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</link><description>### 卡特兰数&#13;
    &#13;
&#13;
&gt; 卡特兰数是组合数学中一个常出现于各种计数问题中的数列。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</guid><pubDate>Sat, 16 Dec 2023 05:23:12 +0000</pubDate></item><item><title>Acwing 888.求组合数IV </title><link>https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</link><description>&#13;
### 求组合数的基础公式：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/d3b140ef-012e-46ab-9edd-974cc4d97757)&#13;
### 其中阶乘可以转化为：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/ec00e7e3-2f42-46a3-bbf5-15df59e956fa)&#13;
&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const int N = 5010;&#13;
&#13;
int primes[N],cnt;&#13;
int sum[N];&#13;
bool st[N];&#13;
&#13;
void get_primes(int n)   //线性筛法求质数 cnt是个数 primes数组里装着质数&#13;
{&#13;
    for(int i = 2;i &lt;= n;i++)&#13;
    {&#13;
        if(!st[i]) primes[cnt++] = i;&#13;
        for(int j = 0;primes[j] * i &lt;= n;j++)&#13;
        {&#13;
            st[primes[j] * i] = true;&#13;
            if(i % primes[j] == 0) break;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int get(int n,int p) //// 求n！中包含p的次数&#13;
{&#13;
    int res = 0;&#13;
    while(n)&#13;
    {&#13;
        res += n/p;&#13;
        n /= p;&#13;
    }&#13;
    return res;&#13;
}&#13;
&#13;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)   //高精度乘法 用vector接收 和 输入 c++才要&#13;
{&#13;
    vector&lt;int&gt; C;&#13;
    int t = 0;&#13;
    for(int i = 0;t || i &lt; A.size();i++)&#13;
    {&#13;
        if(i &lt; A.size()) t += A[i] * b;&#13;
        C.push_back(t % 10);&#13;
        t /= 10;&#13;
    }&#13;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#13;
    return C;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    int a,b;&#13;
    cin &gt;&gt; a &gt;&gt; b;&#13;
    get_primes(a);&#13;
    //循环得到每一个质数的次数（这个次数不能重复）&#13;
    for(int i = 0;i &lt; cnt;i++) //cnt在get_primes函数里&#13;
    {&#13;
        int p = primes[i];&#13;
        sum[i] = get(a,p) - get(a-b,p) - get(b,p);&#13;
    }&#13;
    &#13;
    vector&lt;int&gt; res;&#13;
    res.push_back(1);&#13;
    &#13;
    for(int i = 0;i &lt; cnt;i++) //循环质数的个数&#13;
    {&#13;
        for(int j = 0;j &lt; sum[i];j++)//循环质数的次数&#13;
        {&#13;
            res = mul(res,primes[i]); //算出每一个质数的j次方&#13;
        }&#13;
    }&#13;
    //因为高精度乘法最后的输出是每一个数字以vector的方式呈现的 所以需要遍历整个数组才能得到最后的数字&#13;
    for(int i = res.size() - 1;i &gt;= 0;i--) printf("%d",res[i]);&#13;
    return 0;&#13;
} &#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</guid><pubDate>Thu, 14 Dec 2023 04:27:59 +0000</pubDate></item></channel></rss>