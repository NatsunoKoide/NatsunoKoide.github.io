<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ADd7</title><link>https://natsunokoide.github.io/</link><description>C++ / C# / Unity 
 You are welcome to send us your valuable comments.  E-mail:yujiaqifinn@outlook.com</description><copyright>ADd7</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://i.postimg.cc/dtT4J441/image.png</url><title>avatar</title><link>https://natsunokoide.github.io/</link></image><lastBuildDate>Sun, 21 Jan 2024 11:13:34 +0000</lastBuildDate><managingEditor>ADd7</managingEditor><pubDate>Sun, 21 Jan 2024 11:13:34 +0000</pubDate><ttl>60</ttl><webMaster>ADd7</webMaster><item><title>Unity.Resources资源卸载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-xie-zai.html</link><description>### Resources资源卸载&#13;
&#13;
1. Resources是否存在重复加载资源以及内存消耗&#13;
Resources加载一次资源后，资源会存放在内存中作为缓存。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-xie-zai.html</guid><pubDate>Sun, 21 Jan 2024 11:13:00 +0000</pubDate></item><item><title>Unity.Resources异步加载管理器</title><link>https://natsunokoide.github.io//post/Unity.Resources-yi-bu-jia-zai-guan-li-qi.html</link><description>### Resources异步加载管理器&#13;
&#13;
### 单例模式实现资源异步加载管理&#13;
**用于对象化resources资源的异步加载，使得其他脚本在加载资源的时候更加便利，只需要输入地址和结束后需要响应的函数即可**&#13;
&#13;
&gt; 异步资源加载管理器代码（ResourcesMgr）&#13;
_运用单例模式进行编写，由于没有继承mono所以instance需要实例化_&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
using UnityEngine.Events;&#13;
&#13;
public class ResourcesMgr &#13;
{&#13;
    private static ResourcesMgr instance = new ResourcesMgr();&#13;
    public static ResourcesMgr Instance =&gt; instance;&#13;
    private ResourcesMgr(){}；&#13;
&#13;
    //在Resources类中 对于LoadAsync函数中的泛型T有object约束 所以a as ResourceRequest 需要定义函数内变量的约束&#13;
    //public static ResourceRequest LoadAsync&lt;T&gt;(string path) where T : Object;&#13;
    //泛型unity委托是有参委托&#13;
    public void LoadRes&lt;T&gt;(string address,UnityAction&lt;T&gt; callBack) where T : Object&#13;
    {&#13;
        ResourceRequest rq = Resources.LoadAsync(address);&#13;
        rq.completed += (a) =&gt;&#13;
        {&#13;
            callBack((a as ResourceRequest).asset as T);&#13;
        };&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&gt; 演示如何在text脚本中使用&#13;
```js&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using UnityEngine;&#13;
&#13;
public class Lesson18Text : MonoBehaviour&#13;
{&#13;
    private Texture tex;&#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        ResourcesMgr.Instance.LoadRes&lt;Texture&gt;("软考", (obj) =&gt;&#13;
        {&#13;
            tex = obj;&#13;
        });&#13;
&#13;
    }&#13;
&#13;
    private void OnGUI()&#13;
    {&#13;
        if(tex != null)&#13;
            GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-yi-bu-jia-zai-guan-li-qi.html</guid><pubDate>Sun, 21 Jan 2024 10:54:46 +0000</pubDate></item><item><title>Acwing 338.计数问题</title><link>https://natsunokoide.github.io//post/Acwing%20338.-ji-shu-wen-ti.html</link><description>### 题目&#13;
给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9的出现次数。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20338.-ji-shu-wen-ti.html</guid><pubDate>Sun, 21 Jan 2024 06:44:54 +0000</pubDate></item><item><title>Acwing 900.整数划分（计数DP）</title><link>https://natsunokoide.github.io//post/Acwing%20900.-zheng-shu-hua-fen-%EF%BC%88-ji-shu-DP%EF%BC%89.html</link><description>### 题目&#13;
一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20900.-zheng-shu-hua-fen-%EF%BC%88-ji-shu-DP%EF%BC%89.html</guid><pubDate>Sat, 20 Jan 2024 05:17:20 +0000</pubDate></item><item><title>Acwing 899.编辑距离（最短距离问题的质询版本）</title><link>https://natsunokoide.github.io//post/Acwing%20899.-bian-ji-ju-li-%EF%BC%88-zui-duan-ju-li-wen-ti-de-zhi-xun-ban-ben-%EF%BC%89.html</link><description>### 题目&#13;
给定 n个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-bian-ji-ju-li-%EF%BC%88-zui-duan-ju-li-wen-ti-de-zhi-xun-ban-ben-%EF%BC%89.html</guid><pubDate>Tue, 16 Jan 2024 14:03:31 +0000</pubDate></item><item><title>Unity.Resources资源异步加载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-yi-bu-jia-zai.html</link><description>### Resources异步加载&#13;
### 对于异步加载的定义是什么&#13;
如果加载过大的资源可能会造成程序卡顿&#13;
卡顿的原因就是 从硬盘上把数据读取到内存中 是需要进行计算的&#13;
越大的资源耗时越长，就会造成掉帧卡顿&#13;
&#13;
&gt; Resources异步加载 就是内部新开一个线程进行资源加载 不会造成主线程卡顿&#13;
&#13;
### Resources异步加载方式&#13;
&#13;
1. 通过ResourceRequest中的事件实现异步加载&#13;
```js&#13;
// Unity 在内部 实例化一个rq请求 这个请求会去开一个线程进行资源下载&#13;
ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;("Tex/TestJPG");&#13;
//对资源下载结束这一事件进行监听&#13;
rq.completed += LoadOver;&#13;
//不能直接在 ResourceRequest rq 下一行直接调用 rq.asset 此时资源还没有加载完&#13;
```&#13;
```js&#13;
//completed事件需要形参 AsyncOperation 也就是正在监听是否结束的事件&#13;
private void LoadOver(AsyncOperation rq)&#13;
    {&#13;
        print("加载结束");&#13;
        //asset 是资源对象 加载完毕过后 就能够得到它&#13;
        //需要将AsyncOperation转换为ResourceRequest才能点出asset资源属性才能 再从资源as为目标对象类型&#13;
        tex = (rq as ResourceRequest).asset as Texture;&#13;
    }&#13;
private void OnGUI()&#13;
    {&#13;
        //判定tex对象不为空后 进行gui绘制&#13;
        if (tex != null)&#13;
            GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);&#13;
    }&#13;
```&#13;
2. 通过协程实现 异步加载资源&#13;
```js&#13;
void start()&#13;
{&#13;
     //在start函数中 开启协程 运行 协程函数load&#13;
     StartCoroutine(Load());&#13;
}&#13;
```&#13;
```js&#13;
 IEnumerator Load()&#13;
    {&#13;
        //迭代器函数 当遇到yield return时  就会停止执行之后的代码&#13;
        //协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时&#13;
        ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;("Tex/TestJPG");&#13;
&#13;
        //第一部分&#13;
        //Unity 自己知道 该返回值 意味着你在异步加载资源 &#13;
&#13;
        yield return rq; &#13;
        //通过yield return 一个ResourceRequest 可以让协程知道在运行异步加载&#13;
&#13;
        //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码&#13;
&#13;
         //另一种判断资源是否加载的方式 &#13;
        //判断资源是否加载结束&#13;
        while (!rq.isDone)&#13;
        {&#13;
            //打印当前的 加载进度 &#13;
            //该进度 不会特别准确 过渡也不是特别明显&#13;
            print(rq.progress);&#13;
            yield return null;&#13;
        }&#13;
        tex = rq.asset as Texture;&#13;
&#13;
        //yield return null;&#13;
        ////第二部分&#13;
        //yield return new WaitForSeconds(2f);&#13;
        ////第三部分&#13;
    }&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-yi-bu-jia-zai.html</guid><pubDate>Mon, 15 Jan 2024 12:32:58 +0000</pubDate></item><item><title>Unity.Resources资源动态加载</title><link>https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-dong-tai-jia-zai.html</link><description>### Resources资源动态加载&#13;
&#13;
### 1. Resources资源动态加载的作用&#13;
1. 通过代码动态加载Resources文件夹下指定路径资源&#13;
2. 避免繁琐的拖曳操作&#13;
&#13;
### 2.常用资源类型&#13;
1.预设体对象——GameObject&#13;
2.音效文件——AudioClip&#13;
3.文本文件——TextAsset&#13;
4.图片文件——Texture&#13;
5.其它类型&#13;
&#13;
&gt; 预设体对象加载需要实例化,其它资源加载一般直接用&#13;
&#13;
### 3.资源同步加载 普通方法&#13;
&#13;
1. 在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 打包时 Resources文件夹 里的内容 都会打包在一起.&#13;
2. 预设体对象:第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) 第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化&#13;
```js&#13;
Object obj = Resources.Load("Cube");&#13;
Instantiate(obj);&#13;
```&#13;
_预设体的初始化操作是必须的_&#13;
&#13;
3.音效资源:第一步：就是加载数据 第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可&#13;
```js&#13;
public AudioSource audioS;&#13;
Object obj3 = Resources.Load("Music/BKMusic");&#13;
 audioS.clip = obj3 as AudioClip;&#13;
audioS.Play();&#13;
```&#13;
&#13;
4.文本资源:支持主流格式包括 txt,xml,bytes,json,html,csv……&#13;
```js&#13;
 TextAsset ta = Resources.Load("Txt/Test") as TextAsset;&#13;
 print(ta.text);&#13;
```&#13;
&#13;
5.图片资源&#13;
```js&#13;
private Texture tex;&#13;
tex = Resources.Load("Tex/TestJPG") as Texture;&#13;
```&#13;
&#13;
6.资源同名问题&#13;
显然Resources.Load加载同名资源时 无法准确加载出你想要的内容&#13;
解决方案有：&#13;
   (1)加载指定类型的资源&#13;
```js&#13;
 tex = Resources.Load("Tex/TestJPG", typeof(Texture)) as Texture;&#13;
```&#13;
   (2)加载指定名字的所有资源&#13;
```js&#13;
 Object[] objs = Resources.LoadAll("Tex/TestJPG");&#13;
        foreach (Object item in objs)&#13;
            if (item is Texture)&#13;
            else if (item is TextAsset)&#13;
```&#13;
&#13;
### 4. 解决资源类型和同名问题   泛型方法&#13;
&#13;
&gt; unity在Resources中提供了泛型接口 直接在使用的时候定义好类型即可&#13;
```js&#13;
TextAsset ta2 = Resources.Load&lt;TextAsset&gt;("Tex/TestJPG");&#13;
print(ta2.text);&#13;
tex = Resources.Load&lt;Texture&gt;("Tex/TestJPG");&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.Resources-zi-yuan-dong-tai-jia-zai.html</guid><pubDate>Mon, 15 Jan 2024 07:45:33 +0000</pubDate></item><item><title>Unity.各类特殊文件</title><link>https://natsunokoide.github.io//post/Unity.-ge-lei-te-shu-wen-jian.html</link><description>### 1. 工程路径的获取&#13;
**该方式 获取到的路径 一般情况下 只在 编辑模式下使用&#13;
游戏发布过后 该路径不存在**&#13;
```js&#13;
print(Application.datePath);&#13;
```&#13;
###  2. Resources 资源文件夹&#13;
&#13;
_一般不获取,只能使用Resources相关API进行加载,需要我们自己将创建_&#13;
&#13;
**作用：&#13;
        资源文件夹&#13;
        1-1.需要通过Resources相关API动态加载的资源需要放在其中&#13;
        1-2.该文件夹下所有文件都会被打包出去&#13;
        1-3.打包时Unity会对其压缩加密&#13;
        1-4.该文件夹打包后只读 只能通过Resources相关API加载**&#13;
&#13;
###  3. StreamingAssets 流动资源文件夹&#13;
```js&#13;
print(Application.streamingAssetsPath);&#13;
```&#13;
_可以被主动获取，文件夹需要自己创建 _&#13;
**作用：&#13;
        流文件夹&#13;
        2-1.打包出去不会被压缩加密，可以任由我们摆布&#13;
        2-2.移动平台只读，PC平台可读可写&#13;
        2-3.可以放入一些需要自定义动态加载的初始资源**&#13;
&#13;
### 4. persistentDataPath 持久数据文件夹&#13;
```js&#13;
print(Application.persistentDataPath);&#13;
```&#13;
_可以被主动获取，不需要自己创建文件夹_&#13;
**固定数据文件夹&#13;
        3-1.所有平台都可读可写&#13;
        3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中**&#13;
&#13;
### 5. 其余特殊文件夹&#13;
&#13;
1. Plugins 插件文件夹：一般不获取，自己创建，存放不同平台的插件相关文件。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-ge-lei-te-shu-wen-jian.html</guid><pubDate>Mon, 15 Jan 2024 07:04:08 +0000</pubDate></item><item><title>Acwing 902.最短编辑距离</title><link>https://natsunokoide.github.io//post/Acwing%20902.-zui-duan-bian-ji-ju-li.html</link><description>### 题目&#13;
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：&#13;
1.删除–将字符串 A中的某个字符删除。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20902.-zui-duan-bian-ji-ju-li.html</guid><pubDate>Mon, 15 Jan 2024 04:57:43 +0000</pubDate></item><item><title>Acwing 896.最长上升子序列Ⅱ</title><link>https://natsunokoide.github.io//post/Acwing%20896.-zui-chang-shang-sheng-zi-xu-lie-%E2%85%A1.html</link><description>### 题目&#13;
给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20896.-zui-chang-shang-sheng-zi-xu-lie-%E2%85%A1.html</guid><pubDate>Sun, 14 Jan 2024 14:39:00 +0000</pubDate></item><item><title>Acwing 282.石子合并（区间DP）</title><link>https://natsunokoide.github.io//post/Acwing%20282.-shi-zi-he-bing-%EF%BC%88-qu-jian-DP%EF%BC%89.html</link><description>### 题目&#13;
**设有 N 堆石子排成一排，其编号为 1,2,3,…,N。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20282.-shi-zi-he-bing-%EF%BC%88-qu-jian-DP%EF%BC%89.html</guid><pubDate>Fri, 05 Jan 2024 04:06:36 +0000</pubDate></item><item><title>Hot 100-7 LeetCode 42.接雨水</title><link>https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</link><description>### 题目&#13;
**给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-7%20LeetCode%2042.-jie-yu-shui.html</guid><pubDate>Sat, 30 Dec 2023 08:16:36 +0000</pubDate></item><item><title>Acwing 897.最长公共子序列</title><link>https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</link><description>### 题目&#13;
给定两个长度分别为 N 和 M的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20897.-zui-chang-gong-gong-zi-xu-lie.html</guid><pubDate>Sat, 30 Dec 2023 07:43:48 +0000</pubDate></item><item><title>Acwing 895.最长上升子序列</title><link>https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</link><description>### 题目&#13;
**给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20895.-zui-chang-shang-sheng-zi-xu-lie.html</guid><pubDate>Fri, 29 Dec 2023 04:24:36 +0000</pubDate></item><item><title>Hot 100-6 LeetCode 15.三数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</link><description>### 题目&#13;
**给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-6%20LeetCode%2015.-san-shu-zhi-he.html</guid><pubDate>Thu, 28 Dec 2023 03:59:27 +0000</pubDate></item><item><title>Hot 100-5 LeetCode 11.盛最多水的容器</title><link>https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</link><description>### 题目&#13;
**给定一个长度为 n 的整数数组 height 。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-5%20LeetCode%2011.-sheng-zui-duo-shui-de-rong-qi.html</guid><pubDate>Thu, 28 Dec 2023 03:40:07 +0000</pubDate></item><item><title>Acwing 898.数字三角形</title><link>https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</link><description>### 题目&#13;
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20898.-shu-zi-san-jiao-xing.html</guid><pubDate>Wed, 27 Dec 2023 01:59:41 +0000</pubDate></item><item><title>Hot 100-4 LeetCode 283.移动零</title><link>https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</link><description>### 题目&#13;
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-4%20LeetCode%20283.-yi-dong-ling.html</guid><pubDate>Tue, 26 Dec 2023 03:01:56 +0000</pubDate></item><item><title>Acwing 9.分组背包问题</title><link>https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</link><description>### 分组背包问题&#13;
有 N 组物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%209.-fen-zu-bei-bao-wen-ti.html</guid><pubDate>Mon, 25 Dec 2023 04:17:12 +0000</pubDate></item><item><title>Acwing 5.多重背包问题Ⅱ（二进制优化物品个数问题）</title><link>https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</link><description>### 有 N种物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%205.-duo-zhong-bei-bao-wen-ti-%E2%85%A1%EF%BC%88-er-jin-zhi-you-hua-wu-pin-ge-shu-wen-ti-%EF%BC%89.html</guid><pubDate>Sun, 24 Dec 2023 06:25:08 +0000</pubDate></item><item><title>Acwing 4.多重背包问题Ⅰ</title><link>https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</link><description>### 题目有 N种物品和一个容量是 V的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%204.-duo-zhong-bei-bao-wen-ti-%E2%85%A0.html</guid><pubDate>Sun, 24 Dec 2023 04:34:41 +0000</pubDate></item><item><title>Hot 100-3 LeetCode 128.最长连续序列</title><link>https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</link><description>### 题目&#13;
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-3%20LeetCode%20128.-zui-chang-lian-xu-xu-lie.html</guid><pubDate>Sat, 23 Dec 2023 03:14:47 +0000</pubDate></item><item><title>Acwing 3.完全背包问题 </title><link>https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</link><description>### 完全背包问题&#13;
**有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%203.-wan-quan-bei-bao-wen-ti-%20.html</guid><pubDate>Sat, 23 Dec 2023 02:28:10 +0000</pubDate></item><item><title>Hot 100-2 LeetCode 49.字母异位词分组</title><link>https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</link><description>### 题目&#13;
**给你一个字符串数组，请你将 字母异位词 组合在一起。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-2%20LeetCode%2049.-zi-mu-yi-wei-ci-fen-zu.html</guid><pubDate>Fri, 22 Dec 2023 04:35:06 +0000</pubDate></item><item><title>Acwing 2.01背包问题（要求一维二维数组两组求解方案）</title><link>https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</link><description>### 0-1背包问题&#13;
**有 N 件物品和一个容量是 V 的背包。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%202.01-bei-bao-wen-ti-%EF%BC%88-yao-qiu-yi-wei-er-wei-shu-zu-liang-zu-qiu-jie-fang-an-%EF%BC%89.html</guid><pubDate>Fri, 22 Dec 2023 03:13:13 +0000</pubDate></item><item><title>Hot 100-1 LeetCode 1.两数之和</title><link>https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</link><description>### 题目&#13;
**给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Hot%20100-1%20LeetCode%201.-liang-shu-zhi-he.html</guid><pubDate>Thu, 21 Dec 2023 05:15:36 +0000</pubDate></item><item><title>Acwing 894.拆分-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</link><description>### Nim游戏的基础理论 在 #4 Nim游戏 中&#13;
### 拆分-Nim游戏 的 思考方式类似于集合-Nim游戏 需要针对不同的局面进行异或 #7 （SG函数）&#13;
&#13;
&gt; 拆分-Nim游戏的核心&#13;
**本题主要在于 每一次拆分两组的数量虽然可以大于原石头堆 但是每一组不可以大于原堆的石头数&#13;
   所以每一轮拆分都会至少使得上一轮的最大值-1，从而遍历所有情况总能使得有一方石头堆归零，无法继续操作。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20894.-chai-fen--Nim-you-xi.html</guid><pubDate>Thu, 21 Dec 2023 02:09:57 +0000</pubDate></item><item><title>Acwing 893.集合-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</link><description>### 集合-Nim游戏&#13;
**集合类型的Nim游戏问题在Nim之前需要对每一个集合进行SG函数计算并分析SG的结果**&#13;
&#13;
&gt; 知识点 1 mex( )函数&#13;
_mex（）：设集合S是一个非负整数集合，定义mex（S）为求出不属于S的最小非负整数的运算&#13;
  mes（S）= min[x],其中x属于自然数，且x不属于_&#13;
**可以理解为mex就是得出S中不存在的最小的数**&#13;
&#13;
&gt; 知识点 2 SG( )函数&#13;
_SG( ):：在有向图中，对于每个节点x,设x触发共有k条边，分别到达节点y1，y2……yk&#13;
  SG(x)为x的后继节点的SG值构成的集合执行mex（）运算后的值&#13;
  即SG（x） = mex（SG(y1),SG(y2),SG(y3)……SG（yk））&#13;
性质1：SG(i)  = k，则i最大能到达的SG值为k-1&#13;
性质2：非0可以走向0&#13;
性质3：0只能走向非0_&#13;
&#13;
### 本题最重要的定理&#13;
**对于n个图（集合）如果SG（G1）^SG(G2)^……SG(Gn) != 0 则先手必胜，反之先手必败**&#13;
&#13;
_对于理论部分，引用Acwing用户E.lena的手写图解_&#13;
[https://www.acwing.com/solution/content/23435/](url)&#13;
&#13;
### 题目内容&#13;
**给定 n堆石子以及一个由 k个不同正整数构成的数字集合 S。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20893.-ji-he--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:58:13 +0000</pubDate></item><item><title>Acwing 892.台阶-Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</link><description>### 结论&#13;
**在Acwing 891的基础上，此题将传统Nim游戏问题拓展到台阶，有结论为：如果先手的奇数台阶上的值异或为0，则先手必败，反之亦然。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20892.-tai-jie--Nim-you-xi.html</guid><pubDate>Wed, 20 Dec 2023 02:02:38 +0000</pubDate></item><item><title>Unity.四元数</title><link>https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</link><description>### 轴-角对&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/fb7ce126-6726-4819-bebf-a2dfa19a1f75)&#13;
&#13;
### unity中的四元数结构体 —— Quaternion&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/db2d3b39-ca81-4b03-85ec-c2898ba6e7ae)&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/90418e9d-fb10-4fc1-a528-0ea20316fe95)&#13;
&#13;
&gt; 四元数公式api的使用用例&#13;
```js&#13;
//写一个 绕轴x 60度旋转 的cube&#13;
        Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30) * Mathf.Deg2Rad);&#13;
        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);&#13;
        obj.transform.rotation = q; &#13;
//q2与q相同 只是api不同&#13;
        Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right);&#13;
```&#13;
&#13;
&gt; 四元数和欧拉角转换&#13;
```js&#13;
        //1.欧拉直接赋值给四元数&#13;
        Quaternion q3 = Quaternion.Euler(120, 0, 0);&#13;
        obj.transform.rotation = q3;&#13;
        //2.四元数转欧拉角&#13;
        print(q3.eulerAngles);&#13;
```&#13;
&#13;
&gt; 四元数相乘——旋转（不会万向节死锁）&#13;
```js&#13;
        this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.forward); &#13;
```&#13;
&#13;
&gt; !!!!写一种会产生万向节死锁的方法（错误案例）&#13;
```js&#13;
        e = this.transform.rotation.eulerAngles;&#13;
        e += Vector3.forward;&#13;
        this.transform.rotation = Quaternion.Euler(e);&#13;
```&#13;
### 单位四元数——代表没有旋转&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/7e3c13a5-2def-426e-a612-2443e74416f6)&#13;
&#13;
```js&#13;
#region 知识点1 单位四元数&#13;
        print(Quaternion.identity);&#13;
        //直接让单位四元数赋值会直接让物体转角全部归零&#13;
        //obj.rotation = Quaternion.identity;&#13;
&#13;
        //Instantiate(obj, Vector3.zero, Quaternion.identity);&#13;
 #endregion&#13;
```&#13;
&#13;
### 四元数中的差值运算 + 通过看向的方式让物体一直盯着目标&#13;
```js&#13;
    public Quaternion start;&#13;
    public float time;&#13;
&#13;
    public Transform lookA;&#13;
    public Transform lookB;&#13;
void Start()&#13;
    {&#13;
        start = B.transform.rotation;&#13;
    }&#13;
void Update()&#13;
    {&#13;
&#13;
        #region 知识点2 插值运算 (在Quaternion中有lerp和slerp 但是lerp效果在大角度中一般所以就用slerp)&#13;
        //无限接近&#13;
        A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.transform.rotation, Time.deltaTime);&#13;
        //匀速  time &gt;= 1 到达目标&#13;
        time += Time.deltaTime;&#13;
        B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);&#13;
        #endregion&#13;
        #region 知识点3 lookrotation&#13;
        //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        lookA.rotation = Quaternion.LookRotation(lookB.position - lookA.position);&#13;
        #endregion&#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Unity.-si-yuan-shu.html</guid><pubDate>Tue, 19 Dec 2023 05:54:08 +0000</pubDate></item><item><title>Acwing 891.Nim游戏</title><link>https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</link><description>### Nim游戏中的状态&#13;
**先手必胜状态：先手操作完，可以走到某一个必败状态&#13;
先手必败状态：先手操作完，走不到任何一个必败状态&#13;
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0&#13;
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0**&#13;
&#13;
### 结论&#13;
**假设n堆石头，石头的数量分别是a1，a2，a3……an。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20891.Nim-you-xi.html</guid><pubDate>Tue, 19 Dec 2023 02:21:33 +0000</pubDate></item><item><title>Acwing 890.能被整除的数</title><link>https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</link><description>### 容斥原理&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/74e4f052-c584-420d-9027-d5efab16034b)&#13;
&#13;
### 实现思路&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/9ec8a3d0-3385-4127-a98a-217d07e992be)&#13;
&#13;
&gt; 此处给出一个答案用例 &#13;
&#13;
**n= 10，m = 2 ，p1 = 2， p2 = 3 解释为求1-10中能够满足被2或3整除的数字个数，答案为2，3，4，6，8，9，10，共7个**&#13;
&#13;
### Acwing 890.能被整除的数 代码 + 解析&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
using namespace std;&#13;
&#13;
using LL = long long;&#13;
&#13;
const int N = 20;&#13;
int p[N],n,m;&#13;
int res = 0;&#13;
&#13;
int main()&#13;
{&#13;
    cin &gt;&gt; n &gt;&gt; m;&#13;
    //先把输入的质数存到p数组中&#13;
    for(int i = 0;i &lt; m;i++) cin &gt;&gt; p[i];&#13;
    // 1 &lt;&lt; m 代表的是2的m次方 也就是2的m次方个二进制情况&#13;
    for(int i = 1;i &lt; 1 &lt;&lt; m;i++)&#13;
    {&#13;
        int t = 1;//用于记录当前组质数的总乘积&#13;
        int s = 0; //用来记录这一组二进制数有几个1，几个1代表包含几个集合&#13;
        //遍历当前组的各个位置&#13;
        for(int j = 0;j &lt; m;j++)&#13;
        {&#13;
            //判断到当前位置为1&#13;
            if(i &gt;&gt; j &amp; 1)&#13;
            {&#13;
                //质数的总乘积如果已经大于n呢么就break，此集合是空集&#13;
                if((LL)t * p[j] &gt; n) &#13;
                {&#13;
                    t = -1;&#13;
                    break;&#13;
                }&#13;
                s++; //i &gt;&gt; j &amp; 1 判定到当前位是1 s++&#13;
                t *= p[j]; //把当前1位置的质数乘到t中&#13;
            }&#13;
        }&#13;
        if(t != -1) //如果t的值没有超出总数，就对res进行计算&#13;
        {&#13;
            //这里涉及到容斥原理中 计算集合个数的公式 Si = n/pi（向下取整）（n为总数，pi为质数）&#13;
            //之前用t存储当前组所有质数的乘积 因为 S1交S2 = n/（p1*p2），所以使用t的乘积可以多个集合的情况&#13;
            //s代表1的个数，这是因为容斥原理每一项的系数为（-1）的（n-1）次方（n为1的个数）&#13;
            if(s &amp; 1) res += n / t; //(s &amp; 1)若为1 证明当前组包含奇数个集合（奇数个1）&#13;
            //如果是奇数的组合 根据容斥原理 为+号&#13;
            else res -= n / t; //反之为-号&#13;
        }&#13;
    }&#13;
    cout &lt;&lt; res &lt;&lt; endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
_此题涉及到容斥原理 和 二进制处理集合的情况_。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20890.-neng-bei-zheng-chu-de-shu.html</guid><pubDate>Mon, 18 Dec 2023 09:23:11 +0000</pubDate></item><item><title>Acwing 899.满足条件的01序列</title><link>https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</link><description>### 卡特兰数&#13;
    &#13;
&#13;
&gt; 卡特兰数是组合数学中一个常出现于各种计数问题中的数列。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20899.-man-zu-tiao-jian-de-01-xu-lie.html</guid><pubDate>Sat, 16 Dec 2023 05:23:12 +0000</pubDate></item><item><title>Acwing 888.求组合数IV </title><link>https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</link><description>&#13;
### 求组合数的基础公式：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/d3b140ef-012e-46ab-9edd-974cc4d97757)&#13;
### 其中阶乘可以转化为：&#13;
![image](https://github.com/NatsunoKoide/NatsunoKoide.github.io/assets/137853852/ec00e7e3-2f42-46a3-bbf5-15df59e956fa)&#13;
&#13;
```js&#13;
#include &lt;iostream&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const int N = 5010;&#13;
&#13;
int primes[N],cnt;&#13;
int sum[N];&#13;
bool st[N];&#13;
&#13;
void get_primes(int n)   //线性筛法求质数 cnt是个数 primes数组里装着质数&#13;
{&#13;
    for(int i = 2;i &lt;= n;i++)&#13;
    {&#13;
        if(!st[i]) primes[cnt++] = i;&#13;
        for(int j = 0;primes[j] * i &lt;= n;j++)&#13;
        {&#13;
            st[primes[j] * i] = true;&#13;
            if(i % primes[j] == 0) break;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int get(int n,int p) //// 求n！中包含p的次数&#13;
{&#13;
    int res = 0;&#13;
    while(n)&#13;
    {&#13;
        res += n/p;&#13;
        n /= p;&#13;
    }&#13;
    return res;&#13;
}&#13;
&#13;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b)   //高精度乘法 用vector接收 和 输入 c++才要&#13;
{&#13;
    vector&lt;int&gt; C;&#13;
    int t = 0;&#13;
    for(int i = 0;t || i &lt; A.size();i++)&#13;
    {&#13;
        if(i &lt; A.size()) t += A[i] * b;&#13;
        C.push_back(t % 10);&#13;
        t /= 10;&#13;
    }&#13;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();&#13;
    return C;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    int a,b;&#13;
    cin &gt;&gt; a &gt;&gt; b;&#13;
    get_primes(a);&#13;
    //循环得到每一个质数的次数（这个次数不能重复）&#13;
    for(int i = 0;i &lt; cnt;i++) //cnt在get_primes函数里&#13;
    {&#13;
        int p = primes[i];&#13;
        sum[i] = get(a,p) - get(a-b,p) - get(b,p);&#13;
    }&#13;
    &#13;
    vector&lt;int&gt; res;&#13;
    res.push_back(1);&#13;
    &#13;
    for(int i = 0;i &lt; cnt;i++) //循环质数的个数&#13;
    {&#13;
        for(int j = 0;j &lt; sum[i];j++)//循环质数的次数&#13;
        {&#13;
            res = mul(res,primes[i]); //算出每一个质数的j次方&#13;
        }&#13;
    }&#13;
    //因为高精度乘法最后的输出是每一个数字以vector的方式呈现的 所以需要遍历整个数组才能得到最后的数字&#13;
    for(int i = res.size() - 1;i &gt;= 0;i--) printf("%d",res[i]);&#13;
    return 0;&#13;
} &#13;
```。</description><guid isPermaLink="true">https://natsunokoide.github.io//post/Acwing%20888.-qiu-zu-he-shu-IV%20.html</guid><pubDate>Thu, 14 Dec 2023 04:27:59 +0000</pubDate></item></channel></rss>